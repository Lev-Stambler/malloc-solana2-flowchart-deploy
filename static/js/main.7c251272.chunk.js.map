{"version":3,"sources":["../../../malloc-core/ts-packages/malloc-sdk/lib/index.ts","interfaces.ts","utils/files.ts","utils/graph.ts","globalStore.ts","../../../malloc-spl/src/index.ts","state/flowchart-store.ts","utils/spl-tokens.ts","utils/anchor.ts","utils/action-types.ts","components/node-selector.tsx","components/tokens/TokenAccountChooser.tsx","components/table/table-cells.tsx","components/node-info.tsx","components/graph-visualizer.jsx","utils/errors.ts","utils/sdk-interpelator.ts","components/usdc-airdrop/perform-usdc-airdrop.ts","components/node-visualizer.tsx","components/tablegui.tsx","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx","../../../malloc-spl/src/swap/swap-interfaces.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/utils/tokens.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/constants.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/utils/object.ts","utils/malloc.ts","../../../malloc-spl/src/mint/index.ts","../../../malloc-spl/src/mint-to/index.ts","../../../malloc-spl/src/solend/index.ts","../../../malloc-spl/src/swap/index.ts","../../../malloc-spl/src/transfer/index.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/graph-utils.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/solana-utils.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/malloc-sdk.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/interfaces/index.ts","config/constants.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/builder/index.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/utils/serde.ts"],"names":["InputClassNames","saveStringToFile","data","filename","JSON","stringify","undefined","blob","Blob","type","e","document","createEvent","a","createElement","download","href","window","URL","createObjectURL","dataset","downloadurl","join","initMouseEvent","dispatchEvent","console","error","getFileContent","fileDialog","accept","getSourceNode","g","SOURCE_NODE_ID","getSourceNodeAccount","inp","value","getSourceNodeAmount","getAllVertices","Object","keys","getVertexType","v","split","getNextVertices","vertex","next_actions","map","nextActionSet","slice","nextAction","amount","parseInt","id","filter","i","getNextActionRow","nextMintIdx","className","actionVertex","wholeNumber","INIT_NEXT_ACTION","readOnly","initState","selected","counter","new_action","graph","sourceMint","hiddenInputData","input","CellClassNames","tokenAccountOnlyInit","fractionNumber","globalStore","Store","setGlobalStoreFromFile","fileContents","length","alert","text","parsed","parse","log","setState","downloadGlobalStore","state","MallocSPLBuildActionMap","addActionToMap","actionLib","actionTypeUID","SwapAction","TransferAction","MintAction","MintAndMintToAction","SolendAction","solanaSplStore","derivedTokenAccounts","tokenList","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","ASSOCIATED_TOKEN_PROGRAM_ID","getTokenLists","provider","getCached","TokenListProvider","resolve","tokens","filterByClusterSlug","getConstants","solana","NETWORK","getList","getDemoTokenInfo","usdcMint","PublicKey","demo","FAKE_USDC","aMint","FAKE_TOKEN_A","getMintInfo","usdcInfo","aInfo","chainId","name","symbol","address","findAssociatedTokenAddress","walletAddress","tokenMintAddress","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","associated","findAllAssociatedTokenAddress","mints","Promise","all","m","getTokenAccountInfo","tokenAddr","connection","getAccountInfo","account","parseTokenAccount","mintAddr","parseMintAccount","getProvider","wallet","Provider","Connection","RPC","ACTION_TYPES","getActionTypeUIDFromVertex","vertexType","getActionPIDFromVertex","mallocSpl","SWAP_PROGRAM_ID","TRANSFER_PROGRAM_ID","MINT_TO","SOLEND_ACTION","NodeSelector","useStore","actions","buttonStyle","useAnchorWallet","maxWidth","maxHeight","minWidth","minHeight","useState","Card","CardContent","size","aria-label","style","width","onChange","target","key","display","justifyContent","index","Button","variant","onClick","node_id","toString","init","other","mintAccount","hiddenData","rent","SYSVAR_RENT_PUBKEY","toBase58","serumDexProgramId","projectSerum","DEX_PROGRAM_ID","getInitInputForActionType","new_node","Array","expectedNumberOfOutMints","getModalStyle","top","left","transform","useStyles","makeStyles","theme","createStyles","paper","position","backgroundColor","palette","background","border","boxShadow","shadows","padding","spacing","TokenLine","tok","setChoosen","gridTemplateColumns","gap","info","shortenAddress","mint","balance","utils","toReadableNumber","u64","decimals","TokenAccountChooser","props","onlyWithInitializedAccounts","classes","React","modalStyle","open","setOpen","customTokenAccount","setCustomTokenAccount","customMintAccount","setCustomMintAccount","choosen","solanaSplStoreHook","loadTokens","publicKey","t","associatedAddr","addr","bals","accounts","accountsFiltered","accountsMapped","useEffect","useRef","handleClose","onClose","choosenType","tokenAccount","tokAccountData","mintInfo","bal","body","onBlur","currentTarget","blur","height","zIndex","justifyItems","alignItems","overflow","includeCustomTokenAccount","TextField","label","onFocus","buttonText","InputEditor","Input","cell","isWholeNumber","isFractionNumber","TokenOrMintEditor","onlyWithInitialized","splTok","ActionVertexEditor","vertices","initIdx","indexOf","splice","getActionVertices","active","setActive","pause","setPause","paused","Select","labelId","MenuItem","onMouseOver","TableCellEditor","nextActionMintIdx","mintAccountOnlyInit","NodeInfo","setInput","mintName","sourceAccount","DataEditor","next_action_by_mint","_data","nextActions","object","deepCloneObject","x","setHardCodedNextActions","CardActions","temp","GraphVisualizer","svgRef","nodes","edges","node","node_edges","val","push","source","concat","links","types","color","d3","linkArc","d","Math","hypot","y","create","simulation","force","strength","svg","current","attr","append","selectAll","link","location","call","on","event","alphaTarget","restart","fx","fy","drag","clone","lower","ref","handleError","errorType","eCast","msg","fullError","ErrorGenerator","tokAccount","newFrontendError","PID","MALLOC_PROGRAM_ID","getMallocSdk","MallocSdk","getInputFromActionInput","actionInput","ret","inpItem","getActionData","actionId","allActionIds","incomingVertices","some","nextEdgeSet","includes","getAllIncomingVertexIds","nextNodes","next","actionIdx","fraction","getNextNodes","buildActionInputs","actionPID","actionMetadata","ripeAmount","_buildNonUserSpecificConstruction","hiddenInputDatas","actionVertices","initialSplits","initialActionIndices","actionDatas","getInitialInfo","inAccount","sourceNode","tokenInInfo","amountInF","parseFloat","amountIn","fromReadableNumber","nextFromSource","initialMint","n","compileStateIntoSDKInput","preferredTokenAccounts","nonUserSpecific","builder","buildConstructionFromNonUserSpecific","construction","amountInAccount","opts","run","sdk","buildTxs","sendRequests","prepareCommitment","skipPreflight","preflightCommitment","commitment","actionCommitment","compileAndRunMallocSDK","buildInst","txs","richUSDCAirdroperSK","Uint8Array","richUSDCSigner","Wallet","Keypair","fromSecretKey","getRichUsdcProvider","endpointURL","performUsdcAirdrop","userAddr","tryCreateAssociatedAccount","airdrop","FAKE_USDC_GD","instr","Token","createAssociatedTokenAccountInstruction","tx","Transaction","add","send","gdUsdc","airDropToTokenAccounts","amountAirdrop","transferTxs","createTransferInstruction","NodeVisualizer","loadingAirdrop","setLoadingAirdrop","loadingCompileAndRun","setLoadingCompileAndRun","disabled","then","_","catch","TableGUI","ConnectButton","styled","WalletDialogButton","Home","span","setBalance","message","severity","alertState","setAlertState","useWallet","getBalance","LAMPORTS_PER_SOL","connected","marginTop","toLocaleString","Snackbar","autoHideDuration","Alert","config","anchor","network","rpcHost","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSolletWallet","autoConnect","txTimeout","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","Side","SwapInstructionByte","tryCreateAssociatedAccountInst","owner","payer","inst","associateTokAccount","transferToTx","destination","authority","signer","secretKey","transfer","signers","getTokenAccountUsedByMalloc","tokenAuthority","createTokenAccountsForActions","fundingAccount","getMintsNoDuplicates","tokenCreationOptions","skipOutTokenCreations","skipIdxs","tokenMintOuts","forEach","skipInTokenCreation","tokenMintIn","flat","pk","associatedToSignerAccount","insts","createTokTx","Set","pkToStr","number","wholeStr","substring","fractionStr","padStart","pattern","test","replace","formatWithCommas","wholePart","fracPart","Error","padEnd","CONSTRUCTION_ACCOUNT_SIZE","LIFETIME_RESULT_ACCOUNT_MS","ONE_HOUR_MS","LIFETIME_CONSTRUCTION_ACCOUNT_MS","LAMPORTS_PER_EPOCH","MS_PER_EPOCH","obj","constructor","chars","buildIsolatedMintAction","inMint","inTokenAccount","dummyPassThroughActionPID","amountOutExpanded","amountOut","outTokenAccount","serializeData","createMintInstructions","addDefaultTokAccounts","actionData","tokenAccountOuts","actionAccounts","actionProgram","additionalSigners","instructions","isolatedAction","Buffer","from","buildIsolatedAction","ActionData","serde","Assignable","schema","Map","kind","fields","inputMint","inputTokenAccount","mintToPID","authoritySigner","authoritySecret","createMintSecretKey","associateTokAccountRecipient","optionalAmountWholeNumber","initialSupply","atStartTxs","borshSer","amount_override","isWriteable","isSigner","atStartOfPrepareTxs","solendActionPID","mintIn","tokenAccountIn","solendConfig","solend","assetSymbol","assets","find","asset","mintAddress","mainMarket","markets","reserve","reserves","r","collateralMint","collateralMintAddress","destinationCollateralAccount","oracle","oracles","o","refreshReserveInstruction","priceAddress","refreshData","programID","liquidityAddress","authorityAddress","SYSVAR_CLOCK_PUBKEY","TransactionInstruction","programId","pubkey","isWritable","switchboardFeedAddress","buildIsolatedSwapAction","swapPID","outMint","buildSwapAccounts","swapInfo","packSwapData","BasicSwap","side","minOut","swapAccountsToActionAccounts","swapAccounts","preActionTxs","openOrderInitTx","serumDexId","getMarket","marketRet","marketPk","Market","load","marketSel","getOpenOrdersAccount","openOrderAccountData","getVaultOwnerAndNonce","decoded","ownAddress","vaultSigner","coinWallet","Bid","pcWallet","market","requestQueue","eventQueue","bids","asks","coinVault","baseVault","pcVault","quoteVault","openOrders","openOrdersAccount","openOrderPk","orderPayerTokenAccount","dexProgram","tokenProgram","openOrderTx","dexPID","OpenOrders","findForMarketAndOwner","openOrderAccount","Account","openOrdersTx","makeCreateAccountTransaction","Ask","getMarketsFromBaseMinttoQuoteMint","marketPks","instrByte","packedMinOut","toArrayLike","initPart","referralAccount","outAccount","marketPublicKey","dexProgramId","nonce","BN","toNumber","createProgramAddress","vaultOwner","iaddn","baseMint","quoteMint","serumProgId","getLayout","findAccountsByMints","transferPID","recipient","recipientWallet","createTokInstr","equals","buildSeqListOfActionCalls","actionMetas","initIndices","initHitCounts","fill","simulateDAG","hitCounts","toHit","newHitCounts","getOccurrence","newRipeActions","newToHit","array","calculateRent","durationMs","ceil","mallocProgram","this","Program","MALLOC_IDL","_authority","_inAuth","amountInAuthority","tokenAccounts","tokenTxs","createAndInitConstruction","constructionTx","addConstructionActionsTx","addActionsToConstruction","checkMintsAreTheSame","initMint","transferTx","prepareConstructionTx","prepareConstruction","hitOrder","initResultAccount","ACTION_TEMPLATE_IDL","initResultAccounts","actionCtxFilled","action","toAdd","ctx","resultAccount","processTxs","hitIndex","processAction","getAllAtStartOfPrepareTxs","txsPrepare","txsActionsCalls","txsActionCalls","resultAccounts","fetch","constructionState","actionSerialize","nextNode","actionCallSerialize","numbTimesHit","callAmount","actionCalls","readyCallIdxList","constructionData","options","sendAll","txHashesPrepare","onPrepareAccountsDone","txHashes","program","numbActions","ConstructionAccount","web3","generate","transaction","SystemProgram","createAccount","fromPubkey","newAccountPubkey","space","lamports","initConstruction","actionMetadataWithU64","addActions","initActionIdx","initActionSplits","actionAccountsCtx","auth","tokauth","signersIsolated","actionCtxProxy","actionTemplateProgram","numberOfPossibleOutputTokens","result","getMinimumBalanceForRentExemption","resultSize","calcSizeResultAccount","numberOfActions","every","env","process","DUMMY_PASS_THROUGH","INITIAL_SPLITTER_ID_UUID","getMintAccountFromPriorActions","idx","idxInNextNodes","item","getPreviousActions","prev","firstMint","buildActionMap","initTokenAccount","initMintAccount","orderActionsHit","buildFN","mergeConstructions","parentConstruction","childConstruction","appendChildInitToParent","childConstructionCloned","parentConstructionClone","newActionDatasArray","offset","nextNodeSet","childInitialActionsToAdd","appendToInitial","splitFrac","indexInParent","nextNodeIdx","c","properties"],"mappings":"sHAAA,uL,qnCCMYA,E,4NAAAA,K,6BAAAA,E,6BAAAA,E,2BAAAA,E,+CAAAA,E,6CAAAA,E,2BAAAA,E,iCAAAA,E,eAAAA,M,2BCACC,EAAmB,SAACC,EAAWC,GAC1C,GAAKD,EAAL,CAKKC,IAAUA,EAAW,gBAEN,kBAATD,IACTA,EAAOE,KAAKC,UAAUH,OAAMI,EAAW,IAGzC,IAAIC,EAAO,IAAIC,KAAK,CAACN,GAAO,CAAEO,KAAM,cAClCC,EAAIC,SAASC,YAAY,eACzBC,EAAIF,SAASG,cAAc,KAE7BD,EAAEE,SAAWZ,EACbU,EAAEG,KAAOC,OAAOC,IAAIC,gBAAgBZ,GACpCM,EAAEO,QAAQC,YAAc,CAAC,YAAaR,EAAEE,SAAUF,EAAEG,MAAMM,KAAK,KAC/DZ,EAAEa,eACA,SACA,GACA,EACAN,OACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,EACA,EACA,MAEFJ,EAAEW,cAAcd,QAlCde,QAAQC,MAAM,YAqCLC,EAAc,uCAAG,sBAAAd,EAAA,sEAChBe,IAAW,CACvBC,OAAQ,qBAFoB,mFAAH,qDC/BdC,EAAgB,SAACC,GAAD,OAAkBA,EAAEC,IAEpCC,EAAuB,SAACC,GAAD,OAA0BA,EAAI,GAAG,GAAGC,OAC3DC,EAAsB,SAACF,GAAD,OAA0BA,EAAI,GAAG,GAAGC,OAC1DE,EAAiB,SAACN,GAAD,OAA4BO,OAAOC,KAAKR,IAQzDS,EAAgB,SAACC,GAAD,OAC3BA,EAAEC,MAAM,KAAK,IAGFC,EAAkB,SAC7BZ,EACAa,GAiBA,OAfoBb,EAAEa,GAAQC,aACNC,KAAI,SAACC,GAY3B,OAX8BA,EAAcC,MAAM,GACXF,KAAI,SAACG,GAC1C,OAAKA,EAAW,GAAGd,OAAUc,EAAW,GAAGd,MAGpC,CACLe,OAAQC,SAASF,EAAW,GAAGd,OAC/BiB,GAAIH,EAAW,GAAGd,OAJX,QAQKkB,QAAO,SAAC3C,EAAG4C,GAAJ,OAAgB,OAAN5C,SAKxB6C,EAAmB,SAACC,GAC/B,MAAO,CACL,CAAErB,MAAO,GAAIsB,UAAU,GAAD,OAAKzD,EAAgB0D,aAArB,YAAqCF,IAC3D,CAAErB,MAAO,GAAIsB,UAAWzD,EAAgB2D,eChC/B3B,EAAiB,WAEjB4B,EAAiC,CAC5C,CACE,CAAEzB,MAAO,eAAgB0B,UAAU,GACnC,CAAE1B,MAAO,iBAAkB0B,UAAU,IAEvCN,EAAiB,IAGbO,EAAyB,CAC7BC,SAAU/B,EACVgC,QAAS,EACTC,WAAY,aACZC,MAAO,GACPC,WAAY,UACZC,gBAAiB,IAGnBN,EAAUI,MAAMlC,GAAkB,CAChCqC,MAAO,CACL,CACE,CACElC,MAAO,oBACP0B,UAAU,GAEZ,CAAE1B,MAAO,GAAIsB,UAAWa,EAAeC,uBAEzC,CACE,CACEpC,MAAO,SACP0B,UAAU,GAEZ,CAAE1B,MAAO,GAAIsB,UAAWa,EAAeE,kBAG3C3B,aAAc,CAACe,IAGV,IAAMa,EAAc,IAAIC,QAAmBZ,GAIrCa,EAAsB,uCAAG,8BAAA9D,EAAA,sEACTc,IADS,aAC9BiD,EAD8B,QAEnBC,OAAS,GAFU,uBAGlCC,MAAM,wBAH4B,sCAOrB1E,KAPqB,SAOJwE,EAAa,GAAGG,OAPZ,mBAO9BC,EAP8B,KAOhBC,MAPgB,gBAQpCxD,QAAQyD,IAAIF,GAEZA,EAAOd,MAAMlC,GAAgBqC,MAAM,GAAG,GAAGlC,MAAQ,GACjDsC,EAAYU,SAASH,GAXe,4CAAH,qDActBI,EAAmB,uCAAG,sBAAAvE,EAAA,sEAC3BZ,EAAiBG,KAAKC,UAAUoE,EAAYY,OAAQ,aADzB,2CAAH,qD,6CCnEnBC,EAA0C,GAGjDC,EAAiB,SAACC,GACtBF,EAAwBE,EAAUC,eAAiBD,GAGrDD,EAAeG,KACfH,EAAeI,KACfJ,EAAeK,KACfL,EAAeM,KACfN,EAAeO,K,uCCCFC,GAAiB,IAAIrB,QAAiB,CACjDsB,qBAAsB,KACtBC,UAAW,OCRPC,GACJC,8BAKWC,GAAa,uCAAG,WAC3BC,GAD2B,iBAAAxF,EAAA,6DAGrByF,EAHqB,+BAAAzF,EAAA,MAGT,8BAAAA,EAAA,0DACZkF,GAAeV,MAAMY,UADT,yCAC2BF,GAAeV,MAAMY,WADhD,wBAEK,IAAIM,KAAoBC,UAF7B,cAEVC,EAFU,OAGVR,EAAYQ,EACfC,oBAAoBC,cAAeC,OAAOC,SAC1CC,UACHf,GAAeZ,SAAf,2BACKY,GAAeV,OADpB,IAEEY,eARc,kBAUTA,GAVS,2CAHS,8DAeHK,IAfG,UAerBL,EAfqB,OAkBW,WAAlCU,cAAeC,OAAOC,QAlBC,iDAmBdZ,GAnBc,mBAmBOc,GAAiBV,GAnBxB,oIAqBlBJ,GArBkB,4CAAH,sDAyBpBc,GAAgB,uCAAG,WAAOV,GAAP,qBAAAxF,EAAA,6DACjBmG,EAAW,IAAIC,YAAUN,cAAeO,KAAKC,WAC7CC,EAAQ,IAAIH,YAAUN,cAAeO,KAAKG,cAFzB,SAGAC,GAAYjB,EAAUW,GAHtB,cAGjBO,EAHiB,gBAIHD,GAAYjB,EAAUe,GAJnB,UAIjBI,EAJiB,OAKlBD,GAAaC,EALK,sBAMf,gCANe,iCAQhB,CAAC,2BAEDD,GAFA,IAGHE,SAAU,EACVC,KAAM,YACNC,OAAQ,QACRC,QAASjB,cAAeO,KAAKC,YAN1B,2BASAK,GATA,IAUHC,SAAU,EACVC,KAAM,gBACNC,OAAQ,WACRC,QAASjB,cAAeO,KAAKG,iBArBV,4CAAH,sDAgCTQ,GAA0B,uCAAG,WACxCC,EACAC,GAFwC,eAAAlH,EAAA,sEAIfoG,YAAUe,mBACjC,CACEF,EAAcG,WACdC,mBAAiBD,WACjB,IAAIhB,YAAUc,GAAkBE,YAElC/B,IAVsC,cAIlCiC,EAJkC,yBAYjCA,EAAW,IAZsB,2CAAH,wDAc1BC,GAA6B,uCAAG,WAC3CN,EACAO,GAF2C,SAAAxH,EAAA,+EAI3CyH,QAAQC,IAAIF,EAAMvF,KAAI,SAAC0F,GAAD,OAAOX,GAA2BC,EAAeU,QAJ5B,2CAAH,wDAM7BC,GAAmB,uCAAG,WACjCpC,EACAqC,GAFiC,iBAAA7H,EAAA,sEAIXwF,EAASsC,WAAWC,eAAeF,GAJxB,UAI3BG,EAJ2B,gDAKZ,MALY,uBAOzB3I,EAAO4I,4BAAkBD,EAAQ3I,MAPR,kBAQxBA,GARwB,yCAU/BuB,QAAQC,MAAM,oDAAd,MAV+B,kBAWxB,MAXwB,0DAAH,wDAenB4F,GAAW,uCAAG,WACzBjB,EACA0C,GAFyB,eAAAlI,EAAA,sEAIHwF,EAASsC,WAAWC,eAAeG,GAJhC,UAInBF,EAJmB,gDAKJ,MALI,gCAMlBG,2BAAiBH,EAAQ3I,OANP,2CAAH,wD,UChHX+I,GAAc,SAACC,GAC1B,OAAO,IAAIC,KAAS,IAAIC,aAAWzC,cAAeC,OAAOyC,KAAMH,EAAQ,K,UCiB5DI,GAA8B,CACzC,aACA,WACA,OACA,4BAGWC,GAA6B,SAACC,GACzC,GAAmB,eAAfA,EACF,OAAO9D,IAAWD,cACb,GAAmB,aAAf+D,EACT,OAAO7D,IAAeF,cACjB,GAAmB,SAAf+D,EACT,OAAO3D,IAAoBJ,cACtB,GAAmB,6BAAf+D,EACT,OAAO1D,IAAaL,cACf,uCAAiC+D,IAI7BC,GAAyB,SAACD,GACrC,GAAmB,eAAfA,EACF,OAAO7C,cAAe+C,UAAUC,gBAC3B,GAAmB,aAAfH,EACT,OAAO7C,cAAe+C,UAAUE,oBAC3B,GAAmB,SAAfJ,EACT,OAAO7C,cAAe+C,UAAUG,QAC3B,GAAmB,6BAAfL,EACT,OAAO7C,cAAe+C,UAAUI,cAElC,KAAK,2BAAL,OAAiCN,I,SCqHpBO,GAhIU,WAErB,IAAM1E,EAAQ2E,mBAASvF,GACjBwF,EAAUX,GAEVY,GADSC,4BACK,CAChBC,SAAU,OACVC,UAAW,OACXC,SAAU,OACVC,UAAW,SATY,EAaiBC,oBAAS,GAb1B,gCAc6BA,oBAAS,IAdtC,6BAuC3B,OACI,eAACC,EAAA,EAAD,UACI,gBAACC,EAAA,EAAD,WACI,0CAEA,yBACAtH,GAAG,gBACHK,UAAU,cACVkH,KAAM,GACNC,aAAW,wBACXC,MAAO,CAAEC,MAAO,SAChBC,SAAU,SAACrK,GACP+D,EAAYU,SAAS,CAAEpB,SAAUrD,EAAEsK,OAAO7I,SAP9C,SAUCG,OAAOC,KAAK8C,EAAMnB,OAAOpB,KAAI,SAAUmI,EAAK9I,GACzC,OAAO,yBAAQA,MAAO8I,EAAf,SAAqBA,SAIhC,uBAAKJ,MAAO,CAAEC,MAAO,OAAQI,QAAS,OAAQC,eAAgB,UAA9D,UAEI,yBACI1H,UAAU,cACVmH,aAAW,yBACXG,SAAU,SAACrK,GACP+D,EAAYU,SAAS,CAAElB,WAAYvD,EAAEsK,OAAO7I,SAJpD,SAOK8H,EAAQnH,KAAI,SAACX,EAAOiJ,GACjB,OAAO,yBAAQjJ,MAAOA,EAAf,SAAuBA,SAItC,eAACkJ,EAAA,EAAD,CACAC,QAAQ,OACRT,MAAOX,EACPqB,QAAS,WACL,IAAIC,EAAUnG,EAAMpB,WAAa,IAAMoB,EAAMrB,QAAQyH,WAC/CC,EDhEW,SACvCjL,GAEA,OAAQA,GACN,IAAK,2BACH,MAAO,CACL4D,MAAO,IAEX,IAAK,OACH,MAAO,CACLA,MAAO,CACL,CACE,CACElC,MAAO,WACP0B,UAAU,GAEZ,CACE1B,MAAO,IACPsB,UAAWzD,EAAgB2D,cAG/B,CACE,CACExB,MAAO,gBACP0B,UAAU,GAEZ,CACE1B,MAAO,GACPsB,UAAWzD,EAAgBwE,mBAMrC,IAAK,WACH,MAAO,CACLH,MAAO,CACL,CACE,CACElC,MAAO,kBACP0B,UAAU,GAEZ,CAAE1B,MAAO,GAAIsB,UAAWzD,EAAgB2L,UAKhD,IAAK,aACH,MAAO,CACLtH,MAAO,CACL,CACE,CACElC,MAAO,UACP0B,UAAU,GAEZ,CAAE1B,MAAO,GAAIsB,UAAWzD,EAAgB4L,cAE1C,CACE,CACEzJ,MAAO,SACP0B,UAAU,GAEZ,CAAE1B,MAAO,GAAIsB,UAAWzD,EAAgB2D,eAG5CkI,WAAY,CACVC,KAAMC,qBAAmBC,WACzBC,kBAAmBtF,cAAeuF,aAAaC,iBAIrD,QACE,KAAK,0BAAL,OAAgC1L,ICRD2L,CACT/G,EAAMpB,YAENoI,EAAqB,CACrBhI,MAAOqH,EAAKrH,MAEZxB,aAAc,YACXyJ,MACChH,EACAiE,GACIlE,EAAMpB,aAERsI,2BAEJzJ,KAAI,SAACQ,GAAD,OAAOM,MAEjByB,EAAMnB,MAAMsH,GAAWa,EACvBhH,EAAMjB,gBAAgBoH,GAAWE,EAAKG,YAAc,GACpDpH,EAAYU,SAAZ,2BACOE,GADP,IAEItB,SAAUyH,EACVxH,QAASqB,EAAMrB,QAAU,EACzBE,MAAM,eAAMmB,EAAMnB,WA3B1B,eAiCA,eAACmH,EAAA,EAAD,CACAC,QAAQ,OACRT,MAAOX,EACPqB,QAAS,WACiB,YAAlBlG,EAAMtB,kBACHsB,EAAMnB,MAAMmB,EAAMtB,UACzBU,EAAYU,SAAZ,2BACGE,GADH,IAEAtB,SAAU,WACVG,MAAM,eAAMmB,EAAMnB,YATtB,wB,2GCzHpB,SAASsI,KAIP,MAAO,CACLC,IAAI,GAAD,OAJO,GAIP,KACHC,KAAK,GAAD,OAJO,GAIP,KACJC,UAAU,cAAD,OANC,GAMD,eALE,GAKF,OAIb,IAAMC,GAAYC,cAAW,SAACC,GAAD,OAC3BC,aAAa,CACXC,MAAO,CACLC,SAAU,WACVnC,MAAO,OACPoC,gBAAiBJ,EAAMK,QAAQC,WAAWJ,MAC1CK,OAAQ,iBACRC,UAAWR,EAAMS,QAAQ,GACzBC,QAASV,EAAMW,QAAQ,EAAG,EAAG,SAK7BC,GAAY,SAAC,GAMZ,IALLC,EAKI,EALJA,IACAC,EAII,EAJJA,WAKA,OACE,uBACE/C,MAAO,CACLK,QAAS,OACT2C,oBAAqB,sBACrB/C,MAAO,OACPgD,IAAK,OALT,UAQE,yBAAQvC,QAASqC,EAAjB,oBACA,+BAAMD,EAAII,KAAKrG,OACf,+BAAMsG,YAAeL,EAAII,KAAKE,KAAKjC,cACnC,iCACGgC,YAAeL,EAAI9E,SACnB8E,EAAIO,QAAU,GAAK,8BAEtB,+BACGC,SAAM1H,OAAO2H,iBACZ,IAAIC,MAAIV,EAAIO,SAAW,GACvBP,EAAII,KAAKO,gBAOJ,SAASC,GAAoBC,GAKxC,IAAD,EACKC,EAA2B,UAAGD,EAAMC,mCAAT,SAC3BC,EAAU9B,KAFf,EAIoB+B,IAAMnE,SAASgC,IAA7BoC,EAJN,sBAKuBD,IAAMnE,UAAS,GALtC,mBAKMqE,EALN,KAKYC,EALZ,OAMmDH,IAAMnE,SAAS,IANlE,mBAMMuE,EANN,KAM0BC,EAN1B,OAOiDL,IAAMnE,SAAS,IAPhE,mBAOMyE,EAPN,KAOyBC,EAPzB,KAQKhG,EAASiB,4BARd,EAU6BK,oBAAU,GAVvC,mBAUM2E,EAVN,KAUevB,EAVf,KAWKwB,EAAqBpF,mBAASjE,IAE9BM,EAAW4C,GAAYC,GAEvBmG,EAAU,uCAAG,sCAAAxO,EAAA,sEACOuF,GAAcC,GADrB,cACXJ,EADW,gBAEYmC,GAA6B,OACxDc,QADwD,IACxDA,OADwD,EACxDA,EAAQoG,UACRrJ,EAAUnD,KAAI,SAACyM,GAAD,OAAOA,EAAE3H,YAJR,cAEX4H,EAFW,gBAOElH,QAAQC,IACzBiH,EAAe1M,IAAf,+BAAAjC,EAAA,MAAmB,WAAO4O,GAAP,eAAA5O,EAAA,sEACE4H,GAAoBpC,EAAUoJ,GADhC,cACXvP,EADW,gCAEVA,QAFU,IAEVA,OAFU,EAEVA,EAAMgD,QAFI,2CAAnB,wDARe,OAOXwM,EAPW,OAaXC,EAAWH,EAAe1M,KAAI,SAAC2M,EAAMnM,GACzC,MAAO,CACLuF,QAAS4G,EAAKzD,WACd+B,KAAM9H,EAAU3C,GAChB4K,QAASwB,EAAKpM,OAGZsM,EAAmBnB,EACrBkB,EAAStM,QAAO,SAACC,GAAD,OAAOA,EAAE4K,WACzByB,EACEE,EAAiBD,EAAiB9M,KAAI,SAACQ,GAAO,IAAD,EACjD,OAAO,2BACFA,GADL,IAEEyK,KAAK,2BACAzK,EAAEyK,MADH,IAEFE,KAAM,IAAIhH,YAAU3D,EAAEyK,KAAKnG,WAE7BsG,SAAS,UAAA5K,EAAE4K,eAAF,eAAWzC,aAAc,UAItC1F,GAAeZ,SAAf,2BACKiK,GADL,IAEEpJ,qBAAsB6J,KApCP,4CAAH,qDAwChBC,qBAAU,WACRT,MACC,IAEcU,iBAAO,MAAxB,IAOMC,EAAW,uCAAG,sCAAAnP,EAAA,yDACbuO,EAAmBpJ,qBADN,uBAEhB8I,GAAQ,GACRN,EAAMyB,UAHU,+BAMdd,GAAW,GANG,gBAOhBX,EAAMyB,QAAQb,EAAmBpJ,qBAAqBmJ,IAPtC,2BAWG,WAFbe,GAA2B,IAAbf,EAAiB,QAAU,SAEhBJ,KACZ,SAAhBmB,GAA2BjB,GAZd,wBAcdH,GAAQ,GACRN,EAAMyB,UAfQ,8BAoBE,UAAhBC,EApBc,sBAqBVnB,EArBU,yCAuBFlH,GACJqB,EAAQoG,UACRL,GAzBM,oBA2BRjD,WA3BQ,eAmBVmE,EAnBU,eA4Ba1H,GAC3BpC,EACA,IAAIY,YAAUkJ,IA9BA,WA4BVC,EA5BU,OAgCI,UAAhBF,GAA4BE,EAhChB,wBAiCdtL,MAAM,wDACNgK,GAAQ,GACRN,EAAMyB,UAnCQ,8BAuCE,SAAhBC,IACsC,IAAtC1B,EAAMC,6BACL2B,EAzCa,wBA2CdtL,MACE,wEAEFgK,GAAQ,GACRN,EAAMyB,UA/CQ,kCAkDVlH,EACY,UAAhBmH,EACIE,EAAgBnC,KAChB,IAAIhH,YAAUgI,GArDJ,UAuDO3H,GAAYjB,EAAU0C,GAvD7B,WAuDVsH,EAvDU,+BAyDdvL,MAAM,6DACNgK,GAAQ,GACRN,EAAMyB,UA3DQ,2BA8DVK,GAAoB,OAAdF,QAAc,IAAdA,OAAA,EAAAA,EAAgBlN,SAAU,IAAImL,MAAI,GAC9CG,EAAMyB,QAAQ,CACZ/B,QAASoC,EACTzH,QAASsH,EACTpC,KAAK,2BACAsC,GADD,IAEFpC,KAAMlF,MApEM,QAwElB+F,GAAQ,GACRN,EAAMyB,UAzEY,4CAAH,qDA4EXM,EACJ,sBACEC,OAAQR,EACRvM,UAAU,UAEV8H,QAAS,SAAC7K,GAAD,OAAOA,EAAE+P,cAAcC,QAChC7F,MAAO,CACLoC,SAAU,QACVR,IAAK,IACLC,KAAM,IACNiE,OAAQ,QACR7F,MAAO,QACP8F,OAAQ,IACR1F,QAAS,OACT2F,aAAc,SACd1F,eAAgB,SAChB2F,WAAY,UAfhB,SAkBE,uBAAKjG,MAAK,eAAO+D,GAAcnL,UAAWiL,EAAQ1B,MAAlD,UACE,qBAAI5J,GAAG,qBAAP,oCACA,oBAAGA,GAAG,2BAAN,uFAIA,uBACEK,UAAU,UACVoH,MAAO,CAAEkG,SAAU,SAAU1G,UAAW,QAF1C,UAIE,uBACEQ,MAAO,CACLK,QAAS,OACT2C,oBAAqB,uBAHzB,UAME,0BACA,6CACA,gDACA,yDACA,6CAEAuB,EAAmBpJ,qBAEjBoJ,EAAmBpJ,qBAAqBlD,KAAI,SAAC6K,EAAKrK,GAAN,OAC1C,uBAEEuH,MAAO,CACL2C,QAAS,SACTH,OAAQ8B,IAAY7L,EAAI,kBAAoB,OAJhD,UAOE,eAAC,GAAD,CACEqK,IAAKA,EACLC,WAAY,WACVA,EAAWtK,MAGf,0BAbF,gCACgCA,OAHlC,aAmBHkL,EAAMwC,2BACL,sBACEnG,MAAO,CACL2C,QAAS,SACTH,QAAqB,IAAb8B,EAAiB,kBAAoB,OAHjD,SAME,eAAC8B,GAAA,EAAD,CACEC,MAAM,uBACN/O,MAAO4M,EACPhE,SAAU,SAACrK,GAAD,OAAOsO,EAAsBtO,EAAEsK,OAAO7I,QAChDgP,QAAS,kBAAMvD,GAAY,QAIjC,oCACA,sBACE/C,MAAO,CACL2C,QAAS,SACTH,QAAqB,IAAb8B,EAAiB,kBAAoB,OAHjD,SAME,eAAC8B,GAAA,EAAD,CACEC,MAAM,sBACN/O,MAAO8M,EACPlE,SAAU,SAACrK,GAAD,OAAOwO,EAAqBxO,EAAEsK,OAAO7I,QAC/CgP,QAAS,kBAAMvD,GAAY,gBAQvC,OACE,iCACE,yBAAQnN,KAAK,SAAS8K,QAlLP,WACjB8D,IACAP,GAAQ,IAgLN,SACGN,EAAM4C,YAAc,yBAUtBvC,GAAQ0B,KClUf,I,MAAMc,GAAc,SAClB7C,GAII,IAAD,EACH,OACE,eAAC8C,GAAA,EAAD,CACEvG,SAAU,SAACrK,GACT8N,EAAMzD,SAAN,2BACKyD,EAAM+C,MADX,IAEEpP,MAAOqM,EAAMgD,cACTrO,SAASzC,EAAEsK,OAAO7I,OAAOsJ,WACzB/K,EAAEsK,OAAO7I,UAGjBA,OAAO,UAAAqM,EAAM+C,YAAN,eAAYpP,QAAS,GAC5B1B,KAAM+N,EAAMiD,kBAAoBjD,EAAMgD,cAAgB,SAAW,UAKjEE,GAAoB,SACxBlD,GAKA,OACE,+BACE,eAACD,GAAD,CACE6C,WAAY,SACZ3C,4BAA6BD,EAAMmD,oBACnC1B,QAAS,SAAC2B,GACR,GAAIA,EAAQ,CACV,IAAMzP,EACW,UAAfqM,EAAM/N,KACFmR,EAAO/I,QACP+I,EAAO7D,KAAKE,KAAKjC,WACvBwC,EAAMzD,SAAN,2BACKyD,EAAM+C,MADX,IAEEpP,kBASR0P,GAAqB,SACzBrD,GAGI,IAAD,EAEGsD,ETtDyB,SAAC/P,GAChC,IAAMwG,EAAMjG,OAAOC,KAAKR,GAClBgQ,EAAUxJ,EAAIyJ,QAAQhQ,GAE5B,OADAuG,EAAI0J,OAAOF,EAAS,GACbxJ,ESkDU2J,CADHlI,mBAASvF,GACkBP,OAFtC,EAGyBsG,oBAAS,GAHlC,mBAGI2H,EAHJ,KAGYC,EAHZ,OAIuB5H,oBAAS,GAJhC,mBAII6H,EAJJ,KAIWC,EAJX,KAWH,OACE,+BACE,eAAC,KAAD,CAAWH,OAAQA,EAAQI,OAAQF,EAAnC,SACE,eAACG,GAAA,EAAD,CACEC,QAAQ,2BACRrP,GAAG,qBACHjB,MAAK,UAAEqM,EAAM+C,YAAR,aAAE,EAAYpP,MACnB+O,MAAM,MACNrG,MAAO,CACL8F,OAAQ,QANZ,SASGmB,EAAShP,KAAI,SAACM,GACb,OACE,gCACE,eAACsP,GAAA,EAAD,CACE7H,MAAO,CAAE+F,OAAQ,KACjBzO,MAAOiB,EACPuP,YAAa,kBAAML,GAAS,IAC5BnB,QAAS,kBAxBR,SAAC/N,GAChBoL,EAAMzD,SAAN,2BAAoByD,EAAM+C,MAA1B,IAAgCpP,MAAOiB,KACvCgP,GAAU,GAsBmBjN,CAAS/B,IAJ1B,SAMGA,KAPL,sBAA0BA,cAkB3BwP,GAAiD,SAC5DpE,GACI,IAAD,EAEH,SADmB,UAAAA,EAAM+C,YAAN,eAAY9N,YAAa,IAAIf,MAAM,KAAK,IAEzD,KAAK1C,EAAgB0D,aACnB,IAAMmP,EAAoB1P,SACxBqL,EAAM+C,KAAM9N,UAAWf,MAAM,KAAK,IAAM,IAE1C,OAAOmP,GAAmB,2BAAKrD,GAAN,IAAaqE,uBACxC,KAAK7S,EAAgB8S,oBACnB,OAAOpB,GAAkB,2BACpBlD,GADmB,IAEtB/N,KAAM,OACNkR,qBAAqB,KAEzB,KAAK3R,EAAgBuE,qBACnB,OAAOmN,GAAkB,2BACpBlD,GADmB,IAEtB/N,KAAM,QACNkR,qBAAqB,KAEzB,KAAK3R,EAAgB4L,YACnB,OAAO8F,GAAkB,2BACpBlD,GADmB,IAEtB/N,KAAM,OACNkR,qBAAqB,KAEzB,KAAK3R,EAAgBmQ,aACnB,OAAOuB,GAAkB,2BACpBlD,GADmB,IAEtB/N,KAAM,QACNkR,qBAAqB,KAEzB,KAAK3R,EAAgB2L,MACnB,OAAO0F,GAAY7C,GACrB,KAAKxO,EAAgB2D,YACnB,OAAO0N,GAAY,2BAAK7C,GAAN,IAAagD,eAAe,KAChD,KAAKxR,EAAgBwE,eACnB,OAAO6M,GAAY,2BAAK7C,GAAN,IAAaiD,kBAAkB,KACnD,QACE,OAAOJ,GAAY7C,KCUVuE,GA7HM,WACnB,IAAM1N,EAAQ2E,mBAASvF,GACjByE,EAASiB,4BAET6I,EAAQ,uCAAG,WAAO9S,GAAP,mBAAAW,EAAA,yDACfwE,EAAMnB,MAAMmB,EAAMtB,UAAUM,MAAQnE,EAChC+S,EAAW5N,EAAMlB,WACjBkB,EAAMtB,WAAa/B,EAHR,qBAIPkR,EAAgBjR,EAAqB/B,IAJ9B,gCAMQuI,GACjBQ,GAAYC,GACZ,IAAIjC,YAAUiM,IARL,QAMLnF,EANK,UAWTkF,EAAWlF,EAAKE,KAAKjC,YAXZ,OAefvH,EAAYU,SAAZ,2BACKE,GADL,IAEElB,WAAY8O,EACZ/O,MAAM,eAAMmB,EAAMnB,UAlBL,4CAAH,sDAsBd,OACE,eAACuG,EAAA,EAAD,UACE,gBAACC,EAAA,EAAD,WACE,gCAAKrF,EAAMtB,SAAX,WAECsB,EAAMtB,WAAa/B,GAClB,+CAAiBqD,EAAMlB,cAGzB,wCACA,eAAC,KAAD,CACEjE,KAAMmF,EAAMnB,MAAMmB,EAAMtB,UAAUM,MAClC0G,SAAU,SAAC7K,GAAD,OAAU8S,EAAS9S,IAC7BiT,WAAYP,KAGsC,GAAnDvN,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAagC,QACxC,8CAEDQ,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAaC,KACxC,SAACsQ,EAAqB9P,GACpB,OACE,iCACE,eAAC,KAAD,CACEpD,KAAMmF,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAaS,GAC/CyH,SAAU,SAACsI,GACThO,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAaS,GJwCtB,SACrCgQ,GAGA,IADA,IAAMpT,EAAOiO,SAAMoF,OAAOC,gBAAgBF,GACjCG,EAAI,EAAGA,EAAIvT,EAAK2E,OAAQ4O,IAEU,SAArCjR,EAActC,EAAKuT,GAAG,GAAItR,SAC5BjC,EAAKuT,GAAG,GAAItR,MAAQ,IACpBjC,EAAKuT,GAAG,GAAI5P,UAAW,GAG3B,OAAO3D,EIlDawT,CAAwBL,GAC1B5O,EAAYU,SAAZ,2BACKE,GADL,IAEEnB,MAAM,eAAMmB,EAAMnB,UAEpBzC,QAAQyD,IAAIG,EAAMnB,MAAMmB,EAAMtB,UAAUlB,eAE1CsQ,WAAYP,KAEd,eAACe,GAAA,EAAD,UACE,uBACE9I,MAAO,CACLC,MAAO,OACPI,QAAS,OACTC,eAAgB,UAJpB,UAOE,eAACE,EAAA,EAAD,CACEC,QAAQ,OACRC,QAAS,WACPlG,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAaS,GAAzC,sBACK+B,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAaS,IAD9C,CAEEC,EAAiBD,KAEnBmB,EAAYU,SAAZ,2BACKE,GADL,IAEEnB,MAAM,eAAMmB,EAAMnB,UAEpBzC,QAAQyD,IACN,aACAG,EAAMnB,MAAMmB,EAAMtB,UAAUlB,eAblC,wBAoBA,eAACwI,EAAA,EAAD,CACEC,QAAQ,OACRC,QAAS,WACP,GACElG,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAagC,OAAS,EAClD,CACA,IAAI+O,EAAOvO,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aACvCwC,EAAMnB,MAAMmB,EAAMtB,UAAUlB,aAAe+Q,EAAK5Q,MAC9C,EACA4Q,EAAK/O,OAAS,GAEhBJ,EAAYU,SAAZ,2BACKE,GADL,IAEEnB,MAAM,eAAMmB,EAAMnB,UAEpBzC,QAAQyD,IACN,gBACAG,EAAMnB,MAAMmB,EAAMtB,UAAUlB,gBAjBpC,kCA1CN,sBAAyBS,a,UC0GxBuQ,GApLS,SAAC3P,GACvB,IAAMmB,EAAQ2E,mBAASvF,GACjBqP,EAAS/D,mBA0Kf,OAvKAD,qBAAU,WAOR,IALA,IAAIiE,EAAQzR,OAAOC,KAAK8C,EAAMnB,OAAOpB,KAAI,SAAUmI,EAAKG,GACtD,MAAO,CAAEhI,GAAI6H,MAGX+I,EAAQ,GACZ,MAAkB1R,OAAOC,KAAK8C,EAAMnB,OAApC,eAA4C,CAAvC,IAAM+G,EAAG,KACRgJ,EAAO5O,EAAMnB,MAAM+G,GACnBiJ,EAAa,GAEjB,GAA4B,MAAxBD,EAAI,cAA2D,GAA/BA,EAAI,aAAiBpP,OACvD,IAAK,IAAIvB,EAAI,EAAGA,EAAI2Q,EAAI,aAAiB,GAAGpP,OAAQvB,IAAK,CACvD,IAAI6Q,EAAMF,EAAI,aAAiB,GAAG3Q,GAAG,GAAGnB,MAC7B,IAAPgS,GACFD,EAAWE,KAAK,CACdC,OAAQpJ,EACRD,OAAQmJ,EACR1T,KAAM,MAMW,GAArByT,EAAWrP,SAAamP,EAAQA,EAAMM,OAAOJ,IAGnD,IAAIK,EACc,GAAhBP,EAAMnP,OACF,CAAC,CAAEwP,OAAQ,WAAYrJ,OAAQ,WAAYvK,KAAM,MACjDuT,EAENvS,QAAQyD,IAAI,QAAS8O,GACrBvS,QAAQyD,IAAI,QAASqP,GAErB,IAAMrU,EAAO,CACX6T,QACAQ,SAEEC,EAAQ,CAAC,KAGR1J,EAAkB,IAAX6F,EAAgB,IACxB8D,EAAQC,KAAgBF,EAAOE,MAE/BC,EAAU,SAACC,GACHC,KAAKC,MAAMF,EAAE5J,OAAOyI,EAAImB,EAAEP,OAAOZ,EAAGmB,EAAE5J,OAAO+J,EAAIH,EAAEP,OAAOU,GACpE,MAAM,oBAAN,OACWH,EAAEP,OAAOZ,EADpB,YACyBmB,EAAEP,OAAOU,EADlC,oBAEW,EAFX,IAEgB,EAFhB,kBAE2BH,EAAE5J,OAAOyI,EAFpC,YAEyCmB,EAAE5J,OAAO+J,EAFlD,mBA+BFR,EAAQrU,EAAKqU,MAAMzR,KAAI,SAAC8R,GAAD,OAAOtS,OAAO0S,OAAOJ,MAC5Cb,EAAQ7T,EAAK6T,MAAMjR,KAAI,SAAC8R,GAAD,OAAOtS,OAAO0S,OAAOJ,MAE5C,IAAMK,EAAaP,KACAX,GAChBmB,MACC,OACAR,KAAaH,GAAOnR,IAAG,SAACwR,GAAD,OAAOA,EAAExR,OAEjC8R,MAAM,SAAUR,OAAmBS,UAAU,MAC7CD,MAAM,IAAKR,QACXQ,MAAM,IAAKR,QAERU,EAAMV,KACFZ,EAAOuB,SACdC,KAAK,UAAW,EAAC,KAAY,IAAaxK,EAAO6F,IACjD9F,MAAM,OAAQ,mBAEjBuK,EACGG,OAAO,QACPD,KAAK,KAAK,KACVA,KAAK,KAAK,KACVA,KAAK,QAAS,KACdA,KAAK,SAAU,KACfA,KAAK,OAAQ,SAGhBF,EACGG,OAAO,QACPC,UAAU,UACVtV,KAAKsU,GACLlT,KAAK,UACLgU,KAAK,MAAM,SAACV,GAAD,sBAAgBA,MAC3BU,KAAK,UAAW,cAChBA,KAAK,OAAQ,IACbA,KAAK,QAAS,IACdA,KAAK,cAAe,GACpBA,KAAK,eAAgB,GACrBA,KAAK,SAAU,QACfC,OAAO,QACPD,KAAK,OAAQb,GACba,KAAK,IAAK,kBAEb,IAAMG,EAAOL,EACVG,OAAO,KACPD,KAAK,OAAQ,QACbA,KAAK,eAAgB,KACrBE,UAAU,QACVtV,KAAKqU,GACLjT,KAAK,QACLgU,KAAK,UAAU,SAACV,GAAD,OAAOH,EAAMG,EAAEnU,SAC9B6U,KACC,cACA,SAACV,GAAD,oBAAc,IAAI1T,IAAJ,iBAAkB0T,EAAEnU,MAAQiV,UAA1C,QAGEzB,EAAOmB,EACVG,OAAO,KACPD,KAAK,OAAQ,gBACbA,KAAK,iBAAkB,SACvBA,KAAK,kBAAmB,SACxBE,UAAU,KACVtV,KAAK6T,GACLzS,KAAK,KACLqU,KAzFQ,SAACV,GAkBV,OAAOP,OAEJkB,GAAG,SAnBN,SAAqBC,EAAOjB,GACrBiB,EAAM1D,QAAQ8C,EAAWa,YAAY,IAAKC,UAC/CnB,EAAEoB,GAAKpB,EAAEnB,EACTmB,EAAEqB,GAAKrB,EAAEG,KAiBRa,GAAG,QAdN,SAAiBC,EAAOjB,GACtBA,EAAEoB,GAAKH,EAAMpC,EACbmB,EAAEqB,GAAKJ,EAAMd,KAaZa,GAAG,OAVN,SAAmBC,EAAOjB,GACnBiB,EAAM1D,QAAQ8C,EAAWa,YAAY,GAC1ClB,EAAEoB,GAAK,KACPpB,EAAEqB,GAAK,QA0EHC,CAAKjB,IAEbhB,EACGsB,OAAO,UACPD,KAAK,SAAU,SACfA,KAAK,eAAgB,KACrBA,KAAK,IAAK,GAEbrB,EACGsB,OAAO,QACPD,KAAK,IAAK,GACVA,KAAK,IAAK,UACVvQ,MAAK,SAAC6P,GAAD,OAAOA,EAAExR,MACd+S,OAAM,GACNC,QACAd,KAAK,OAAQ,QACbA,KAAK,SAAU,SACfA,KAAK,eAAgB,GAExBL,EAAWW,GAAG,QAAQ,WACpBH,EAAKH,KAAK,IAAKX,GACfV,EAAKqB,KAAK,aAAa,SAACV,GAAD,0BAAoBA,EAAEnB,EAAtB,YAA2BmB,EAAEG,EAA7B,aAExB,CAAC1P,IAGF,uBAAKwF,MAAO,CAAEwC,OAAQ,kBAAmBG,QAAS,OAAQ1C,MAAO,SAAjE,UACE,sBAAKuL,IAAKvC,IACV,6BAAIzO,EAAMtB,eCnLHuS,GAAc,SAAC5V,GAE1B,GADAe,QAAQC,MAAMhB,GATmB,4BAU5B,OAADA,QAAC,IAADA,OAAA,EAAAA,EAAG6V,WAML,MADAzR,MAAM,gCAAD,OAAiCpE,IAChCA,EALN,IAAM8V,EAAQ9V,EAEd,GADAoE,MAAM0R,EAAMC,KACTD,EAAME,UAAW,MAAMF,EAAME,WAOvBC,GACmB,SAACC,GAAD,OAC5BC,GAAiB,qBAAD,OACOD,EAAWnL,WADlB,qBAFPkL,GAKW,SAACzT,GAAD,OACpB2T,GAAiB,GAAD,OAAI3T,EAAJ,0CANPyT,GAOkB,SAC3B/K,EACAgL,GAF2B,OAI3BC,GACED,EAAU,mBACMhL,EAAYH,WADlB,6BACiDmL,EAAWnL,WAD5D,sCAEMG,EAAYH,WAFlB,qBAMVoL,GAAmB,SAACJ,EAAa/V,GACrC,MAAO,CACL+V,MACAC,UAAWhW,EACXD,KAAM,2BCKJqW,GAAM,IAAI7P,YAAUN,cAAeoQ,mBACnCC,GAAe,SAAC9N,GAAD,OACnB,IAAI+N,aAAUH,GAAK7N,GAAYC,KAS3BgO,GAA0B,SAC9BC,EACA/S,GAEA,IAAMgT,EAAM,GAIZ,OAHAD,EAAYrU,KAAI,SAACuU,GACfD,EAAIC,EAAQ,GAAGlV,OAASkV,EAAQ,GAAGlV,SAE9B,2BAAKiV,GAAQhT,IAwBhBkT,GAAgB,SACpBC,EACAC,EACAtT,EACAE,GAEA,IAAMqT,EA7CwB,SAACF,EAAkBrT,GAAnB,OAC9B7B,EAAe6B,GAAOb,QAAO,SAACZ,GAAD,OAC3BE,EAAgBuB,EAAOzB,GAAGiV,MAAK,SAACC,GAAD,OAC7BA,EAAY7U,KAAI,SAACQ,GAAD,OAAOA,EAAEF,MAAIwU,SAASL,SA0CjBM,CAAwBN,EAAUrT,GAErD4T,EA7Ba,SACnBN,EACAD,EACArT,GAeA,OAboBvB,EAAgBuB,EAAOqT,GAEqBzU,KAC9D,SAACC,GACC,OAAOA,EAAcD,KAAI,SAACiV,GACxB,MAAO,CACLC,UAAWR,EAAaxF,QAAQ+F,EAAK3U,IACrC6U,SAAUF,EAAK7U,cAiBwBgV,CAC7CV,EACAD,EACArT,GAGIsF,EAAahH,EAAc+U,GACjC,MAAO,CACL9R,cAAe8D,GAA2BC,GAC1C2O,kBAAmBjB,GACjBhT,EAAMqT,GAAUlT,MAChBD,EAAgBmT,IAElBa,UAAW3O,GAAuBD,GAClC6O,eAAgB,CACdC,WAAYb,EAAiB5S,OAC7BiT,eAKAS,GAAiC,uCAAG,WACxCxW,EACAyW,EACAC,EACAC,EACAC,EACAzV,GANwC,SAAArC,EAAA,6DAQvBwB,EAAeN,GARQ,kBAUjC,CACL6W,YAAaH,EAAe3V,KAAI,SAACL,GAAD,OAC9B6U,GAAc7U,EAAGgW,EAAgB1W,EAAGyW,MAEtCE,gBACAC,uBACAzV,WAhBsC,2CAAH,gEAoBjC2V,GAAc,uCAAG,WACrB9W,EACA+W,EACAL,EACApS,GAJqB,2BAAAxF,EAAA,6DAMfkY,EAAajX,EAAcC,GANZ,SAOK0G,GAAoBpC,EAAUyS,GAPnC,UAOfE,EAPe,6BASbrC,GAA4CmC,GAT/B,cAYf7K,EAAO+K,EAAY/K,KAZJ,SAaE3G,GAAYjB,EAAU4H,GAbxB,UAafoC,EAbe,8BAgBbsG,GAA2C1I,EAAM6K,GAhBpC,kBAqBnBG,EAAYC,WACV9W,EAAoB2W,EAAW1U,QAtBd,yDAyBbsS,GACJvU,EAAoB2W,EAAW1U,QA1Bd,eA6Bf8U,EAAWhL,SAAM1H,OAAO2S,mBAC5BH,EACA5I,EAAS/B,UAEL+K,EAAiB1W,EAAgBZ,EAAGC,GAAgB,GAjCrC,kBAmCd,CACLkB,OAAQiW,EACRG,YAAarL,EACbyK,cAAeW,EAAevW,KAAI,SAACyW,GAAD,OAAOA,EAAErW,UAC3CyV,qBAAsBU,EAAevW,KAAI,SAACyW,GAAD,OACvCd,EAAezG,QAAQuH,EAAEnW,SAxCR,2DAAH,4DA6CdoW,GAAwB,uCAAG,WAC/BtQ,EACAuQ,GAF+B,yCAAA5Y,EAAA,+DZ1HG4D,EAAYY,MY8HtCnB,EAJuB,EAIvBA,MAAwB2H,EAJD,EAIhBzH,gBAET0U,EAAY,IAAI7R,YACpBhF,EAAqBH,EAAcoC,GAAOG,QAGtCgC,EAAW4C,GAAYC,GACvB4I,EAAWzP,EAAe6B,GAC1BuU,EAAiB3G,EAAS9O,MAAM,GAZP,SAcvB6V,GAAe3U,EAAO4U,EAAWL,EAAgBpS,GAd1B,uBAavBqS,EAbuB,EAavBA,cAAeC,EAbQ,EAaRA,qBAAsBW,EAbd,EAacA,YAAapW,EAb3B,EAa2BA,OAb3B,UAiBDqV,GAC5BrU,EACA2H,EACA4M,EACAC,EACAC,EACAzV,GAvB6B,eAiBzBwW,EAjByB,iBA0BJC,WAAQC,qCACjCF,EACApU,EACAwT,EAAU9M,WACVsN,EAAYtN,WACZ3F,GA/B6B,eA0BzBwT,EA1ByB,yBAkCxB,CACL5P,QAAS4P,EAAa5P,QACtByO,cAAemB,EAAanB,cAC5BxV,OAAQ2W,EAAa3W,OACrByV,qBAAsBkB,EAAalB,qBACnCmB,gBAAiBhB,EACjBiB,KAAM,CAAEN,4BAxCqB,4CAAH,wDA4CxBO,GAAG,uCAAG,WACV9X,EACAgH,GAFU,iBAAArI,EAAA,6DAIJoZ,EAAMjD,GAAa9N,GAJf,SAKS+Q,EAAIC,SAAShY,GALtB,cAKJhC,EALI,gBAMG+Z,EAAIE,aAAaja,EAAM,CAClCka,kBAAmB,CACjBC,eAAe,EACfC,oBAAqB,SACrBC,WAAY,UAEdC,iBAAkB,CAChBH,eAAe,EACfC,oBAAqB,SACrBC,WAAY,YAfN,mFAAH,wDAoBIE,GAAsB,uCAAG,WAAOvR,GAAP,iBAAArI,EAAA,+EAEV2Y,GAAyBtQ,GAFf,cAE5BwR,EAF4B,gBAGhBV,GAAIU,EAAWxR,GAHC,OAG5ByR,EAH4B,OAIlC7V,MAAM,gCAAD,OAAiC6V,IAJJ,kDAMlCrE,GAAY,EAAD,IANuB,0DAAH,sDChP7BsE,GAAsB,IAAIC,WAAW,CACzC,EAAG,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,EAAG,IAAK,GAAI,GAAI,GAAI,IAAK,IAAK,GAAI,GAAI,GAAI,GAC1E,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IACzE,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,IAAK,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,EAAG,IAAK,EAAG,GAC1E,GAAI,GAAI,GAAI,IAAK,IAAK,GAAI,IAAK,IAAK,GAAI,IAAK,MAGzCC,GAAiB,IAAIC,KAAOC,UAAQC,cAAcL,KAElDM,GAAsB,SAACC,GAAD,OAC1B,IAAIhS,WAAS,IAAIC,aAAW+R,GAAcL,GAAgB,CACxDP,WAAY,eAGHa,GAAkB,uCAAG,WAAOC,GAAP,eAAAxa,EAAA,+EAELya,GACvB,IAAIrU,YAAUN,cAAeO,KAAKC,WAClCkU,EACAH,GAAoBvU,cAAeC,OAAOyC,MALd,cAExBuN,EAFwB,gBAOxB2E,GAAQ,IAAItU,YAAUN,cAAeO,KAAKsU,cAAe,CAC7D5E,IAR4B,OAU9B9R,MAAM,0BAVwB,gDAY9BrD,QAAQC,MAAR,MACAoD,MAAM,sCAAD,OAAuC1E,KAAKC,UAAL,QAbd,yDAAH,sDAiBzBib,GAA0B,uCAAG,WACjCrN,EACApF,EACAxC,GAHiC,mBAAAxF,EAAA,sEAMzBoG,YAAUe,mBACd,CACEa,EAAQZ,WACRC,mBAAiBD,WACjB,IAAIhB,YAAUgH,GAAMhG,YAEtB9B,+BAZ6B,cAK3BgC,EAL2B,OAc/B,GAd+B,SAed9B,EAASsC,WAAWC,eAAeT,GAfrB,yCAiBzBsT,EAAQC,QAAMC,wCAClBxV,8BACA+B,mBACA+F,EACA9F,EACAU,EACAxC,EAAS6C,OAAOoG,YAEZsM,EAAK,IAAIC,eACZC,IAAIL,GA1BwB,UA2BzBpV,EAAS0V,KAAKH,EAAI,IA3BO,yCA8B1BzT,GA9B0B,4CAAH,0DAiC1BoT,GAAO,uCAAG,WACdS,EACAC,GAFc,iBAAApb,EAAA,6DAIG,EACXqb,EAAgB,WAAI,GADT,GAGXC,EAA2B,IAAIN,cACrCI,EAAuBnZ,KAAI,SAAC8T,GAC1BuF,EAAYL,IACVJ,QAAMU,0BACJlU,mBACA8T,EACApF,EACAkE,GAAexL,UACf,GACA4M,OAhBQ,SAqBRhB,GAAoBvU,cAAeC,OAAOyC,KAAK0S,KAAKI,EAAa,GAAI,CACzE9B,eAAe,IAtBH,2CAAH,wDCoBEgC,GAtDQ,WACPrS,mBAASvF,GAAvB,IACMyE,EAASiB,4BAFY,EAKiBK,oBAAS,GAL1B,mBAKpB8R,EALoB,KAKJC,EALI,OAM6B/R,oBAAS,GANtC,mBAMpBgS,EANoB,KAMEC,EANF,KAS3B,OACE,gBAAChS,EAAA,EAAD,WACE,gBAACC,EAAA,EAAD,WACE,6CACA,eAAC,GAAD,OAEF,gBAACiJ,GAAA,EAAD,WACM,eAACtI,EAAA,EAAD,CACAC,QAAQ,OACRoR,SAAUF,EACVjR,QAAS,WACLkR,GAAwB,GACxBhC,GAAuBvR,GACtByT,MAAK,SAACC,GAAD,OAAOH,GAAwB,MACpCI,OAAM,SAACnc,GAAD,OAAO+b,GAAwB,OAP1C,SAUCD,EAAuB,aAAe,oBAGvC,eAACnR,EAAA,EAAD,CACAC,QAAQ,OACRC,QAAS,WACLgR,GAAkB,GAClBnB,GAAmBlS,EAAQoG,WAAWqN,MAAK,SAACC,GAAD,OAC3CL,GAAkB,OAGtBG,SAAUJ,EARV,SAUCA,EAAiB,qBAAuB,sBAGzC,eAACjR,EAAA,EAAD,CAAQC,QAAQ,OAAOC,QAAS,kBAAM5G,KAAtC,oBAIA,eAAC0G,EAAA,EAAD,CAAQC,QAAQ,OAAOC,QAAS,kBAAMnG,KAAtC,2BChEG0X,GAfM,WAEjB,OACI,sBAAKjS,MAAO,CAAEC,MAAO,OAAQI,QAAS,OAAQC,eAAgB,SAAU2C,IAAK,QAA7E,SACI,eAACrD,EAAA,EAAD,UACI,uBAAKI,MAAO,CAAEC,MAAO,OAAQI,QAAS,OAAQC,eAAgB,eAAgB2F,WAAY,aAAchD,IAAK,QAA7G,UACI,eAAC,GAAD,IACA,eAAC,GAAD,IACA,eAAC,GAAD,YCMdiP,GAAgBC,YAAOC,qBAAPD,CAAH,4BA8EJE,IA5EKF,IAAOG,KAAV,4BAQJ,SAAC3O,GAAsB,IAAD,IACHhE,qBADG,mBAC1B0D,EAD0B,KACjBkP,EADiB,OAED5S,oBAAS,GAFR,gCAGCA,oBAAS,IAHV,gCAICA,oBAAS,IAJV,gCAMGA,mBAAqB,CACvDqE,MAAM,EACNwO,QAAS,GACTC,cAAUhd,KATqB,mBAM1Bid,EAN0B,KAMdC,EANc,KAY3BtU,EAASuU,sBAWf,OATA3N,qBAAU,WACR,sBAAC,4BAAAjP,EAAA,kEACKqI,QADL,IACKA,OADL,EACKA,EAAQoG,WADb,gCAEyBd,EAAM7F,WAAW+U,WAAWxU,EAAOoG,WAF5D,OAESpB,EAFT,OAGGkP,EAAWlP,EAAUyP,oBAHxB,0CAAD,KAMC,CAACzU,EAAQsF,EAAM7F,aAGhB,kCACGO,EAAO0U,WACN,qBAAG/S,MAAO,CAAEgT,UAAW,GAAvB,sBACY7P,aAAe,UAAA9E,EAAOoG,iBAAP,eAAkBtD,aAAc,OAI5D9C,EAAO0U,WACN,4CAAc1P,GAAW,GAAG4P,iBAA5B,UAED5U,EAAO0U,WAAa,oBACnB1U,EAAO0U,WAAa,eAACb,GAAD,6BACtB,eAACgB,EAAA,EAAD,CACElP,KAAM0O,EAAW1O,KACjBmP,iBAAkB,IAClB/N,QAAS,kBAAMuN,EAAc,2BAAKD,GAAN,IAAkB1O,MAAM,MAHtD,SAKE,eAACoP,EAAA,EAAD,CACEhO,QAAS,kBAAMuN,EAAc,2BAAKD,GAAN,IAAkB1O,MAAM,MACpDyO,SAAUC,EAAWD,SAFvB,SAIGC,EAAWF,YAIfnU,EAAO0U,WAAa,eAAC,GAAD,S,UC1DrBM,GAAS,IAAIC,KAAYlX,UAAUN,cAAeoQ,mBAElDqH,GAAUzX,cAAeC,OAAOC,QAEhCwX,GAAU1X,cAAeC,OAAOyC,IAChCV,GAAa,IAAIwV,KAAY/U,WAAWiV,IA2B/BC,GAvBH,WACV,IAAMC,EAAWC,mBAAQ,kBAAMC,wBAAcL,MAAU,IAEjDM,EAAUF,mBACd,iBAAM,CAACG,8BAAoBC,+BAAqBC,gCAChD,IAGF,OACE,eAAC,qBAAD,CAAoBN,SAAUA,EAA9B,SACE,eAAC,iBAAD,CAAgBG,QAASA,EAASI,aAAW,EAA7C,SACE,eAAC,uBAAD,UACE,eAAC,GAAD,CACEZ,OAAQA,GACRvV,WAAYA,GACZoW,UAjBM,aCfHC,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,+BAAqBvC,MAAK,YAAkD,IAA/CwC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCHdO,IAASC,OACP,eAAC,IAAMC,WAAP,UACE,eAAC,GAAD,MAEF/e,SAASgf,eAAe,SAM1BX,M,iCCdO,IAAKY,EA2BAC,EA3BZ,oE,SAAYD,O,aAAAA,I,cAAAA,M,cA2BAC,O,0BAAAA,M,ifCTCC,EAA8B,uCAAG,WAC5C7R,EACA8R,EACApX,EACAqX,GAJ4C,iBAAAnf,EAAA,sEAUpCoG,IAAUe,mBACd,CACE+X,EAAM9X,WACNC,IAAiBD,WACjB,IAAIhB,IAAUgH,GAAMhG,YAEtB9B,KAhBwC,cAStCgC,EATsC,OAkB1C,GAlB0C,SAmBzBQ,EAAWC,eAAeT,GAnBD,yCAqBpC8X,EAAOvE,IAAMC,wCACjBxV,IACA+B,IACA,IAAIjB,IAAUgH,GACd9F,EACA4X,EACAC,GA3BwC,kBA6BnC,CACLvE,MAAOwE,EACPC,oBAAqB/X,IA/BmB,iCAkCnC,CACL+X,oBAAqB/X,IAnCmB,4CAAH,4DAwC9BmT,EAA0B,uCAAG,WACxCrN,EACA8R,EACA1Z,GAHwC,qBAAAxF,EAAA,sEAKKif,EAC3C7R,EACA8R,EACA1Z,EAASsC,WACTtC,EAAS6C,OAAOoG,WATsB,mBAKhC4Q,EALgC,EAKhCA,oBAAqBzE,EALW,EAKXA,MALW,yCAWrByE,GAXqB,cAYlCtE,EAAK,IAAIC,KACZC,IAAIL,GAbiC,UAclCpV,EAAS0V,KAAKH,GAdoB,iCAejCsE,GAfiC,4CAAH,0DAsB1BC,EAAY,uCAAG,WAC1B9L,EACA+L,EACAld,EACAmd,GAJ0B,mBAAAxf,EAAA,6DAMpByf,EAAUD,EAAqBE,UAAY,CAACF,GAAwB,GACpEJ,EAAOO,mBAAS,CACpBnM,SACA+L,cACAld,SACA6c,MAAOM,EAAU/Q,aAEbsM,EAAK,IAAIC,KACZC,IAAImE,GAdmB,kBAenB,CAAErE,KAAI6E,QAASH,IAfI,2CAAH,4DA0BZI,EAA2B,uCAAG,WACzCC,EACA/U,EACA6N,GAHyC,SAAA5Y,EAAA,0DAMvC4Y,IACAA,EAAuB7N,EAAYI,YAPI,yCAShCyN,EAAuB7N,EAAYI,aATH,uBAW5BnE,EAA2B8Y,EAAgB/U,GAXf,mFAAH,0DAqB3BgV,EAA6B,uCAAG,WAC3Cva,EACAsa,EACA1W,EACA4W,EACApH,GAL2C,yBAAA5Y,EAAA,sDAOrCwH,EAAQyY,EACZ7W,EACGnH,KAAI,SAACjC,GAAO,IAAD,IACJwH,EAAQ,GACd,GAAI,UAAAxH,EAAEkgB,4BAAF,eAAwBC,sBAAgC,CAC1D,IAAMC,EAAWpgB,EAAEkgB,qBAAqBC,sBACxCvf,QAAQyD,IAAI+b,GAEZpgB,EAAEqgB,cAAcC,SAAQ,SAAClT,EAAM3K,GACxB2d,EAASrJ,SAAStU,IAAI+E,EAAM+L,KAAKnG,WAGxC5F,EAAM+L,KAAN,MAAA/L,EAAK,YAASxH,EAAEqgB,gBAMlB,OAJoD,KAAhD,UAAArgB,EAAEkgB,4BAAF,eAAwBK,sBAE1B/Y,EAAM+L,KAAKvT,EAAEwgB,aAERhZ,KAERiZ,QAEL7f,QAAQyD,IAAImD,GAERsH,EAA0B,GACrBrM,EAAI,EAhC8B,YAgC3BA,EAAI+E,EAAMxD,QAhCiB,oBAiCnCoJ,EAAO5F,EAAM/E,KACdmW,GAA0B,IAAIxL,GAlCM,iBAmCvC0B,EAAS1B,GAAQ,CAAEqB,UAAWmK,EAAuBxL,IAnCd,yCAsCtBpG,EACf8Y,EAAerR,UACfrB,GAxCqC,QAsCjCsT,EAtCiC,OA0CvC5R,EAAS1B,GAAQ,CACfqB,UAAWiS,GA3C0B,QAgCTje,IAhCS,wCAgDjBgF,QAAQC,IAChCF,EAAMvF,IAAN,uCAAU,WAAOmL,GAAP,qBAAApN,EAAA,6DACF2gB,EAA4B7R,EAAS1B,GAAMqB,UADzC,SAEoBjJ,EAASsC,WAAWC,eAC9C4Y,GAHM,yCAQN/f,QAAQyD,IAAI,kBARN,kBASC,MATD,cAWFuc,EAAQ/F,IAAMC,wCAClBxV,IACA+B,IACA,IAAIjB,IAAUgH,GACd0B,EAAS1B,GAAMqB,UACfqR,EAAerR,UACfuR,EAAevR,YAEXsM,EAAK,IAAIC,KACZC,IAAI2F,GACDhB,EAAsBI,EAA0BN,UAClD,CAACM,GACD,GAvBI,kBAwBD,CACLjF,KACA6E,QAASA,IA1BH,4CAAV,wDAjDyC,eAgDrCiB,EAhDqC,yBAgFpC,CAAE/R,SAAUA,EAAUgL,IAAK+G,EAAYre,QAAO,SAACC,GAAD,QAASA,OAhFnB,4CAAH,8DAsFpCuE,EAA0B,uCAAG,WACjCC,EACAC,GAFiC,SAAAlH,EAAA,sEAKzBoG,IAAUe,mBACd,CACEF,EAAcG,WACdC,IAAiBD,WACjB,IAAIhB,IAAUc,GAAkBE,YAElC9B,KAX6B,uCAa/B,IAb+B,2CAAH,wDAgB1B2a,EAAuB,SAACzY,GAAD,mBACxB,IAAIsZ,IAAItZ,EAAMvF,IAAI8e,MAGjBA,EAAU,SAACL,GAAD,OAAmBA,EAAGvV,YAGzBoC,EAAmB,SAACyT,EAAavT,GAY5C,IAAMJ,EAAU2T,EAAOpW,WACjBqW,EAAW5T,EAAQ6T,UAAU,EAAG7T,EAAQrJ,OAASyJ,IAAa,IAE9D0T,EAAc9T,EACjB6T,UAAU7T,EAAQrJ,OAASyJ,GAC3B2T,SAAS3T,EAAU,KACnByT,UAAU,EAAGzT,GAEhB,MAA0B,GAAD,OAhBzB,SAA0BnM,GAExB,IADA,IAAM+f,EAAU,iBACTA,EAAQC,KAAKhgB,IAClBA,EAAQA,EAAMigB,QAAQF,EAAS,SAEjC,OAAO/f,EAWoBkgB,CAAiBP,GAArB,YAAkCE,GAlB5CI,QAAQ,SAAU,KAqBtBhJ,EAAqB,SAChCyI,EACAvT,GAUA,IAR2BnM,EAQrBO,EAAQmf,EAAOpW,WAAW/I,MAAM,KAChC4f,EAAY5f,EAAM,GAClB6f,EAAW7f,EAAM,IAAM,GAC7B,GAAIA,EAAMmC,OAAS,GAAK0d,EAAS1d,OAASyJ,EACxC,MAAM,IAAIkU,MAAJ,wBAA2BX,EAA3B,sBAER,MAZgB,MADd1f,GADyBA,EAcFmgB,EAAYC,EAASE,OAAOnU,EAAU,MAb/C8T,QAAQ,MAAO,KAEpB,IAEFjgB,I,iCC9QX,0KAAO,IAAMugB,EAA4B,IAI5BC,EAA6BC,OAC7BC,EACXD,OAIWE,EAAqB,OACrBC,EAAeH,Q,iCCX5B,uDACO,IAAMpP,EAAkB,SAACwP,GAS9B,OARA,SAAS7M,EAAM6M,GACb,GAAW,MAAPA,GAA6B,iBAAPA,EAAiB,OAAOA,EAElD,IAAIpP,EAAOoP,EAAIC,cAEf,IAAK,IAAIhY,KAAO+X,EAAKpP,EAAK3I,GAAOkL,EAAM6M,EAAI/X,IAC3C,OAAO2I,EAEFuC,CAAM6M,K,uGCuJFhV,G,0BA1JmC,IAAImQ,IAAYlX,UAC9D,gDAGgC,IAAIkX,IAAYlX,UAChD,+CAqJ4B,SAACW,GAAwC,IAAvBsb,EAAsB,uDAAd,EACtD,MAAM,GAAN,OAAUtb,EAAQ5E,MAAM,EAAGkgB,GAA3B,cAAuCtb,EAAQ5E,OAAOkgB,Q,mIC7H3CC,EAAqE,uCAChF,WACEjhB,EACAkhB,EACAC,EACAC,EACAjd,EACA0T,GANF,uBAAAlZ,EAAA,6DAQQyN,EAAWnL,SAASjB,EAAIoM,UACxBL,EAAO,IAAI+M,IACXuI,EAAoBpV,QAAM1H,OAAO2S,mBACrCF,WAAWhX,EAAIshB,WACflV,GAZJ,SAegCH,QAAM1H,OAAOia,4BACzCra,EAAS6C,OAAOoG,UAChBrB,EAAKqB,UAFuB,OAG5ByK,QAH4B,IAG5BA,OAH4B,EAG5BA,EAAMN,wBAlBV,cAeQgK,EAfR,OAqBQpD,EAAY,IAAIpZ,IAAU/E,EAAIme,WAAaha,EAAS6C,OAAOoG,WArBnE,KA0BkBoU,EAAcH,EAAkB9X,YA1BlD,KA2BwB,CAACgY,GA3BzB,KA4BsB,GA5BtB,KA6BqB,IAAIxc,IAAUqc,GA7BnC,KA8BmB,IAAIrc,IAAUmc,GA9BjC,KA+BqB,CAACnV,EAAKqB,WA/B3B,KAgCyB,CAACrB,GAhC1B,KAiC4B,CACpB+S,sBAAuB,CAAC,IAlChC,mBAqCkB2C,iCACRtd,EACAga,EACApS,EAAKqB,UACLhB,GAzCV,uDAyBMsV,uBAAuB,EACvBC,WA1BN,KA2BMC,iBA3BN,KA4BMC,eA5BN,KA6BMC,cA7BN,KA8BM3C,YA9BN,KA+BMH,cA/BN,KAgCM+C,kBAhCN,KAiCMlD,qBAjCN,KAoCMmD,aApCN,0BAwBIC,eAxBJ,oDADgF,gEAiD5ET,EAAgB,SAACxgB,GAAD,OAAoBkhB,EAAOC,KAAP,WAAgBnhB,EAAhB,OAK7B0C,EAA+C,CAC1D0e,oBAAqBnB,EACrB1d,cAhEoB,kBAiEpB8G,yBAA0B,GAEb3G,Q,8MChET2e,E,4HAAmBpW,QAAMqW,MAAMC,YAE/BC,EAAS,IAAIC,IAAI,CACrB,CACEJ,EACA,CACEK,KAAM,SACNC,OAAQ,CAAC,CAAC,kBAAmB,CAAED,KAAM,SAAUnkB,KAAM,aAgG9CoF,EAAkD,CAC7Dye,oBAtF+D,uCAAG,WAClEpiB,EACA4iB,EACAC,EACAC,EACA3e,GALkE,2BAAAxF,EAAA,6DAQ5DokB,EAAkB/iB,EAAIgjB,gBACxBlK,IAAQC,cACN,IAAIJ,WAAWuJ,EAAOC,KAAKniB,EAAIgjB,gBAAiB,cAElD5kB,EAGE2N,EAAO/L,EAAIijB,oBACbnK,IAAQC,cACN,IAAIJ,WAAWuJ,EAAOC,KAAKniB,EAAIijB,oBAAqB,SAEtD,IAAInK,IAnB0D,SAuB1D7M,QAAM1H,OAAOia,4BACjBra,EAAS6C,OAAOoG,UAChBrB,EAAKqB,WAzByD,cAsB5D8V,EAtB4D,OA4B5DC,EAA4BlX,QAAM1H,OAAO2S,mBAC7CF,WAAWhX,EAAIojB,eACfpjB,EAAIoM,UAGAiX,EAA8B,GAE9BlF,EAAY,IAAIpZ,IAAUZ,EAAS6C,OAAOoG,WAC1CsM,EAAK,IAAIC,IApCmD,KAqClED,EAAGE,IArC+D,KAqClEF,EArCkE,mBAsCtD+H,iCACRtd,EACAga,EACApS,EAAKqB,UACLpN,EAAIoM,UA1C0D,+EA6ClEiX,EAAWnR,KAAK,CACdwH,KACA6E,QAAS,CAACxS,KA/CsD,kBAkD3D,CACLkW,eAAgB,CACd9C,YAAa,IAAIpa,IAAU6d,GAC3BjB,YA3D+B3gB,EA2DEmiB,EA1D9BjB,EAAOC,KACZmB,oBAASd,EAAQ,IAAIH,EAAW,CAAEkB,gBAAiB,IAAIpX,MAAInL,QA0DzD8gB,cAAe,IAAI/c,IAAU+d,GAC7BjB,eAAgB,CACd,CACEnc,QAASqG,EAAKqB,UACdoW,aAAa,GAEf,CACE9d,QAASwd,EACTM,aAAa,GAEf,CACE9d,SAAwB,OAAfqd,QAAe,IAAfA,OAAA,EAAAA,EAAiB3V,YAAajJ,EAAS6C,OAAOoG,UACvDqW,UAAU,GAEZ,CACE/d,QAASM,qBAGb+b,kBAAmBgB,EAAkB,CAACA,GAAmB,GACzD/D,cAAe,CAACjT,EAAKqB,WACrBwU,iBAAkB,CAACsB,GACnBQ,oBAAqBL,KA3EyC,kCANhC,IAACriB,IAM+B,OAAH,8DAuF/DuC,cA3GoB,qBA4GpB8G,yBAA0B,K,iLCEfzG,EAA2C,CACtDwe,oBArH+D,uCAAG,WAClEpiB,EACA0J,EACAmZ,EACAc,EACAxf,EACAoT,GANkE,qCAAA5Y,EAAA,yDAQ5DilB,EAAS,IAAI7e,IAAU2E,GACvBma,EAAiB,IAAI9e,IAAU8d,GAE/BiB,EAAeC,eACfC,EAZ4D,UAY9CF,EAAaG,OAAOC,MACtC,SAACC,GAAD,OAAWA,EAAMC,cAAgB1a,YAb+B,aAY9C,EAEjBjE,OAd+D,gFAgBNiE,GAhBM,UAmB5D2a,EAAaP,EAAaQ,QAAQ,GAClCC,EAAUF,EAAWG,SAASN,MAAK,SAACO,GAAD,OAAOA,EAAEN,QAAUH,KApBM,6EAuBVA,GAvBU,eA0B5DU,EAAiB,IAAI3f,IAAUwf,EAAQI,uBA1BqB,UA2BvBnG,sCACzCra,EAAS6C,OAAOoG,UAChBsX,EACAnN,GA9BgE,WA2B5DqN,EA3B4D,OA8C5DC,EAASf,EAAagB,QAAQb,OAAOC,MACzC,SAACa,GAAD,OAAOA,EAAEZ,QAAUH,KA/C6C,8DAiDdA,GAjDc,iBAkDpCgB,YAC5B,IAAIjgB,IAAUwf,EAAQ7e,SACtB,IAAIX,IAAU8f,EAAOI,eAFTC,EAlDoD,EAkD1DlnB,KAlD0D,kBAsD3D,CACLikB,eAAgB,CACd9C,YAAayE,EACbjC,WAAYO,EAAOC,KAAK,IACxBL,cAAe,IAAI/c,IAAU4e,GAC7B9B,eAAgB,CACd,CACEnc,QAAS,IAAIX,IAAU+e,EAAaqB,YAEtC,CACEzf,QAASke,GAEX,CACEle,QAASme,EACTL,aAAa,GAEf,CAAE9d,QAASkf,EAA8BpB,aAAa,GACtD,CAAE9d,QAAS,IAAIX,IAAUwf,EAAQ7e,SAAU8d,aAAa,GACxD,CAAE9d,QAAS,IAAIX,IAAUwf,EAAQa,kBAAmB5B,aAAa,GACjE,CAAE9d,QAASgf,EAAgBlB,aAAa,GACxC,CAAE9d,QAAS,IAAIX,IAAUsf,EAAW3e,SAAU8d,aAAa,GAC3D,CAAE9d,QAAS,IAAIX,IAAUsf,EAAWgB,mBACpC,CAAE3f,QAASvB,EAAS6C,OAAOoG,UAAWqW,UAAU,GAChD,CAAE/d,QAAS4f,KACX,CAAE5f,QAASM,qBAEbgc,aAAc,CACZ,IAAIuD,IAAuB,CACzBvnB,KAAMknB,EAENM,UAAW,IAAIzgB,IAAU+e,EAAaqB,WACtC9kB,KAAM,CACJ,CACEolB,OAAQ,IAAI1gB,IAAUwf,EAAQ7e,SAC9BggB,YAAY,EACZjC,UAAU,GAEZ,CACEgC,OAAQ,IAAI1gB,IAAU8f,EAAOI,cAC7BS,YAAY,EACZjC,UAAU,GAEZ,CACEgC,OAAQ,IAAI1gB,IAAU8f,EAAOc,wBAC7BD,YAAY,EACZjC,UAAU,GAEZ,CACEgC,OAAQH,IACR7B,UAAU,EACViC,YAAY,OAKpB3D,kBAAmB,GACnB/C,cAAe,CAAC0F,GAChB9C,iBAAkB,CAACgD,MA/G2C,4CAAH,gEAsH/DrhB,cAzHoB,oBA0HpB8G,yBAA0B,K,sMClGfub,G,OAAqE,uCAChF,WACE5lB,EACAkhB,EACAC,EACA0E,EACA1hB,EACA0T,GANF,iBAAAlZ,EAAA,sEAQgCsN,QAAM1H,OAAOia,4BACzCra,EAAS6C,OAAOoG,UAChB,IAAIrI,IAAU/E,EAAI8lB,SAFU,OAG5BjO,QAH4B,IAG5BA,OAH4B,EAG5BA,EAAMN,wBAXV,cAQQgK,EARR,gBAayBwE,EACrB/lB,EACAkhB,EACAC,EACAI,EAAgBzX,WAChB3F,GAlBJ,cAaQ6hB,EAbR,yBAqBS,CACL/D,eAAgB,CACdP,uBAAuB,EACvBC,WAAYsE,EACVtI,IAAoBuI,UACpBF,EAASG,KACT,IAAIha,MAAInM,EAAIomB,SAEdxE,iBAAkB,CAACL,GACnBM,eAAgBwE,EACdL,EAASM,aACTN,EAASG,MAEXrE,cAAe,IAAI/c,IAAU8gB,GAC7B1G,YAAa,IAAIpa,IAAUmc,GAC3BlC,cAAe,CAAC,IAAIja,IAAU/E,EAAI8lB,UAClCS,aAAcP,EAASQ,gBACnB,CAACR,EAASQ,iBACV,MAvCV,2CADgF,iEA6CrET,EAAiB,uCAAG,WAC/B/lB,EACAkhB,EACAC,EACAI,EACApd,GAL+B,mCAAAxF,EAAA,6DAYzB8nB,EAAa,IAAI1hB,IAAU/E,EAAI+J,mBAZN,SAaP2c,EACtBviB,EAASsC,WACT,IAAI1B,IAAUmc,GACd,IAAInc,IAAU/E,EAAI8lB,SAClBW,GAjB6B,UAazBE,EAbyB,4BAmBT,mBAnBS,cAqBvBR,EAAuBQ,EAAvBR,KAAUS,EAAaD,EAAjBtH,GArBiB,SAsBPwH,SAAOC,KAC7B3iB,EAASsC,WACTmgB,EACA,GACAH,GA1B6B,cAsBzBM,EAtByB,iBA6BIC,EACjC7iB,EAASsC,WACTsgB,EACA5iB,EAAS6C,OAAOoG,UAChB,IAAIrI,IAAU/E,EAAI+J,oBAjCW,eA6BzBkd,EA7ByB,iBAoCAC,EAC7BH,EAAUI,QAAQC,WAClB,IAAIriB,IAAU/E,EAAI+J,oBAtCW,2CAoCxBsd,EApCwB,UAyCzBC,EAAanB,IAASzI,IAAK6J,IAAMhG,EAAkBJ,EACnDqG,EAAWrB,IAASzI,IAAK6J,IAAMpG,EAAiBI,EA1CvB,kBA4CxB,CACLkG,OAAQV,EACRT,aAAc,CACZmB,OAAQ,CACNA,OAAQV,EAAUI,QAAQC,WAC1BM,aAAcX,EAAUI,QAAQO,aAChCC,WAAYZ,EAAUI,QAAQQ,WAC9BC,KAAMb,EAAUI,QAAQS,KACxBC,KAAMd,EAAUI,QAAQU,KACxBC,UAAWf,EAAUI,QAAQY,UAC7BC,QAASjB,EAAUI,QAAQc,WAC3BZ,YAAaA,EAEba,WAAY,IAAInjB,IACd/E,EAAImoB,mBAAqBlB,EAAqBmB,aAEhDC,uBAAwB,IAAItjB,IAAUoc,GACtCmG,WAAY,IAAIviB,IAAUuiB,IAE5BE,SAAU,IAAIziB,IAAUyiB,GACxBrJ,UAAWha,EAAS6C,OAAOoG,UAC3Bkb,WAAY,IAAIvjB,IAAU/E,EAAI+J,mBAC9Bwe,aAAc,IAAIxjB,IAAUiB,oBAC5B4D,KAAM,IAAI7E,IAAU/E,EAAI4J,OAG1B4c,gBAAiBxmB,EAAImoB,uBACjB/pB,EACA6oB,EAAqBuB,YACzBrC,SAzE6B,4CAAH,8DAkFxBa,EAAoB,uCAAG,WAC3BvgB,EACAghB,EACA5J,EACA4K,GAJ2B,mBAAA9pB,EAAA,sEASF+pB,aAAWC,sBAClCliB,EACAghB,EAAO/hB,QACPmY,EACA4K,GAbyB,UAeD,KANpBP,EATqB,QAeZvlB,OAfY,wBAgBnBimB,EAAmB,IAAIC,KAAQ,IAAI/P,KAAUuF,WAC7CyK,EAAe,IAAInP,IAjBA,KAkBzBmP,EAlByB,SAmBjBJ,aAAWK,6BACftiB,EACAghB,EAAON,QAAQC,WACfvJ,EACA+K,EAAiBxb,UACjBqb,GAxBqB,+BAkBZ7O,IAlBY,kCA4BlB,CACLwO,YAAaQ,EAAiBxb,UAC9Bob,YAAa,CACX9O,GAAIoP,EACJvK,QAAS,CAACqK,MAhCW,iCAoClB,CACLR,YAAaF,EAAW,GAAG9a,YArCJ,4CAAH,4DA+CbsZ,EAAS,uCAAG,WACvBjgB,EACAya,EACA4E,EACA/b,GAJuB,iBAAApL,EAAA,6DAOnBwnB,EAAOzI,IAAKsL,IAPO,SAQDC,EACpBxiB,EACAya,EACA4E,EACA/b,GAZqB,WAQnBmf,EARmB,SAgBgB,IAArBA,EAAUvmB,OAhBL,gCAiBHsmB,EAChBxiB,EACAqf,EACA5E,EACAnX,GArBmB,OAiBrBmf,EAjBqB,OAuBrB/C,EAAOzI,IAAK6J,IAvBS,UAyBlB2B,GAAkC,IAArBA,EAAUvmB,OAzBL,0CAyB0B,MAzB1B,iCA0BhB,CAAE0c,GAAI6J,EAAU,GAAI/C,SA1BJ,4CAAH,4DA6BTF,EAAe,SAC1BkD,EACAhD,EACAC,GAEA,IAAMgD,EAAehD,EAAOiD,YAAYnH,EAAQ,KAAM,GAChDoH,EAAWpH,EAAOC,KAAK,IAAIxJ,WAAW,CAACwQ,EAAWhD,KACxD,OAAOjE,EAAO9P,OAAO,CAACkX,EAAUF,KAGrB/C,EAA+B,SAC1CC,EACAH,EACAoD,GAEA,IAAMtb,EACJkY,IAASzI,IAAK6J,IAAMjB,EAAakB,SAAWlB,EAAamB,OAAOH,WAC5DkC,EACJrD,IAASzI,IAAK6J,IAAMjB,EAAamB,OAAOH,WAAahB,EAAakB,SAC9D/Z,EAAW,CACf,CACE+V,aAAa,EACb9d,QAASuI,GAEX,CACEvI,QAAS4gB,EAAaiC,cAExB,CACE7iB,QAAS4gB,EAAanI,UACtBsF,UAAU,GAEZ,CACE/d,QAAS4gB,EAAa1c,MAExB,CACElE,QAAS4gB,EAAagC,YAExB,CACE5iB,QAAS8jB,EACThG,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOA,OAC7BjE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOS,WAC7B1E,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOC,aAC7BlE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOE,WAC7BnE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOG,KAC7BpE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOI,KAC7BrE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOY,uBAC7B7E,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOK,UAC7BtE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOO,QAC7BxE,aAAa,GAEf,CACE9d,QAAS4gB,EAAamB,OAAOJ,cASjC,OANIkC,GACF9b,EAASyE,KAAK,CACZxM,QAAS6jB,EACT/F,aAAa,IAGV/V,GAGF,SAAeyZ,EAAtB,oC,4CAAO,WACLuC,EACAC,GAFK,iBAAA/qB,EAAA,sDAICgrB,EAAQ,IAAIC,IAAG,GAJhB,YAKED,EAAME,WAAa,KALrB,0CAOwB9kB,IAAU+kB,qBACjC,CAACL,EAAgB1jB,WAAY4jB,EAAMN,YAAYnH,EAAQ,KAAM,IAC7DwH,GATD,cAOKK,EAPL,yBAWM,CAACA,EAAYJ,IAXnB,gCAaDA,EAAMK,MAAM,GAbX,qCAgBC,IAAI1J,MAAM,wBAhBX,0D,sBAmBP,IAAM2I,EAAiC,uCAAG,WACxCxiB,EACAwjB,EACAC,EACAC,GAJwC,SAAAxrB,EAAA,sEAMnBkoB,SAAOuD,UAAUD,GANE,8BAShCtD,SAAOwD,oBACX5jB,EACAwjB,EACAC,EACAC,GAboC,uCAetCvpB,KAAI,SAACpC,GAAD,OAAOA,EAAE4O,cAfyB,2CAAH,4DAgE1B5J,EAA+C,CAC1D4e,oBAAqBwD,EACrBriB,cAvYoB,kBAwYpB8G,yBAA0B,GAEb7G,Q,oJCtXFC,EAA+C,CAC1D2e,oBA3CmE,uCAAG,WACtEpiB,EACA0J,EACAmZ,EACAyH,EACAnmB,GALsE,uBAAAxF,EAAA,6DAOhEilB,EAAS,IAAI7e,IAAU2E,GACvB6gB,EAAY,IAAIxlB,IAAU/E,EAAIwqB,iBARkC,SAU9Dve,QAAM1H,OAAOqZ,+BACjBgG,EACA2G,EACApmB,EAASsC,WACTtC,EAAS6C,OAAOoG,WAdkD,uBAS9D4Q,EAT8D,EAS9DA,oBAA4ByM,EATkC,EASzClR,MATyC,kBAiB/D,CACL0I,eAAgB,CACdP,uBAAuB,EACvBvC,YAAayE,EACbjC,WAAYO,EAAOC,KAAK,IACxBL,cAAe,IAAI/c,IAAUulB,GAC7BzI,eAAgB,CACd,CACEnc,QAASsY,EACTwF,aAAa,IAGjBzB,kBAAmB,GACnB/C,cAAe,GACf4C,iBAAkB,GAGlBI,aACEyI,IAAmBF,EAAUG,OAAOvmB,EAAS6C,OAAOoG,WAChD,CAACqd,QACDrsB,KArC4D,2CAAH,8DA4CnEmF,cA9CoB,sBA+CpB8G,yBAA0B,K,ugICjDfsgB,EAA4B,SACvCC,EACAC,GAEA,IAAMC,EAAgB,YAAI1gB,MAAMwgB,EAAYjoB,SAASooB,KAAK,GAS1D,OAReC,EACbJ,EAAYhqB,KAAI,SAACjC,EAAGyC,GAClB,OAAO,2BAAKzC,GAAZ,IAAeuC,GAAIE,OAErB0pB,EACAD,IAOEG,EAAc,SAAdA,EACJJ,EACAK,EACAC,GAEA,GAAqB,IAAjBA,EAAMvoB,OAAc,MAAO,GAC/B,IAAMwoB,EAAeF,EAAUrqB,KAAI,SAACpC,EAAG4C,GAAJ,OAAUgqB,EAAcF,EAAO9pB,GAAK5C,KACjE6sB,EAAiBT,EAAYzpB,QACjC,SAACxC,GAAD,OAAOA,EAAEyX,aAAe+U,EAAaxsB,EAAEuC,KAAOgqB,EAAMxV,SAAS/W,EAAEuC,OAE3DoqB,EAAWD,EACdzqB,KAAI,SAACjC,GAAD,OAAOA,EAAEiX,UAAUhV,KAAI,SAACmkB,GAAD,OAAOA,EAAEnkB,KAAI,SAACQ,GAAD,OAAOA,EAAE0U,mBACjDsJ,OACAA,OACH,MAAM,GAAN,mBACKiM,EAAezqB,KAAI,SAACjC,GAAD,OAAOA,EAAEuC,OADjC,YAEK8pB,EAAYJ,EAAaO,EAAcG,MAIxCF,EAAgB,SAAIG,EAAYtrB,GAAhB,OACpBsrB,EAAMpqB,QAAO,SAACZ,GAAD,OAAOA,IAAMN,KAAO0C,S,iCC3CnC,+CAEa6oB,EAAgB,SAAC/iB,EAAcgjB,GAE3C,OADkB9Y,KAAK+Y,KAAK9K,IAAqBnY,GAAQgjB,EAAa5K,Q,2NC8E1D9L,EAAb,WAGE,WACmBF,EACA1Q,GAChB,yBAFgB0Q,oBAEjB,KADiB1Q,WACjB,KALewnB,mBAKf,EACAC,KAAKD,cAAgB,IAAIE,IACvBC,EACAjX,EACA1Q,GAVN,mFAoBE,wFAAAxF,EAAA,6DACEoJ,EADF,EACEA,QACAyO,EAFF,EAEEA,cACAC,EAHF,EAGEA,qBACAzV,EAJF,EAIEA,OACW+qB,EALb,EAKE5N,UACAvG,EANF,EAMEA,gBACmBoU,EAPrB,EAOEC,kBACApU,EARF,EAQEA,KAEIoU,EAAoBD,GAAYJ,KAAKznB,SAAS6C,OAC9CmX,EAAY4N,GAAeH,KAAKznB,SAAS6C,OAX/C,SAeU0X,wCACJkN,KAAKznB,SACLga,EACApW,EACA6jB,KAAKznB,SAAS6C,OAJmB,OAKjC6Q,QALiC,IAKjCA,OALiC,EAKjCA,EAAMN,wBApBZ,uBAaoB2U,EAbpB,EAaUze,SAA8B0e,EAbxC,EAamC1T,IAbnC,UAuBU2T,EACJR,KAAKD,cACLxN,EAAU/Q,UACVrF,EAAQpF,QA1Bd,oBAsBUgV,EAtBV,EAsBUA,aAAkB0U,EAtB5B,EAsBwB3S,GAMhB4S,EAA2BC,EAC/BX,KAAKD,cACLhU,EAAavK,UACbrF,EAAQnH,KAAI,SAACjC,GAAD,OAAOA,EAAEwX,kBACrBgI,GAGGqO,EAAqB/V,EAAqB7V,KAAI,SAACQ,GAAD,OAAO2G,EAAQ3G,OAnCpE,sBAoCU,kDApCV,WAuCsC,IAAhCqV,EAAqB9T,OAvC3B,sBAwCU,sDAxCV,eA0CQ8pB,EAAW1kB,EAAQ0O,EAAqB,IAAI0I,YA1CpD,UA4C2BlB,uBACvBrG,EACAsU,EAAcO,EAAS3iB,YAAYsD,UACnC,IAAIwc,IAAG5oB,GACPirB,GAhDJ,WA4CQS,EA5CR,OAmDQC,EAAwBC,EAC5BhB,KAAKD,cACLhU,EAAavK,UACbqJ,EACAD,EACA2H,EACA,IAAIyL,IAAG5oB,KAGH6rB,EAAWlC,YACf5iB,EAAQnH,KAAI,SAACjC,GAAD,OAAOA,EAAEwX,kBACrBM,IAEW9T,SAAWoF,EAAQpF,OAhElC,sBAiEU,yDAjEV,yBAmEmCyD,QAAQC,IACvC0B,EAAQnH,KAAI,SAACjC,GAAD,OACVmuB,EACE,IAAIjB,IACFkB,EACApuB,EAAEmjB,cACF,EAAK3d,UAGPxF,EAAEwX,eAAeP,UAAUjT,YA5EnC,eAmEQqqB,EAnER,OAmFQC,EAA0CllB,EAAQnH,KAAI,SAACssB,EAAQ9rB,GACnE,IAAM+rB,EAAQD,EAAOxL,sBACjB,CACE,CACEhc,QAASwmB,EAAcgB,EAAO/N,YAAYrV,YAAYsD,UACtDoW,aAAa,EACbC,UAAU,GAEZ,CACE/d,QAASM,IACTwd,aAAa,EACbC,UAAU,GAEZ,CACE/d,QAASyY,EAAU/Q,UACnBqW,UAAU,EACVD,aAAa,IAGjB,GAEJ,MAAO,CACL4J,IAAK,CACHC,cAAeL,EAAmB5rB,GAAGisB,cAAcjgB,UACnD0U,cAAeoL,EAAOpL,eAExBD,eAAe,GAAD,OAAMsL,EAAN,YAAgBD,EAAOrL,qBAInCyL,EAAaT,EAASjsB,KAAI,SAAC2sB,GAAD,OAC9BC,EACE,EAAK7B,cACL4B,EACA5V,EAAavK,UACb6f,EAAgBM,GAChBpP,EACA,CACEngB,KAAM+J,EAAQwlB,GAAU5L,WACxBK,aAAcja,EAAQwlB,GAAUvL,aAChCD,kBAAmBha,EAAQwlB,GAAUxL,kBACrCwE,aAAcxe,EAAQwlB,GAAUhH,kBAKhC7C,EAAsB+J,EAA0B1lB,GAGhD2lB,EApIR,sBAqIOhK,GArIP,YAsIOyI,GAtIP,CAuIIO,EACAL,EACAC,EACAK,GA1IJ,YA2IOK,EAAmBpsB,KAAI,SAACQ,GAAD,OAAOA,EAAEsY,QAE/BiU,EA7IR,YA6I8BL,EAAWlO,QA7IzC,kBA+IS,CACLzH,eACA+V,WAAYA,EACZE,eAAgBD,EAChBzB,gBACA2B,eAAgBb,EAAmBpsB,KAAI,SAACjC,GAAD,OAAOA,EAAE0uB,mBApJpD,iDApBF,gIA4KE,WACErvB,GADF,mBAAAW,EAAA,sEAIWitB,KAAKD,cAAchlB,QAAQgR,aAAamW,MAC7C9vB,EAAK2Z,aAAavK,WALxB,cAGQ2gB,EAHR,OAOQC,EAAkB,SAACrvB,GACvB,MAAO,CACLsP,aAAc,IAAIlJ,IAAUpG,EAAEsP,cAAcnE,WAC5CsM,WAAYzX,EAAEyX,WACdR,UAAWjX,EAAEiX,UAAUhV,KAAI,SAACmkB,GAAD,OACzBA,EAAEnkB,KAAI,SAACqtB,GACL,MAAO,CACLnY,UAAWmY,EAASnY,UACpBC,SAAU,IAAI6T,IAAGqE,EAASlY,UAAUxM,oBAMxC2kB,EAAsB,SAACvvB,GAC3B,MAAO,CACLwvB,aAAcxvB,EAAEwvB,aAChBC,WAAY,IAAIxE,IAAGjrB,EAAEyvB,YAAY7kB,aAxBvC,kBA2BS,CACLoO,aAAc,CACZwG,UAAW,IAAIpZ,IAAUgpB,EAAkB5P,WAAWrU,WACtD/B,QAASgmB,EAAkBhmB,QAAQnH,IAAIotB,GACvCK,YAAaN,EAAkBM,YAAYztB,IAAIstB,GAC/CI,iBAAkBP,EAAkBO,oBAhC1C,gDA5KF,mIAkNE,WAA8BC,GAA9B,SAAA5vB,EAAA,uDAC+B,SAACgI,MAC9B4nB,EAAiB5W,aAFnB,2CAlNF,wHAuNE,WACE3Z,EACAwwB,GAFF,iBAAA7vB,EAAA,sEAIQitB,KAAKznB,SAJb,YAMInG,EAAK0vB,WAAW/qB,OAAS,GAN7B,gCAOcipB,KAAKznB,SAASsqB,QAAQzwB,EAAK0vB,WAA3B,gBAEO,OAAPc,QAAO,IAAPA,OAAA,EAAAA,EAAStW,oBAAqB,KAT5C,8CAWQ,GAXR,UAKQwW,EALR,QAYa,OAAPF,QAAO,IAAPA,OAAA,EAAAA,EAASG,wBAAyBD,EAAgB/rB,OAAS,GAZjE,kCAaU6rB,EAAQG,sBAAsBD,GAbxC,yBAcyB9C,KAAKznB,SAASsqB,QAAQzwB,EAAK4vB,eAA3B,gBAEV,OAAPY,QAAO,IAAPA,OAAA,EAAAA,EAASlW,mBAAoB,KAhBrC,eAcQsW,EAdR,+CAkBaF,GAlBb,YAkBiCE,KAlBjC,iDAvNF,gEA6OMxC,EAAyB,uCAAG,WAChCyC,EACA1Q,EACA2Q,GAHgC,iBAAAnwB,EAAA,6DAK1BowB,EAAsBC,IAAKlW,QAAQmW,WALT,KAMrBJ,EAAQK,YANa,KAMgBJ,EANhB,KAOpB,CACRnX,aAAcoX,EAAoB3hB,UAClC+Q,YACAvU,KAAMolB,IAAKnlB,oBAViB,KAYrB,CAACklB,GAZoB,SActBI,IAAcC,cAAc,CAChCC,WAAYR,EAAQ1qB,SAAS6C,OAAOoG,UACpCkiB,iBAAkBP,EAAoB3hB,UACtCmiB,MAAO/O,IAA4B,EACnCgP,SAAUhE,YACRhL,IAA4B,EAC5BG,KAEF6E,UAAWqJ,EAAQrJ,YAtBO,4CAO9B/X,SAP8B,KAY9B8Q,QAZ8B,KAa9ByD,aAb8B,MAM1BtI,EAN0B,KAMD+V,iBANC,uCA4BzB,CACL/V,GAAI,CAAEA,KAAI6E,QAAS,CAACwQ,IACpBpX,aAAcoX,IA9BgB,4CAAH,0DAkCzBxC,EAA2B,SAC/BsC,EACAlX,EACA5P,EACAoW,GAEA,IAAMI,EAAWJ,EAAqBE,UAAY,CAACF,GAAuB,GACpEuR,EAA0C3nB,EAAQnH,KAAI,SAACssB,GAC3D,MAAO,CACL9W,WAAY8W,EAAO9W,WACnBR,UAAWsX,EAAOtX,UAAUhV,KAAI,SAACqtB,GAAD,OAC9BA,EAASrtB,KAAI,SAACyW,GACZ,MAAO,CACLvB,UAAWuB,EAAEvB,UACbC,SAAU,IAAI5J,IAAIkL,EAAEtB,qBAM9B,MAAO,CACL2D,GAAImV,EAAQK,YAAYS,WAAWD,EAAuB,CACxDjiB,SAAU,CACR0Q,UAAWA,EAAU/Q,UACrBuK,aAAcA,EACd/N,KAAMolB,IAAKnlB,oBAEb0U,QAASA,IAEXA,YAIEkP,EAA4B,SAAC1lB,GAAD,OAChCA,EAAQnH,KAAI,SAACjC,GAAD,OAAOA,EAAE+kB,qBAAuB,MAAItE,QAE5CwN,EAAsB,SAC1BiC,EACAlX,EACAiY,EACAC,EACA1R,EACAnd,GAEA,IAAMud,EAAWJ,EAAqBE,UAAY,CAACF,GAAuB,GAC1E,MAAO,CACLzE,GAAImV,EAAQK,YAAYtC,oBACtBgD,EACAC,EAAiBjvB,KAAI,SAACQ,GAAD,OAAO,IAAIwoB,IAAGxoB,MACnCJ,EACA,CACEyM,SAAU,CACR0Q,UAAWA,EAAU/Q,UACrBuK,aAAcA,EACd/N,KAAMolB,IAAKnlB,oBAEb0U,YAGJA,YAOEiP,EAAgB,SACpBqB,EACA/Y,EACA6B,EACAmY,EACA3R,EACAtG,GAOqB,IAAD,EACdkY,GAAO,OAAC5R,QAAD,IAACA,OAAD,EAACA,EAAsBE,WAAY,CAACF,GAAuB,GAClE6R,GAAU,UAACnY,EAAK4G,sBAAN,eAAiCJ,WAC7C,CAACxG,EAAK4G,gBACN,GACEwR,EAAkBpY,EAAK4G,eAAL,UAChBuR,EAAYD,GADI,UAEhBA,GACFxR,EAAO,sBAAO0R,GAAP,YAA4BpY,EAAKkK,mBAAqB,KACnE,MAAM,GAAN,mBACMlK,EAAK0O,cAAgB,IAD3B,CAEE,CACE7M,GAAImV,EAAQK,YAAY1B,cACtB1X,EACA+B,EAAK7Z,MAAQkkB,EAAOC,KAAK,IACzB,CACE1U,SAAU,CACRkK,aAAcA,EACd/N,KAAMolB,IAAKnlB,mBACXsU,UAAWA,EAAU/Q,UACrB8iB,eAAgBJ,EAAkB1C,IAClCvL,eAAgBiO,EAAkBjO,gBAEpCtD,UACAyD,aAAcnK,EAAKmK,mBAAgB5jB,IAGvCmgB,cAKAuO,EAAiB,uCAAG,WACxBqD,EACAC,GAFwB,mBAAAzxB,EAAA,6DAIlB0xB,EAASvX,IAAQmW,WACvBkB,EAAsBhsB,SAASsC,WAAW6pB,kCACpCC,EAAaC,EAAsBJ,GANjB,KAObD,EAAsBjB,YAPT,KAQtBkB,EARsB,KAUV,CACRC,OAAQA,EAAOjjB,UACfxD,KAAMolB,IAAKnlB,oBAZO,SAeZslB,IAAcC,cAAc,CAChCC,WAAYc,EAAsBhsB,SAAS6C,OAAOoG,UAClDkiB,iBAAkBe,EAAOjjB,UACzBmiB,MAAOgB,EACPf,SAAUhE,YAAc+E,EAAY9P,KACpC+E,UAAW2K,EAAsB3K,YApBjB,2CAuBX,CAAC6K,GAvBU,MAUpB5iB,SAVoB,KAcpBuU,aAdoB,KAuBpBzD,QAvBoB,MAOlB7E,EAPkB,KAOqBoT,kBAPrB,uCA0BjB,CACLpT,GAAI,CAAEA,KAAI6E,QAAS,CAAC8R,IACpBhD,cAAegD,IA5BO,4CAAH,wDAoDjBG,EAAwB,SAACC,GAAD,OAC5B,GAA+B,EAAlBA,EAAsB,IAE/BjE,EAAuB,SAACzkB,GAC5B,GAAuB,IAAnBA,EAAQpF,OAAc,OAAO,EACjC,IAAMoJ,EAAOhE,EAAQ,GAAGoX,YAAYrV,WACpC,OAAO/B,EAAQ2oB,OAAM,SAAC/xB,GAAD,OAAOA,EAAEwgB,YAAYrV,aAAeiC,Q,yDC1gB3D,e,gCCAA,kCAAO,IAAMtH,EAAe,WAC1B,IAAMksB,EAAMC,SAGR,MAAO,CACL/b,kBAAmB,+CACnBrN,UAAW,CACTE,oBAAqB,+CACrBD,gBAAiB,+CACjBopB,mBAAoB,+CACpBlpB,QAAS,+CACTC,cAAe,gDAEjBoC,aAAc,CACZC,eAAgB,gDAElBjF,KAAM,CACJC,UAAW,+CACXqU,aAAc,+CACdnU,aAAc,gDAEhB2rB,yBAA0B,UAC1BpsB,OAAQ,CACNyC,IAAK,yCACLxC,QAASgsB,M,+VCiCbI,EAAiC,SACrCjb,EACA/N,GAEA,IACM5B,EA5CmB,SACzB2P,EACA/N,GAKA,OAAOA,EACJnH,KAAI,SAACjC,EAAGyC,GACP,OAAOzC,EAAC,2BAAQA,GAAR,IAAWqyB,IAAK5vB,IAAMzC,KAE/BwC,QAAO,SAACxC,GAAD,QAASA,KAChBiC,KAAI,SAACjC,GAGJ,IAFA,IAAMsyB,EAAmC,EAAE,GAAI,GAEtC7vB,EAAI,EAAGA,EAAIzC,EAAEwX,eAAeP,UAAUjT,OAAQvB,IAIrD,GAHA6vB,EAAe,GAAKtyB,EAAEwX,eAAeP,UAAUxU,GAC5CR,KAAI,SAACswB,GAAD,OAAUA,EAAKpb,aACnBhG,QAAQgG,IACgB,IAAvBmb,EAAe,GAAW,CAC5BA,EAAe,GAAK7vB,EACpB,MAGJ,IAA2B,IAAvB6vB,EAAe,KAAoC,IAAvBA,EAAe,GAE/C,MAAO,CACLD,IAAKryB,EAAEqyB,IACPC,qBAGH9vB,QAAO,SAACC,GAAD,QAASA,KAYK+vB,CAAmBrb,EAAW/N,GACxBnH,KAAI,SAACwwB,GAGjC,OAFerpB,EAAQqpB,EAAKJ,KACRhS,cAAcoS,EAAKH,eAAe,IAC1CnnB,cAEd,GAAI3D,EAAMxD,OAAS,EACjB,KAAK,8DACP,IAAM0uB,EAAYlrB,EAAM,GACxB,IAAKA,EAAMuqB,OAAM,SAAC3kB,GAAD,OAAUA,IAASslB,KAClC,KAAK,4DACP,OAAOA,GAGI3Z,EAAoC,uCAAG,WAClDC,EACA2Z,EACAC,EACAC,EACArtB,EACAoT,GANkD,mCAAA5Y,EAAA,0DAQ5C8yB,EAAkB9G,YACtBhT,EAAajB,YAAY9V,KAAI,SAACjC,GAAD,OAAOA,EAAEwX,kBACtCwB,EAAalB,uBAGK9T,SAAWgV,EAAajB,YAAY/T,OAbN,wHAgB5CoF,EAhB4C,YAiB7CqC,MAAMuN,EAAajB,YAAY/T,SAE3BvB,EAAI,EAnBqC,YAmBlCA,EAAIqwB,EAAgB9uB,QAnBc,oBAoB1CmT,EAAY2b,EAAgBrwB,GAC5BsI,EAAciO,EAAalB,qBAAqBf,SAASI,GAC3D0b,EACAT,EAA+Bjb,EAAW/N,GACxC4Z,EAAahK,EAAajB,YAAYZ,GACtC4b,EAAUJ,EAAe3P,EAAWpe,eAAe6e,oBAzBT,sFA2BiBT,EAAWpe,eA3B5B,YA4B3BoU,EAAalB,qBAAqBf,SAAStU,GA5BhB,sBA6B5CmwB,EA7B4C,yCA+BpC/S,sCACJra,EAAS6C,OAAOoG,UAChB,IAAIrI,IAAU2E,GACd6N,GAlCwC,oBAoC1CzN,WApC0C,eA4B1CmE,EA5B0C,eAqCfyjB,EAC/B/P,EAAW1L,kBACXvM,EACAuE,EACA0T,EAAWzL,UACX/R,EACA,CACEoT,2BA5C4C,iBAqCxC0K,EArCwC,EAqCxCA,eAUFiL,EA/C0C,2BAgD3CjL,GAhD2C,IAiD9C9L,eAAgBwL,EAAWxL,iBAE7BpO,EAAQ+N,GAAaoX,EAnD2B,QAmBN9rB,IAnBM,gDAsD3C,CACL2G,UACA0O,qBAAsBkB,EAAalB,qBACnCD,cAAemB,EAAanB,cAC5BxV,OAAQ,IAAI4oB,IAAGjS,EAAa3W,UA1DoB,4CAAH,gEAkFpC2wB,EAAqB,SAChCC,EACAC,EACAC,GAUA,IAAMC,EAA0BzgB,0BAAgBugB,GAC1CG,EAA0B1gB,0BAAgBsgB,GAEhD,GACEE,EAAwBnvB,QACtBovB,EAAwBtb,qBAAqB9T,QAC/CmvB,EAAwBnvB,SACtBovB,EAAwBvb,cAAc7T,OAExC,KAAK,yIAmBP,IAjBA,IAAMsvB,EAAmB,sBACpBD,EAAwBtb,aADJ,YAEpBqb,EAAwBrb,YAAY9V,KAAI,SAACjC,GAC1C,OAAO,2BACFA,GADL,IAEEwX,eAAe,2BACVxX,EAAEwX,gBADO,IAEZP,WAlDRA,EAmDUjX,EAAEwX,eAAeP,UAlD3Bsc,EAmDUF,EAAwBtb,YAAY/T,OAjD9CiT,EAAUhV,KAAI,SAACuxB,GAAD,OACZA,EAAYvxB,KAAI,SAACyW,GACf,MAAO,CACLvB,UAAWuB,EAAEvB,UAAYoc,EACzBnc,SAAUsB,EAAEtB,qBARI,IACtBH,EACAsc,OA0DME,EAA2B,GACxBhxB,EAAI,EAAGA,EAAI0wB,EAAwBnvB,OAAQvB,IAClD,GAAI0wB,EAAwB1wB,GAAGixB,gBAC7BD,EAAyBlgB,KAAK,CAC5B8e,IAAK5vB,EAAI4wB,EAAwBtb,YAAY/T,OAC7CoT,SAAU+b,EAAwB1wB,GAAGkxB,gBAElC,KAAIR,EAAwB1wB,GAAGmxB,cAUpC,KAAK,uHATLN,EACEH,EAAwB1wB,GAAGmxB,cAAczc,WACzCK,eAAeP,UACfkc,EAAwB1wB,GAAGmxB,cAAcC,aACzCtgB,KAAK,CACL6D,SAAU+b,EAAwB1wB,GAAGkxB,UACrCxc,UAAW1U,EAAI4wB,EAAwBtb,YAAY/T,SAezD,MAAO,CACL+T,YAAaub,EACbxb,qBAV2B,sBACxBub,EAAwBvb,sBADA,YAExB2b,EAAyBxxB,KAAI,SAAC6xB,GAAD,OAAOA,EAAEzB,SASzCxa,cAPsB,sBACnBwb,EAAwBxb,eADL,YAEnB4b,EAAyBxxB,KAAI,SAAC6xB,GAAD,OAAOA,EAAE1c,cAMzC/U,OAAQgxB,EAAwBhxB,U,2OCtOvBuhB,EACZ,WAAYmQ,GAAa,IAAD,2BACtBtyB,OAAOC,KAAKqyB,GAAY9xB,KAAI,SAACmI,GAC3B,EAAKA,GAAO2pB,EAAW3pB,O","file":"static/js/main.7c251272.chunk.js","sourcesContent":["export * from \"./malloc-sdk\";\nexport * from \"./interfaces\";\nexport * as utils from \"./utils\";\nexport * as serializer from \"./serializer\";\nexport * as builder from './builder'\nimport _MallocIdl from \"./idls/malloc.json\";\nexport const MallocIdl = _MallocIdl;\n","import { MintInfo, u64 } from \"@solana/spl-token\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { FlowElement } from \"react-flow-renderer\";\nimport internal from \"stream\";\n\nexport enum InputClassNames {\n  actionVertex = \"ACTION_VERTEX\",\n  tokenAccount = \"TOKEN_ACCOUNT\",\n  mintAccount = \"MINT_ACCOUNT\",\n  tokenAccountOnlyInit = \"TOKEN_ACCOUNT_ONLY_INIT\",\n  mintAccountOnlyInit = \"MINT_ACCOUNT_ONLY_INIT\",\n  wholeNumber = \"WHOLE_NUMBER\",\n  fractionNumber = \"FRACTION_NUMBER\",\n  other = \"OTHER\",\n}\n\nexport type SPLToken = { account: string } & {\n  info: Partial<TokenInfo> & { decimals: number; mint: PublicKey };\n  balance: string | u64 | null;\n};\n\nexport type NextAction = [\n  { value: string; readOnly?: boolean; className?: string },\n  { value: string; readOnly?: boolean; className?: string }\n];\n\nexport type Input = [\n  { value: string; readOnly: true },\n  { value: string; className?: string }\n][];\nexport type SourceNodeInput = [\n  [{ value: string; readOnly: true }, { value: string; className?: string }],\n  [{ value: string; readOnly: true }, { value: string; className?: string }]\n];\nexport type ActionEdge = { id: string; amount: number };\nexport type NodeType = { input: Input; next_actions: NextAction[][] };\nexport type GraphType = { [id: string]: NodeType };\nexport type HiddenInputData = { [id: string]: any };\n","import fileDialog from \"file-dialog\";\n/* function to save JSON to file from browser\n * adapted from http://bgrins.github.io/devtools-snippets/#console-save\n * @param {Object} data -- json object to save\n * @param {String} file -- file name to save to\n */\nexport const saveStringToFile = (data: any, filename: string) => {\n  if (!data) {\n    console.error(\"No data\");\n    return;\n  }\n\n  if (!filename) filename = \"console.json\";\n\n  if (typeof data === \"object\") {\n    data = JSON.stringify(data, undefined, 4);\n  }\n\n  var blob = new Blob([data], { type: \"text/json\" }),\n    e = document.createEvent(\"MouseEvents\"),\n    a = document.createElement(\"a\");\n\n  a.download = filename;\n  a.href = window.URL.createObjectURL(blob);\n  a.dataset.downloadurl = [\"text/json\", a.download, a.href].join(\":\");\n  e.initMouseEvent(\n    \"click\",\n    true,\n    false,\n    window,\n    0,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null\n  );\n  a.dispatchEvent(e);\n};\n\nexport const getFileContent = async () => {\n\treturn await fileDialog({\n\t\taccept: 'application/json'\n\t})\n};\n","import { SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { getConstants } from \"src/config/constants\";\nimport { INIT_NEXT_ACTION, SOURCE_NODE_ID } from \"src/globalStore\";\nimport {\n  ActionEdge,\n  GraphType,\n  HiddenInputData,\n  Input,\n  InputClassNames,\n  NextAction,\n  SourceNodeInput,\n} from \"src/interfaces\";\nimport { ActionTypes } from \"./action-types\";\n\nexport const getSourceNode = (g: GraphType) => g[SOURCE_NODE_ID];\n\nexport const getSourceNodeAccount = (inp: SourceNodeInput) => inp[0][1].value;\nexport const getSourceNodeAmount = (inp: SourceNodeInput) => inp[1][1].value;\nexport const getAllVertices = (g: GraphType): string[] => Object.keys(g);\nexport const getActionVertices = (g: GraphType): string[] => {\n  const all = Object.keys(g);\n  const initIdx = all.indexOf(SOURCE_NODE_ID);\n  all.splice(initIdx, 1);\n  return all;\n};\n\nexport const getVertexType = (v: string): ActionTypes =>\n  v.split(\"-\")[0] as ActionTypes;\n\n// Discard the first element as those are just labels\nexport const getNextVertices = (\n  g: GraphType,\n  vertex: string\n): ActionEdge[][] => {\n  const nextActions = g[vertex].next_actions;\n  const ret = nextActions.map((nextActionSet) => {\n    const nextActionRemoveLabel = nextActionSet.slice(1);\n    const edgesRet = nextActionRemoveLabel.map((nextAction: NextAction) => {\n      if (!nextAction[1].value && !nextAction[0].value) {\n        return null;\n      }\n      return {\n        amount: parseInt(nextAction[1].value),\n        id: nextAction[0].value,\n      } as ActionEdge;\n    });\n    // Remove empty rows\n    return edgesRet.filter((e, i) => e !== null) as ActionEdge[];\n  });\n  return ret;\n};\n\nexport const getNextActionRow = (nextMintIdx: number) => {\n  return [\n    { value: \"\", className: `${InputClassNames.actionVertex}-${nextMintIdx}` },\n    { value: \"\", className: InputClassNames.wholeNumber },\n  ] as NextAction;\n};\n","import { Store } from \"react-stores\";\nimport {\n  Input,\n  ActionEdge,\n  NodeType,\n  GraphType,\n  SourceNodeInput,\n  NextAction,\n  HiddenInputData,\n  InputClassNames as CellClassNames,\n} from \"src/interfaces\";\nimport { getFileContent, saveStringToFile } from \"./utils/files\";\nimport { getNextActionRow } from \"./utils/graph\";\n\nexport interface MallocState {\n  selected: string;\n  counter: number;\n  new_action: string;\n  graph: GraphType;\n  sourceMint: string;\n  hiddenInputData: HiddenInputData;\n}\n\nexport const SOURCE_NODE_ID = \"SOURCE-0\";\n\nexport const INIT_NEXT_ACTION: NextAction[] = [\n  [\n    { value: \"NextActionID\", readOnly: true },\n    { value: \"Parts of 1,000\", readOnly: true },\n  ],\n  getNextActionRow(0),\n];\n\nconst initState: MallocState = {\n  selected: SOURCE_NODE_ID,\n  counter: 1,\n  new_action: \"SERUM_SWAP\",\n  graph: {},\n  sourceMint: \"<UNSET>\",\n  hiddenInputData: {},\n};\n\ninitState.graph[SOURCE_NODE_ID] = {\n  input: [\n    [\n      {\n        value: \"InputTokenAccount\",\n        readOnly: true,\n      },\n      { value: \"\", className: CellClassNames.tokenAccountOnlyInit },\n    ],\n    [\n      {\n        value: \"Amount\",\n        readOnly: true,\n      },\n      { value: \"\", className: CellClassNames.fractionNumber },\n    ],\n  ] as SourceNodeInput,\n  next_actions: [INIT_NEXT_ACTION],\n};\n\nexport const globalStore = new Store<MallocState>(initState);\n\nexport const getGlobalStore = () => globalStore.state;\n\nexport const setGlobalStoreFromFile = async () => {\n  const fileContents = await getFileContent();\n  if (fileContents.length < 1) {\n    alert(\"Please select a file\");\n    return;\n  }\n  // TODO: use have the input be the nonspecific construction (and validated via malloc sdk) and then have a function which interpolates\n  const parsed = JSON.parse(await fileContents[0].text()) as MallocState;\n  console.log(parsed);\n  // Set the token account in to be undefined\n  parsed.graph[SOURCE_NODE_ID].input[0][1].value = \"\";\n  globalStore.setState(parsed);\n};\n\nexport const downloadGlobalStore = async () => {\n  await saveStringToFile(JSON.stringify(globalStore.state), \"flow.json\");\n};\n","import { ActionLib, BuildActionMap } from \"@malloc/sdk\";\nimport MintAction from \"./mint\";\nimport { MintAndMintToAction } from \"./mint-to\";\nimport { SolendAction } from \"./solend\";\nimport SwapAction from \"./swap\";\nimport { TransferAction } from \"./transfer\";\n\nexport { SwapAction } from \"./swap\";\nexport { TransferAction } from \"./transfer\";\nexport { MintAction } from \"./mint\";\nexport { MintAndMintToAction } from \"./mint-to\";\nexport { SolendAction } from \"./solend\";\n\nexport const MallocSPLBuildActionMap: BuildActionMap = {};\n\n// Add the spl actions to the default mapping\nconst addActionToMap = (actionLib: ActionLib<any>) => {\n  MallocSPLBuildActionMap[actionLib.actionTypeUID] = actionLib;\n};\n\naddActionToMap(SwapAction);\naddActionToMap(TransferAction);\naddActionToMap(MintAction);\naddActionToMap(MintAndMintToAction);\naddActionToMap(SolendAction);\n","import { Elements, FlowElement } from \"react-flow-renderer\";\nimport { Store } from \"react-stores\";\nimport { SPLToken } from \"../interfaces\";\nimport {\n  AccountsArray,\n  Action,\n  IsolatedAction,\n} from \"../../../../malloc-core/ts-packages/malloc-sdk/lib/\";\nimport { getConstants } from \"../config/constants\";\nimport { PublicKey, Signer } from \"@solana/web3.js\";\nimport { u64 } from \"@solana/spl-token\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\n\nexport interface IFlowChart {\n  elements: Elements<any>;\n  initSplits: number[];\n  initTokenAccount?: PublicKey;\n  initAmount: u64;\n}\n\nexport interface SolanaSpl {\n  derivedTokenAccounts: SPLToken[] | null;\n  tokenList: TokenInfo[] | null;\n}\n\nexport const solanaSplStore = new Store<SolanaSpl>({\n  derivedTokenAccounts: null,\n  tokenList: null,\n});\n","import { getProvider, Provider } from \"@project-serum/anchor\";\nimport { parseTokenAccount, parseMintAccount } from \"@project-serum/common\";\nimport {\n  AccountInfo,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  MintInfo,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport {\n  TokenListProvider,\n  TokenInfo,\n  TokenListContainer,\n} from \"@solana/spl-token-registry\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\nimport { solanaSplStore } from \"../state/flowchart-store\";\n\n// TODO: where does this come from?\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: PublicKey =\n  ASSOCIATED_TOKEN_PROGRAM_ID;\n\n// TODO: have a store for token metadata which has a list of all tokens as well as their metadata\n\n// See https://github.com/solana-labs/token-list\nexport const getTokenLists = async (\n  provider: Provider\n): Promise<TokenInfo[]> => {\n  const getCached = async () => {\n    if (solanaSplStore.state.tokenList) return solanaSplStore.state.tokenList;\n    const tokens = await new TokenListProvider().resolve();\n    const tokenList = tokens\n      .filterByClusterSlug(getConstants().solana.NETWORK)\n      .getList();\n    solanaSplStore.setState({\n      ...solanaSplStore.state,\n      tokenList,\n    });\n    return tokenList;\n  };\n  const tokenList = await getCached();\n\n  // Add in demo tokens\n  if (getConstants().solana.NETWORK === \"devnet\") {\n    return [...tokenList, ...(await getDemoTokenInfo(provider))];\n  } else {\n    return tokenList;\n  }\n};\n\nconst getDemoTokenInfo = async (provider: Provider): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(getConstants().demo.FAKE_USDC);\n  const aMint = new PublicKey(getConstants().demo.FAKE_TOKEN_A);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: getConstants().demo.FAKE_USDC,\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE: A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: getConstants().demo.FAKE_TOKEN_A,\n    },\n  ];\n};\n\nexport const getTokenListContainer = async (\n  provider: Provider\n): Promise<TokenListContainer> =>\n  new TokenListContainer(await getTokenLists(provider));\n\n// See https://spl.solana.com/associated-token-account\nexport const findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  const associated = await PublicKey.findProgramAddress(\n    [\n      walletAddress.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      new PublicKey(tokenMintAddress).toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  return associated[0];\n};\nexport const findAllAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  mints: (PublicKey | string)[]\n): Promise<PublicKey[]> =>\n  Promise.all(mints.map((m) => findAssociatedTokenAddress(walletAddress, m)));\n\nexport const getTokenAccountInfo = async (\n  provider: Provider,\n  tokenAddr: PublicKey\n): Promise<AccountInfo | null> => {\n  const account = await provider.connection.getAccountInfo(tokenAddr);\n  if (!account) return null;\n  try {\n    const data = parseTokenAccount(account.data);\n    return data;\n  } catch (e) {\n    console.error(\"An error occured parsing the data, returning null\", e);\n    return null;\n  }\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n","import { Provider } from \"@project-serum/anchor\";\nimport { AnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\n\nexport const getProvider = (wallet: AnchorWallet): Provider => {\n  return new Provider(new Connection(getConstants().solana.RPC), wallet, {});\n};\n","import { utils } from \"@malloc/sdk\";\nimport {\n  MintAction,\n  MintAndMintToAction,\n  SolendAction,\n  SwapAction,\n  TransferAction,\n} from \"@malloc/spl\";\nimport { SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { getConstants } from \"src/config/constants\";\nimport {\n  HiddenInputData,\n  Input,\n  InputClassNames,\n  NextAction,\n} from \"src/interfaces\";\nimport { getVertexType } from \"./graph\";\n\nexport type ActionTypes =\n  | \"SERUM_SWAP\"\n  | \"TRANSFER\"\n  | \"MINT\"\n  | \"SOLEND DEPOSIT LIQUIDITY\";\nexport const ACTION_TYPES: ActionTypes[] = [\n  \"SERUM_SWAP\",\n  \"TRANSFER\",\n  \"MINT\",\n  \"SOLEND DEPOSIT LIQUIDITY\",\n];\n\nexport const getActionTypeUIDFromVertex = (vertexType: ActionTypes) => {\n  if (vertexType === \"SERUM_SWAP\") {\n    return SwapAction.actionTypeUID;\n  } else if (vertexType === \"TRANSFER\") {\n    return TransferAction.actionTypeUID;\n  } else if (vertexType === \"MINT\") {\n    return MintAndMintToAction.actionTypeUID;\n  } else if (vertexType === \"SOLEND DEPOSIT LIQUIDITY\") {\n    return SolendAction.actionTypeUID;\n  } else throw `unexpected vertex id of ${vertexType}`;\n};\n\n// TODO: move this over to Malloc SPL and use action type uids instead\nexport const getActionPIDFromVertex = (vertexType: ActionTypes) => {\n  if (vertexType === \"SERUM_SWAP\") {\n    return getConstants().mallocSpl.SWAP_PROGRAM_ID;\n  } else if (vertexType === \"TRANSFER\") {\n    return getConstants().mallocSpl.TRANSFER_PROGRAM_ID;\n  } else if (vertexType === \"MINT\") {\n    return getConstants().mallocSpl.MINT_TO;\n  } else if (vertexType === \"SOLEND DEPOSIT LIQUIDITY\") {\n    return getConstants().mallocSpl.SOLEND_ACTION;\n  }\n  throw `unexpected vertex id of ${vertexType}`;\n};\n\nexport const getInitInputForActionType = (\n  type: ActionTypes\n): { input: Input; hiddenData?: HiddenInputData } => {\n  switch (type) {\n    case \"SOLEND DEPOSIT LIQUIDITY\":\n      return {\n        input: [],\n      };\n    case \"MINT\":\n      return {\n        input: [\n          [\n            {\n              value: \"decimals\",\n              readOnly: true,\n            },\n            {\n              value: \"6\",\n              className: InputClassNames.wholeNumber,\n            },\n          ],\n          [\n            {\n              value: \"initialSupply\",\n              readOnly: true,\n            },\n            {\n              value: \"\",\n              className: InputClassNames.fractionNumber,\n            },\n          ],\n        ],\n      };\n\n    case \"TRANSFER\":\n      return {\n        input: [\n          [\n            {\n              value: \"recipientWallet\",\n              readOnly: true,\n            },\n            { value: \"\", className: InputClassNames.other },\n          ],\n        ],\n      };\n\n    case \"SERUM_SWAP\":\n      return {\n        input: [\n          [\n            {\n              value: \"outMint\",\n              readOnly: true,\n            },\n            { value: \"\", className: InputClassNames.mintAccount },\n          ],\n          [\n            {\n              value: \"minOut\",\n              readOnly: true,\n            },\n            { value: \"\", className: InputClassNames.wholeNumber },\n          ],\n        ],\n        hiddenData: {\n          rent: SYSVAR_RENT_PUBKEY.toBase58(),\n          serumDexProgramId: getConstants().projectSerum.DEX_PROGRAM_ID,\n        },\n      };\n\n    default:\n      throw `Unexpected action type ${type}`;\n  }\n};\n\nexport const setHardCodedNextActions = (\n  nextActions: NextAction[]\n): NextAction[] => {\n  const data = utils.object.deepCloneObject(nextActions);\n  for (let x = 0; x < data.length; x++) {\n    // TODO: this shouldn't be hardcoded\n    if (getVertexType(data[x][0]!.value) === \"MINT\") {\n      data[x][1]!.value = \"0\";\n      data[x][1]!.readOnly = true;\n    }\n  }\n  return data;\n};\n","import React, { useState, FC } from 'react';\nimport Card from '@mui/material/Card';\nimport CardActions from '@mui/material/CardActions';\nimport CardContent from '@mui/material/CardContent';\nimport Button from '@mui/material/Button';\nimport Spreadsheet from \"react-spreadsheet\";\n\nimport {\n    Input,\n    ActionEdge,\n    NodeType,\n    GraphType,\n    NextAction,\n    InputClassNames,\n    SourceNodeInput,\n  } from \"src/interfaces\";\n  import { useStore } from \"react-stores\";\n  import {\n    downloadGlobalStore,\n    globalStore,\n    INIT_NEXT_ACTION,\n    setGlobalStoreFromFile,\n    SOURCE_NODE_ID,\n  } from \"../globalStore\";\n  import {\n    compileAndRunMallocSDK,\n  } from \"src/utils/sdk-interpelator\";\n  import { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\n  import {\n    getSourceNodeAccount,\n  } from \"src/utils/graph\";\n  import { MallocSPLBuildActionMap } from \"@malloc/spl\";\n  import { TableCellEditor } from \"./table/table-cells\";\n  import { performUsdcAirdrop } from \"./usdc-airdrop/perform-usdc-airdrop\";\n  import { saveStringToFile } from \"src/utils/files\";\n  import { Satellite } from \"@material-ui/icons\";\n  import { getMintInfo, getTokenAccountInfo } from \"src/utils/spl-tokens\";\n  import { getProvider } from \"src/utils/anchor\";\n  import { PublicKey } from \"@solana/web3.js\";\n  import { ActionTypes, ACTION_TYPES, getActionTypeUIDFromVertex, getInitInputForActionType } from \"src/utils/action-types\";\n  \n\nconst NodeSelector: FC = () => {\n\n    const state = useStore(globalStore);\n    const actions = ACTION_TYPES;\n    const wallet = useAnchorWallet();\n    const buttonStyle = {\n        maxWidth: \"20px\",\n        maxHeight: \"20px\",\n        minWidth: \"20px\",\n        minHeight: \"20px\",\n    };\n\n    // Control panel loaders\n    const [loadingAirdrop, setLoadingAirdrop] = useState(false);\n    const [loadingCompileAndRun, setLoadingCompileAndRun] = useState(false);\n    // End control panel loaders\n\n    const setInput = async (data: Input) => {\n        state.graph[state.selected].input = data as Input;\n        let mintName = state.sourceMint;\n        if (state.selected === SOURCE_NODE_ID) {\n        const sourceAccount = getSourceNodeAccount(data as SourceNodeInput);\n        if (sourceAccount) {\n            const info = await getTokenAccountInfo(\n            getProvider(wallet!),\n            new PublicKey(sourceAccount)\n            );\n            if (info) {\n            mintName = info.mint.toBase58();\n            }\n        }\n        }\n        globalStore.setState({\n        ...state,\n        sourceMint: mintName,\n        graph: { ...state.graph },\n        });\n    };\n\n    return (\n        <Card>\n            <CardContent>\n                <h2>Node Id</h2>\n\n                <select\n                id=\"node-selector\"\n                className=\"form-select\"\n                size={10}\n                aria-label=\"size 3 select example\"\n                style={{ width: \"200px\" }}\n                onChange={(e) => {\n                    globalStore.setState({ selected: e.target.value });\n                }}\n                >\n                {Object.keys(state.graph).map(function (key, value) {\n                    return <option value={key}>{key}</option>;\n                })}\n                </select>\n        \n                <div style={{ width: '100%', display: 'flex', justifyContent: 'center'}}>\n\n                    <select\n                        className=\"form-select\"\n                        aria-label=\"Default select example\"\n                        onChange={(e) => {\n                            globalStore.setState({ new_action: e.target.value });\n                        }}\n                        >\n                        {actions.map((value, index) => {\n                            return <option value={value}>{value}</option>;\n                        })}\n                    </select>\n\n                    <Button\n                    variant=\"text\"\n                    style={buttonStyle}\n                    onClick={() => {\n                        let node_id = state.new_action + \"-\" + state.counter.toString();\n                        const init = getInitInputForActionType(\n                            state.new_action as ActionTypes\n                        );\n                        let new_node: NodeType = {\n                            input: init.input,\n                            // TODO: make a seperate fn\n                            next_actions: [\n                            ...Array(\n                                MallocSPLBuildActionMap[\n                                getActionTypeUIDFromVertex(\n                                    state.new_action as ActionTypes\n                                )\n                                ].expectedNumberOfOutMints\n                            ),\n                            ].map((i) => INIT_NEXT_ACTION),\n                        };\n                        state.graph[node_id] = new_node;\n                        state.hiddenInputData[node_id] = init.hiddenData || {};\n                        globalStore.setState({\n                            ...state,\n                            selected: node_id,\n                            counter: state.counter + 1,\n                            graph: { ...state.graph },\n                        });\n                        }}\n                    >\n                        +\n                    </Button>\n                    <Button\n                    variant=\"text\"\n                    style={buttonStyle}\n                    onClick={() => {\n                        if (state.selected == \"SOURCE-0\") return;\n                        delete state.graph[state.selected];\n                        globalStore.setState({\n                        ...state,\n                        selected: \"SOURCE-0\",\n                        graph: { ...state.graph },\n                        });\n                    }}\n                    >\n                    -\n                    </Button>\n                </div>\n            </CardContent>\n\n            </Card>\n    )\n}\n\nexport default NodeSelector\n","import React, { Ref, useRef } from \"react\";\nimport { makeStyles, Theme, createStyles } from \"@material-ui/core/styles\";\nimport Modal from \"@material-ui/core/Modal\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { useMemo } from \"react\";\nimport { useEffect } from \"react\";\nimport {\n  findAllAssociatedTokenAddress,\n  findAssociatedTokenAddress,\n  getMintInfo,\n  getTokenAccountInfo,\n  getTokenLists,\n} from \"../../utils/spl-tokens\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { SPLToken } from \"../../interfaces\";\nimport { shortenAddress } from \"../../utils/malloc\";\nimport { Provider } from \"@project-serum/anchor\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { isBundle } from \"typescript\";\nimport { useState } from \"react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { useStore } from \"react-stores\";\nimport { solanaSplStore } from \"../../state/flowchart-store\";\nimport { u64 } from \"@solana/spl-token\";\nimport { utils } from \"@malloc/sdk\";\n\nfunction getModalStyle() {\n  const top = 50;\n  const left = 50;\n\n  return {\n    top: `${top}%`,\n    left: `${left}%`,\n    transform: `translate(-${top}%, -${left}%)`,\n  };\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    paper: {\n      position: \"absolute\",\n      width: \"auto\",\n      backgroundColor: theme.palette.background.paper,\n      border: \"2px solid #000\",\n      boxShadow: theme.shadows[5],\n      padding: theme.spacing(2, 4, 3),\n    },\n  })\n);\n\nconst TokenLine = ({\n  tok,\n  setChoosen,\n}: {\n  tok: SPLToken;\n  setChoosen: () => void;\n}) => {\n  return (\n    <div\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: \"1fr 1fr 1fr 1fr 1fr\",\n        width: \"100%\",\n        gap: \"5px\",\n      }}\n    >\n      <button onClick={setChoosen}>Choose</button>\n      <div>{tok.info.name}</div>\n      <div>{shortenAddress(tok.info.mint.toBase58())}</div>\n      <div>\n        {shortenAddress(tok.account)}\n        {tok.balance ? \"\" : \" (currently nonexistent)\"}\n      </div>\n      <div>\n        {utils.tokens.toReadableNumber(\n          new u64(tok.balance || 0),\n          tok.info.decimals\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default function TokenAccountChooser(props: {\n  buttonText?: string;\n  onlyWithInitializedAccounts?: boolean;\n  onClose: (tok?: SPLToken) => void;\n  includeCustomTokenAccount?: boolean;\n}) {\n  const onlyWithInitializedAccounts = props.onlyWithInitializedAccounts ?? true;\n  const classes = useStyles();\n  // getModalStyle is not a pure function, we roll the style only on the first render\n  const [modalStyle] = React.useState(getModalStyle);\n  const [open, setOpen] = React.useState(false);\n  const [customTokenAccount, setCustomTokenAccount] = React.useState(\"\");\n  const [customMintAccount, setCustomMintAccount] = React.useState(\"\");\n  const wallet = useAnchorWallet();\n  // If it is -1, then the custom state is choosen\n  const [choosen, setChoosen] = useState(-1);\n  const solanaSplStoreHook = useStore(solanaSplStore);\n\n  const provider = getProvider(wallet!);\n\n  const loadTokens = async () => {\n    const tokenList = await getTokenLists(provider);\n    const associatedAddr = await findAllAssociatedTokenAddress(\n      wallet?.publicKey!,\n      tokenList.map((t) => t.address)\n    );\n\n    const bals = await Promise.all(\n      associatedAddr.map(async (addr) => {\n        const data = await getTokenAccountInfo(provider, addr);\n        return data?.amount;\n      })\n    );\n    const accounts = associatedAddr.map((addr, i) => {\n      return {\n        account: addr.toBase58(),\n        info: tokenList[i],\n        balance: bals[i],\n      };\n    });\n    const accountsFiltered = onlyWithInitializedAccounts\n      ? accounts.filter((i) => i.balance)\n      : accounts;\n    const accountsMapped = accountsFiltered.map((i) => {\n      return {\n        ...i,\n        info: {\n          ...i.info,\n          mint: new PublicKey(i.info.address),\n        },\n        balance: i.balance?.toString() || null,\n      };\n    });\n\n    solanaSplStore.setState({\n      ...solanaSplStoreHook,\n      derivedTokenAccounts: accountsMapped,\n    });\n  };\n\n  useEffect(() => {\n    loadTokens();\n  }, []);\n\n  const modalRef = useRef(null);\n\n  const handleOpen = () => {\n    loadTokens();\n    setOpen(true);\n  };\n\n  const handleClose = async () => {\n    if (!solanaSplStoreHook.derivedTokenAccounts) {\n      setOpen(false);\n      props.onClose();\n      return;\n    }\n    if (choosen >= 0)\n      props.onClose(solanaSplStoreHook.derivedTokenAccounts[choosen]);\n    else {\n      const choosenType = choosen === -1 ? \"TOKEN\" : \"MINT\";\n      if (\n        (choosenType === \"TOKEN\" && !customTokenAccount) ||\n        (choosenType === \"MINT\" && !customMintAccount)\n      ) {\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n\n      const tokenAccount =\n        choosenType === \"TOKEN\"\n          ? customTokenAccount\n          : (\n              await findAssociatedTokenAddress(\n                wallet!.publicKey,\n                customMintAccount\n              )\n            ).toBase58();\n      const tokAccountData = await getTokenAccountInfo(\n        provider,\n        new PublicKey(tokenAccount)\n      );\n      if (choosenType === \"TOKEN\" && !tokAccountData) {\n        alert(\"Looks like an invalid SPL Token Account was provided\");\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n      if (\n        choosenType === \"MINT\" &&\n        props.onlyWithInitializedAccounts !== false &&\n        !tokAccountData\n      ) {\n        alert(\n          \"Looks like there is no initialized associated account with this mint\"\n        );\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n      const mintAddr =\n        choosenType === \"TOKEN\"\n          ? tokAccountData!.mint\n          : new PublicKey(customMintAccount);\n\n      const mintInfo = await getMintInfo(provider, mintAddr);\n      if (!mintInfo) {\n        alert(\"Looks like the mint associated with this token is invalid\");\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n      const bal = tokAccountData?.amount || new u64(0);\n      props.onClose({\n        balance: bal,\n        account: tokenAccount,\n        info: {\n          ...mintInfo,\n          mint: mintAddr,\n        },\n      });\n    }\n    setOpen(false);\n    props.onClose();\n  };\n\n  const body = (\n    <div\n      onBlur={handleClose}\n      className=\"wrapper\"\n      // TODO: this is a bit ghetto but react modal isn't working with the cells\n      onClick={(e) => e.currentTarget.blur()}\n      style={{\n        position: \"fixed\",\n        top: \"0\",\n        left: \"0\",\n        height: \"100vh\",\n        width: \"100vw\",\n        zIndex: 100,\n        display: \"grid\",\n        justifyItems: \"center\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <div style={{ ...modalStyle }} className={classes.paper}>\n        <h2 id=\"simple-modal-title\">Choose a token account</h2>\n        <p id=\"simple-modal-description\">\n          Choose from either your associated token accounts or add a custom\n          address\n        </p>\n        <div\n          className=\"options\"\n          style={{ overflow: \"scroll\", maxHeight: \"70vh\" }}\n        >\n          <div\n            style={{\n              display: \"grid\",\n              gridTemplateColumns: \"1fr 1fr 1fr 1fr 1fr\",\n            }}\n          >\n            <span></span>\n            <div>Mint Name</div>\n            <div>Mint Address</div>\n            <div>Token Account Address</div>\n            <div>Amount</div>\n          </div>\n          {!solanaSplStoreHook.derivedTokenAccounts\n            ? \"Loading...\"\n            : solanaSplStoreHook.derivedTokenAccounts.map((tok, i) => (\n                <div\n                  key={`token-derived-account-${i}`}\n                  style={{\n                    padding: \"0.5rem\",\n                    border: choosen === i ? \"1px solid black\" : \"0px\",\n                  }}\n                >\n                  <TokenLine\n                    tok={tok}\n                    setChoosen={() => {\n                      setChoosen(i);\n                    }}\n                  />\n                  <br />\n                </div>\n              ))}\n          {/* TODO: add balance to the left of this once filled out */}\n          {props.includeCustomTokenAccount && (\n            <div\n              style={{\n                padding: \"0.5rem\",\n                border: choosen === -1 ? \"1px solid black\" : \"0px\",\n              }}\n            >\n              <TextField\n                label=\"Custom Token Account\"\n                value={customTokenAccount}\n                onChange={(e) => setCustomTokenAccount(e.target.value)}\n                onFocus={() => setChoosen(-1)}\n              />\n            </div>\n          )}\n          <p>Or</p>\n          <div\n            style={{\n              padding: \"0.5rem\",\n              border: choosen === -2 ? \"1px solid black\" : \"0px\",\n            }}\n          >\n            <TextField\n              label=\"Custom Mint Account\"\n              value={customMintAccount}\n              onChange={(e) => setCustomMintAccount(e.target.value)}\n              onFocus={() => setChoosen(-2)}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <div>\n      <button type=\"button\" onClick={handleOpen}>\n        {props.buttonText || \"Choose Token Account\"}\n      </button>\n\n      {/* <Modal\n        open={open}\n        ref={modalRef}\n        onClose={handleClose}\n        aria-labelledby=\"simple-modal-title\"\n        aria-describedby=\"simple-modal-description\"\n      > */}\n      {open && body}\n      {/* </Modal> */}\n    </div>\n  );\n}\n","import Input from \"@material-ui/core/Input\";\nimport { getVertexType } from \"src/utils/graph\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport Select from \"@mui/material/Select\";\nimport FocusTrap from \"focus-trap-react\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport {\n  CellBase,\n  DataEditorComponent,\n  DataEditorProps,\n} from \"react-spreadsheet\";\nimport { useStore } from \"react-stores\";\nimport { globalStore, MallocState } from \"src/globalStore\";\nimport { InputClassNames } from \"src/interfaces\";\nimport { getActionVertices } from \"src/utils/graph\";\nimport TokenAccountChooser from \"../tokens/TokenAccountChooser\";\n\nconst InputEditor = (\n  props: DataEditorProps<CellBase> & {\n    isWholeNumber?: boolean;\n    isFractionNumber?: boolean;\n  }\n) => {\n  return (\n    <Input\n      onChange={(e) => {\n        props.onChange({\n          ...props.cell,\n          value: props.isWholeNumber\n            ? parseInt(e.target.value).toString()\n            : e.target.value,\n        });\n      }}\n      value={props.cell?.value || \"\"}\n      type={props.isFractionNumber || props.isWholeNumber ? \"number\" : \"text\"}\n    />\n  );\n};\n\nconst TokenOrMintEditor = (\n  props: DataEditorProps<CellBase> & {\n    type: \"mint\" | \"token\";\n    onlyWithInitialized: boolean;\n  }\n) => {\n  return (\n    <div>\n      <TokenAccountChooser\n        buttonText={\"select\"}\n        onlyWithInitializedAccounts={props.onlyWithInitialized}\n        onClose={(splTok) => {\n          if (splTok) {\n            const value =\n              props.type === \"token\"\n                ? splTok.account\n                : splTok.info.mint.toBase58();\n            props.onChange({\n              ...props.cell,\n              value,\n            });\n          }\n        }}\n      />\n    </div>\n  );\n};\n\nconst ActionVertexEditor = (\n  props: DataEditorProps<CellBase> & {\n    nextActionMintIdx: number;\n  }\n) => {\n  const store = useStore(globalStore);\n  const vertices = getActionVertices(store.graph);\n  const [active, setActive] = useState(true);\n  const [pause, setPause] = useState(false);\n\n  const setState = (id: string) => {\n    props.onChange({ ...props.cell, value: id });\n    setActive(false);\n  };\n\n  return (\n    <div>\n      <FocusTrap active={active} paused={pause}>\n        <Select\n          labelId=\"demo-simple-select-label\"\n          id=\"demo-simple-select\"\n          value={props.cell?.value}\n          label=\"Age\"\n          style={{\n            height: \"20px\",\n          }}\n        >\n          {vertices.map((id) => {\n            return (\n              <span key={`select-opts-${id}`}>\n                <MenuItem\n                  style={{ zIndex: 100 }}\n                  value={id}\n                  onMouseOver={() => setPause(true)}\n                  onFocus={() => setState(id)}\n                >\n                  {id}\n                </MenuItem>\n              </span>\n            );\n          })}\n        </Select>\n      </FocusTrap>\n    </div>\n  );\n};\n\nexport const TableCellEditor: DataEditorComponent<CellBase> = (\n  props: DataEditorProps<CellBase>\n) => {\n  const className = (props.cell?.className || \"\").split(\"-\")[0];\n  switch (className) {\n    case InputClassNames.actionVertex:\n      const nextActionMintIdx = parseInt(\n        props.cell!.className!.split(\"-\")[1] || \"\"\n      );\n      return ActionVertexEditor({ ...props, nextActionMintIdx });\n    case InputClassNames.mintAccountOnlyInit:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"mint\",\n        onlyWithInitialized: true,\n      });\n    case InputClassNames.tokenAccountOnlyInit:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"token\",\n        onlyWithInitialized: true,\n      });\n    case InputClassNames.mintAccount:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"mint\",\n        onlyWithInitialized: false,\n      });\n    case InputClassNames.tokenAccount:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"token\",\n        onlyWithInitialized: false,\n      });\n    case InputClassNames.other:\n      return InputEditor(props);\n    case InputClassNames.wholeNumber:\n      return InputEditor({ ...props, isWholeNumber: true });\n    case InputClassNames.fractionNumber:\n      return InputEditor({ ...props, isFractionNumber: true });\n    default:\n      return InputEditor(props);\n  }\n};\n","import React, { useState, FC } from \"react\";\nimport Card from \"@mui/material/Card\";\nimport CardActions from \"@mui/material/CardActions\";\nimport CardContent from \"@mui/material/CardContent\";\nimport Button from \"@mui/material/Button\";\nimport Spreadsheet from \"react-spreadsheet\";\n\nimport {\n  Input,\n  ActionEdge,\n  NodeType,\n  GraphType,\n  NextAction,\n  InputClassNames,\n  SourceNodeInput,\n} from \"src/interfaces\";\nimport { useStore } from \"react-stores\";\nimport {\n  downloadGlobalStore,\n  globalStore,\n  INIT_NEXT_ACTION,\n  setGlobalStoreFromFile,\n  SOURCE_NODE_ID,\n} from \"../globalStore\";\nimport { compileAndRunMallocSDK } from \"src/utils/sdk-interpelator\";\nimport { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\nimport { getNextActionRow, getSourceNodeAccount } from \"src/utils/graph\";\nimport { MallocSPLBuildActionMap } from \"@malloc/spl\";\nimport { saveStringToFile } from \"src/utils/files\";\nimport { getMintInfo, getTokenAccountInfo } from \"src/utils/spl-tokens\";\nimport {\n  getActionTypeUIDFromVertex,\n  getInitInputForActionType,\n  setHardCodedNextActions,\n} from \"src/utils/action-types\";\nimport { utils } from \"@malloc/sdk\";\nimport { getProvider } from \"src/utils/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { TableCellEditor } from \"./table/table-cells\";\n\nconst NodeInfo: FC = () => {\n  const state = useStore(globalStore);\n  const wallet = useAnchorWallet();\n\n  const setInput = async (data: Input) => {\n    state.graph[state.selected].input = data as Input;\n    let mintName = state.sourceMint;\n    if (state.selected === SOURCE_NODE_ID) {\n      const sourceAccount = getSourceNodeAccount(data as SourceNodeInput);\n      if (sourceAccount) {\n        const info = await getTokenAccountInfo(\n          getProvider(wallet!),\n          new PublicKey(sourceAccount)\n        );\n        if (info) {\n          mintName = info.mint.toBase58();\n        }\n      }\n    }\n    globalStore.setState({\n      ...state,\n      sourceMint: mintName,\n      graph: { ...state.graph },\n    });\n  };\n\n  return (\n    <Card>\n      <CardContent>\n        <h2>{state.selected} info</h2>\n\n        {state.selected === SOURCE_NODE_ID && (\n          <p>Source Mint: {state.sourceMint}</p>\n        )}\n\n        <h5>Input</h5>\n        <Spreadsheet\n          data={state.graph[state.selected].input}\n          onChange={(data) => setInput(data as Input)}\n          DataEditor={TableCellEditor}\n        />\n\n        {state.graph[state.selected].next_actions.length != 0 && (\n          <h5>Next Action</h5>\n        )}\n        {state.graph[state.selected].next_actions.map(\n          (next_action_by_mint, i) => {\n            return (\n              <div key={`next-action-${i}`}>\n                <Spreadsheet\n                  data={state.graph[state.selected].next_actions[i]}\n                  onChange={(_data) => {\n                    state.graph[state.selected].next_actions[i] =\n                      setHardCodedNextActions(_data as NextAction[]);\n                    globalStore.setState({\n                      ...state,\n                      graph: { ...state.graph },\n                    });\n                    console.log(state.graph[state.selected].next_actions);\n                  }}\n                  DataEditor={TableCellEditor}\n                />\n                <CardActions>\n                  <div\n                    style={{\n                      width: \"100%\",\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                    }}\n                  >\n                    <Button\n                      variant=\"text\"\n                      onClick={() => {\n                        state.graph[state.selected].next_actions[i] = [\n                          ...state.graph[state.selected].next_actions[i],\n                          getNextActionRow(i),\n                        ];\n                        globalStore.setState({\n                          ...state,\n                          graph: { ...state.graph },\n                        });\n                        console.log(\n                          \"new action\",\n                          state.graph[state.selected].next_actions\n                        );\n                      }}\n                    >\n                      New Action\n                    </Button>\n\n                    <Button\n                      variant=\"text\"\n                      onClick={() => {\n                        if (\n                          state.graph[state.selected].next_actions.length > 2\n                        ) {\n                          let temp = state.graph[state.selected].next_actions;\n                          state.graph[state.selected].next_actions = temp.slice(\n                            0,\n                            temp.length - 1\n                          );\n                          globalStore.setState({\n                            ...state,\n                            graph: { ...state.graph },\n                          });\n                          console.log(\n                            \"remove action\",\n                            state.graph[state.selected].next_actions\n                          );\n                        }\n                      }}\n                    >\n                      Remove Action\n                    </Button>\n                  </div>\n                </CardActions>\n              </div>\n            );\n          }\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default NodeInfo;\n","import React, { useState, useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\n\nimport { useStore } from \"react-stores\";\nimport {\n  ActionTypes,\n  ACTION_TYPES,\n  downloadGlobalStore,\n  globalStore,\n  INIT_NEXT_ACTION,\n  setGlobalStoreFromFile,\n  SOURCE_NODE_ID,\n} from \"../globalStore\";\n\nconst GraphVisualizer = (graph) => {\n  const state = useStore(globalStore);\n  const svgRef = useRef();\n\n  // ...D3 code\n  useEffect(() => {\n    // DATA\n    let nodes = Object.keys(state.graph).map(function (key, index) {\n      return { id: key };\n    });\n\n    let edges = [];\n    for (const key of Object.keys(state.graph)) {\n      let node = state.graph[key];\n      let node_edges = [];\n\n      if (node[\"next_actions\"] != null && node[\"next_actions\"].length != 0) {\n        for (var i = 1; i < node[\"next_actions\"][0].length; i++) {\n          var val = node[\"next_actions\"][0][i][0].value;\n          if (val != \"\") {\n            node_edges.push({\n              source: key,\n              target: val,\n              type: \"0\",\n            });\n          }\n        }\n      }\n\n      if (node_edges.length != 0) edges = edges.concat(node_edges);\n    }\n\n    let links =\n      edges.length == 0\n        ? [{ source: \"SOURCE-0\", target: \"SOURCE-0\", type: \"0\" }]\n        : edges;\n\n    console.log(\"EDGES\", edges);\n    console.log(\"LINKS\", links);\n\n    const data = {\n      nodes,\n      links,\n    };\n    let types = [\"0\"];\n\n    // STYLING\n    let [width, height] = [300, 300];\n    let color = d3.scaleOrdinal(types, d3.schemeCategory10);\n\n    let linkArc = (d) => {\n      const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);\n      return `\n              M${d.source.x},${d.source.y}\n              A${0},${0} 0 0,1 ${d.target.x},${d.target.y}\n            `;\n    };\n\n    let drag = (simulation) => {\n      function dragstarted(event, d) {\n        if (!event.active) simulation.alphaTarget(0.3).restart();\n        d.fx = d.x;\n        d.fy = d.y;\n      }\n\n      function dragged(event, d) {\n        d.fx = event.x;\n        d.fy = event.y;\n      }\n\n      function dragended(event, d) {\n        if (!event.active) simulation.alphaTarget(0);\n        d.fx = null;\n        d.fy = null;\n      }\n\n      return d3\n        .drag()\n        .on(\"start\", dragstarted)\n        .on(\"drag\", dragged)\n        .on(\"end\", dragended);\n    };\n\n    links = data.links.map((d) => Object.create(d));\n    nodes = data.nodes.map((d) => Object.create(d));\n\n    const simulation = d3\n      .forceSimulation(nodes)\n      .force(\n        \"link\",\n        d3.forceLink(links).id((d) => d.id)\n      )\n      .force(\"charge\", d3.forceManyBody().strength(-400))\n      .force(\"x\", d3.forceX())\n      .force(\"y\", d3.forceY());\n\n    const svg = d3\n      .select(svgRef.current)\n      .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n      .style(\"font\", \"12px sans-serif\");\n\n    svg\n      .append(\"rect\")\n      .attr(\"x\", -width)\n      .attr(\"y\", -height)\n      .attr(\"width\", 2 * width)\n      .attr(\"height\", 2 * height)\n      .attr(\"fill\", \"white\");\n\n    // Per-type markers, as they don't inherit styles.\n    svg\n      .append(\"defs\")\n      .selectAll(\"marker\")\n      .data(types)\n      .join(\"marker\")\n      .attr(\"id\", (d) => `arrow-${d}`)\n      .attr(\"viewBox\", \"0 -5 10 10\")\n      .attr(\"refX\", 15)\n      .attr(\"refY\", -0.5)\n      .attr(\"markerWidth\", 6)\n      .attr(\"markerHeight\", 6)\n      .attr(\"orient\", \"auto\")\n      .append(\"path\")\n      .attr(\"fill\", color)\n      .attr(\"d\", \"M0,-5L10,0L0,5\");\n\n    const link = svg\n      .append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", 1.5)\n      .selectAll(\"path\")\n      .data(links)\n      .join(\"path\")\n      .attr(\"stroke\", (d) => color(d.type))\n      .attr(\n        \"marker-end\",\n        (d) => `url(${new URL(`#arrow-${d.type}`, location)})`\n      );\n\n    const node = svg\n      .append(\"g\")\n      .attr(\"fill\", \"currentColor\")\n      .attr(\"stroke-linecap\", \"round\")\n      .attr(\"stroke-linejoin\", \"round\")\n      .selectAll(\"g\")\n      .data(nodes)\n      .join(\"g\")\n      .call(drag(simulation));\n\n    node\n      .append(\"circle\")\n      .attr(\"stroke\", \"white\")\n      .attr(\"stroke-width\", 1.5)\n      .attr(\"r\", 4);\n\n    node\n      .append(\"text\")\n      .attr(\"x\", 8)\n      .attr(\"y\", \"0.31em\")\n      .text((d) => d.id)\n      .clone(true)\n      .lower()\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"white\")\n      .attr(\"stroke-width\", 3);\n\n    simulation.on(\"tick\", () => {\n      link.attr(\"d\", linkArc);\n      node.attr(\"transform\", (d) => `translate(${d.x},${d.y})`);\n    });\n  }, [state]);\n\n  return (\n    <div style={{ border: \"2px solid black\", padding: \"10px\", width: \"300px\" }}>\n      <svg ref={svgRef}></svg>\n      <p>{state.selected}</p>\n    </div>\n  );\n};\n\nexport default GraphVisualizer;\n","import { PublicKey } from \"@solana/web3.js\";\n\nexport const frontendErrorTypeID = \"MALLOC_FLOWCHART_ERROR\";\n\nexport type FrontendError = {\n  type: \"MALLOC_FLOWCHART_ERROR\";\n  msg: string;\n  fullError?: any;\n};\n\nexport const handleError = (e: any) => {\n  console.error(e)\n  if (e?.errorType === frontendErrorTypeID) {\n    const eCast = e as FrontendError;\n    alert(eCast.msg)\n    if(eCast.fullError) throw eCast.fullError\n  } else {\n    alert(`An unexpected error occured: ${e}`)\n    throw e;\n  }\n};\n\nexport const ErrorGenerator = {\n  TOKEN_ACCOUNT_DOES_NOT_EXIST: (tokAccount: PublicKey | string) =>\n    newFrontendError(\n      `The token account ${tokAccount.toString()} does not exist`\n    ),\n  INVALID_AMOUNT_INPUT: (amount: string) =>\n    newFrontendError(`${amount} is not a valid number for the input`),\n  MINT_ACCOUNT_DOES_NOT_EXIST: (\n    mintAccount: PublicKey | string,\n    tokAccount?: PublicKey | string\n  ) =>\n    newFrontendError(\n      tokAccount\n        ? `The mint ${mintAccount.toString()} found from token ${tokAccount.toString()} does not exist`\n        : `The mint ${mintAccount.toString()} does not exist`\n    ),\n};\n\nconst newFrontendError = (msg: string, e?: any) => {\n  return {\n    msg,\n    fullError: e,\n    type: \"MALLOC_FLOWCHART_ERROR\",\n  } as FrontendError;\n};\n","import {\n  Action,\n  utils as mallocUtils,\n  BuildEphemeralTxsInstr,\n  builder,\n  MallocSdk,\n  NonUserSpecificConstruction,\n  NonUserSpecificConstructionAction,\n  ActionMetadata,\n  utils,\n} from \"@malloc/sdk\";\nimport { BN, Provider } from \"@project-serum/anchor\";\nimport { AnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getConstants } from \"src/config/constants\";\nimport {\n  getGlobalStore,\n  globalStore,\n  SOURCE_NODE_ID,\n} from \"src/globalStore\";\nimport {\n  GraphType,\n  HiddenInputData,\n  Input,\n  NodeType,\n  SourceNodeInput,\n} from \"src/interfaces\";\nimport { getProvider } from \"./anchor\";\nimport { ErrorGenerator, handleError } from \"./errors\";\nimport {\n  getAllVertices,\n  getNextVertices,\n  getSourceNode,\n  getSourceNodeAccount,\n  getSourceNodeAmount,\n  getVertexType,\n} from \"./graph\";\nimport { getMintInfo, getTokenAccountInfo } from \"./spl-tokens\";\nimport {\n  MallocSPLBuildActionMap,\n  SwapAction,\n  TransferAction,\n} from \"@malloc/spl\";\nimport { GroupAddSharp } from \"@material-ui/icons\";\nimport {\n  getActionPIDFromVertex,\n  getActionTypeUIDFromVertex,\n} from \"./action-types\";\n\nconst PID = new PublicKey(getConstants().MALLOC_PROGRAM_ID);\nconst getMallocSdk = (wallet: AnchorWallet) =>\n  new MallocSdk(PID, getProvider(wallet));\n\nconst getAllIncomingVertexIds = (actionId: string, graph: GraphType) =>\n  getAllVertices(graph).filter((v) =>\n    getNextVertices(graph, v).some((nextEdgeSet) =>\n      nextEdgeSet.map((i) => i.id).includes(actionId)\n    )\n  );\n\nconst getInputFromActionInput = (\n  actionInput: Input,\n  hiddenInputData: any\n): any => {\n  const ret = {} as any;\n  actionInput.map((inpItem) => {\n    ret[inpItem[0].value] = inpItem[1].value;\n  });\n  return { ...ret, ...hiddenInputData };\n};\n\nconst getNextNodes = (\n  allActionIds: string[],\n  actionId: string,\n  graph: GraphType\n): ActionMetadata[\"nextNodes\"] => {\n  const nextActions = getNextVertices(graph, actionId);\n\n  const groupedByMints: ActionMetadata[\"nextNodes\"] = nextActions.map(\n    (nextActionSet) => {\n      return nextActionSet.map((next) => {\n        return {\n          actionIdx: allActionIds.indexOf(next.id),\n          fraction: next.amount,\n        };\n      });\n    }\n  );\n\n  return groupedByMints;\n};\n\nconst getActionData = (\n  actionId: string,\n  allActionIds: string[],\n  graph: GraphType,\n  hiddenInputData: HiddenInputData\n): NonUserSpecificConstructionAction => {\n  const incomingVertices = getAllIncomingVertexIds(actionId, graph);\n\n  const nextNodes: ActionMetadata[\"nextNodes\"] = getNextNodes(\n    allActionIds,\n    actionId,\n    graph\n  );\n\n  const vertexType = getVertexType(actionId);\n  return {\n    actionTypeUID: getActionTypeUIDFromVertex(vertexType),\n    buildActionInputs: getInputFromActionInput(\n      graph[actionId].input,\n      hiddenInputData[actionId]\n    ),\n    actionPID: getActionPIDFromVertex(vertexType),\n    actionMetadata: {\n      ripeAmount: incomingVertices.length,\n      nextNodes,\n    },\n  };\n};\n\nconst _buildNonUserSpecificConstruction = async (\n  g: GraphType,\n  hiddenInputDatas: HiddenInputData,\n  actionVertices: string[],\n  initialSplits: number[],\n  initialActionIndices: number[],\n  amount: string\n): Promise<NonUserSpecificConstruction> => {\n  const vertices = getAllVertices(g);\n\n  return {\n    actionDatas: actionVertices.map((v) =>\n      getActionData(v, actionVertices, g, hiddenInputDatas)\n    ),\n    initialSplits,\n    initialActionIndices,\n    amount,\n  };\n};\n\nconst getInitialInfo = async (\n  g: GraphType,\n  inAccount: PublicKey,\n  actionVertices: string[],\n  provider: Provider\n) => {\n  const sourceNode = getSourceNode(g);\n  const tokenInInfo = await getTokenAccountInfo(provider, inAccount);\n  if (!tokenInInfo) {\n    throw ErrorGenerator.TOKEN_ACCOUNT_DOES_NOT_EXIST(inAccount);\n  }\n\n  const mint = tokenInInfo.mint;\n  const mintInfo = await getMintInfo(provider, mint);\n\n  if (!mintInfo) {\n    throw ErrorGenerator.MINT_ACCOUNT_DOES_NOT_EXIST(mint, inAccount);\n  }\n\n  let amountInF: number;\n  try {\n    amountInF = parseFloat(\n      getSourceNodeAmount(sourceNode.input as SourceNodeInput)\n    );\n  } catch (e) {\n    throw ErrorGenerator.INVALID_AMOUNT_INPUT(\n      getSourceNodeAmount(sourceNode.input as SourceNodeInput)\n    );\n  }\n  const amountIn = utils.tokens.fromReadableNumber(\n    amountInF,\n    mintInfo.decimals\n  );\n  const nextFromSource = getNextVertices(g, SOURCE_NODE_ID)[0];\n\n  return {\n    amount: amountIn,\n    initialMint: mint,\n    initialSplits: nextFromSource.map((n) => n.amount),\n    initialActionIndices: nextFromSource.map((n) =>\n      actionVertices.indexOf(n.id)\n    ),\n  };\n};\n\nconst compileStateIntoSDKInput = async (\n  wallet: AnchorWallet,\n  preferredTokenAccounts?: mallocUtils.tokens.PreferredTokenAccounts\n): Promise<BuildEphemeralTxsInstr> => {\n  const { graph, hiddenInputData: hiddenData } = getGlobalStore();\n\n  const inAccount = new PublicKey(\n    getSourceNodeAccount(getSourceNode(graph).input as SourceNodeInput)\n  );\n\n  const provider = getProvider(wallet);\n  const vertices = getAllVertices(graph);\n  const actionVertices = vertices.slice(1);\n  const { initialSplits, initialActionIndices, initialMint, amount } =\n    await getInitialInfo(graph, inAccount, actionVertices, provider);\n\n  // Get the non specific\n  const nonUserSpecific = await _buildNonUserSpecificConstruction(\n    graph,\n    hiddenData,\n    actionVertices,\n    initialSplits,\n    initialActionIndices,\n    amount\n  );\n\n  const construction = await builder.buildConstructionFromNonUserSpecific(\n    nonUserSpecific,\n    MallocSPLBuildActionMap,\n    inAccount.toBase58(),\n    initialMint.toBase58(),\n    provider\n  );\n\n  return {\n    actions: construction.actions,\n    initialSplits: construction.initialSplits,\n    amount: construction.amount,\n    initialActionIndices: construction.initialActionIndices,\n    amountInAccount: inAccount,\n    opts: { preferredTokenAccounts },\n  };\n};\n\nconst run = async (\n  inp: BuildEphemeralTxsInstr,\n  wallet: AnchorWallet\n): Promise<string[]> => {\n  const sdk = getMallocSdk(wallet);\n  const data = await sdk.buildTxs(inp);\n  return await sdk.sendRequests(data, {\n    prepareCommitment: {\n      skipPreflight: false,\n      preflightCommitment: \"single\",\n      commitment: \"single\",\n    },\n    actionCommitment: {\n      skipPreflight: false,\n      preflightCommitment: \"single\",\n      commitment: \"single\",\n    },\n  });\n};\n\nexport const compileAndRunMallocSDK = async (wallet: AnchorWallet) => {\n  try {\n    const buildInst = await compileStateIntoSDKInput(wallet);\n    const txs = await run(buildInst, wallet);\n    alert(`DONE AND SUCCESSFUL with tx: ${txs}`);\n  } catch (e) {\n    handleError(e);\n  }\n};\n","import { Wallet } from \"@project-serum/anchor\";\nimport { createTokenAccount, Provider } from \"@project-serum/common\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { Connection, Keypair, PublicKey, Transaction } from \"@solana/web3.js\";\nimport { getConstants } from \"../../config/constants\";\n\nconst richUSDCAirdroperSK = new Uint8Array([\n  8, 57, 204, 222, 105, 129, 113, 8, 245, 54, 20, 45, 122, 175, 82, 37, 32, 44,\n  46, 6, 54, 35, 168, 208, 213, 194, 164, 50, 97, 226, 134, 119, 136, 196, 213,\n  189, 243, 233, 16, 53, 22, 220, 245, 4, 17, 203, 251, 233, 20, 7, 178, 5, 36,\n  19, 66, 89, 210, 148, 19, 225, 117, 61, 214, 253,\n]);\n\nconst richUSDCSigner = new Wallet(Keypair.fromSecretKey(richUSDCAirdroperSK));\n\nconst getRichUsdcProvider = (endpointURL: string) =>\n  new Provider(new Connection(endpointURL), richUSDCSigner, {\n    commitment: \"confirmed\",\n  });\n\nexport const performUsdcAirdrop = async (userAddr: PublicKey) => {\n  try {\n    const tokAccount = await tryCreateAssociatedAccount(\n      new PublicKey(getConstants().demo.FAKE_USDC),\n      userAddr,\n      getRichUsdcProvider(getConstants().solana.RPC)\n    );\n    await airdrop(new PublicKey(getConstants().demo.FAKE_USDC_GD), [\n      tokAccount,\n    ]);\n    alert(\"Done with your airdrop\");\n  } catch (e) {\n    console.error(e);\n    alert(`An error occurred with the airdrop ${JSON.stringify(e)}`);\n  }\n};\n\nconst tryCreateAssociatedAccount = async (\n  mint: PublicKey,\n  account: PublicKey,\n  provider: Provider\n): Promise<PublicKey> => {\n  const associated = (\n    await PublicKey.findProgramAddress(\n      [\n        account.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(mint).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n  const data = await provider.connection.getAccountInfo(associated);\n  if (!data) {\n    const instr = Token.createAssociatedTokenAccountInstruction(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      mint,\n      associated,\n      account,\n      provider.wallet.publicKey\n    );\n    const tx = new Transaction();\n    tx.add(instr);\n    await provider.send(tx, []);\n    return associated;\n  }\n  return associated;\n};\n\nconst airdrop = async (\n  gdUsdc: PublicKey,\n  airDropToTokenAccounts: PublicKey[]\n) => {\n  const decimals = 6;\n  const amountAirdrop = 4 * 10 ** decimals;\n\n  const transferTxs: Transaction = new Transaction();\n  airDropToTokenAccounts.map((tokAccount) => {\n    transferTxs.add(\n      Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        gdUsdc,\n        tokAccount,\n        richUSDCSigner.publicKey,\n        [],\n        amountAirdrop\n      )\n    );\n  });\n\n  await getRichUsdcProvider(getConstants().solana.RPC).send(transferTxs, [], {\n    skipPreflight: true,\n  });\n};\n","import React, { useState, FC } from \"react\";\nimport Card from \"@mui/material/Card\";\nimport CardActions from \"@mui/material/CardActions\";\nimport CardContent from \"@mui/material/CardContent\";\nimport Button from \"@mui/material/Button\";\nimport GraphVisualizer from \"./graph-visualizer\";\n\nimport {\n  Input,\n  ActionEdge,\n  NodeType,\n  GraphType,\n  NextAction,\n  InputClassNames,\n  SourceNodeInput,\n} from \"src/interfaces\";\nimport { useStore } from \"react-stores\";\nimport {\n  downloadGlobalStore,\n  globalStore,\n  INIT_NEXT_ACTION,\n  setGlobalStoreFromFile,\n  SOURCE_NODE_ID,\n} from \"../globalStore\";\nimport { compileAndRunMallocSDK } from \"src/utils/sdk-interpelator\";\nimport { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\nimport { getSourceNodeAccount } from \"src/utils/graph\";\nimport { MallocSPLBuildActionMap } from \"@malloc/spl\";\nimport { TableCellEditor } from \"./table/table-cells\";\nimport { performUsdcAirdrop } from \"./usdc-airdrop/perform-usdc-airdrop\";\nimport { saveStringToFile } from \"src/utils/files\";\nimport { Satellite } from \"@material-ui/icons\";\nimport { getMintInfo, getTokenAccountInfo } from \"src/utils/spl-tokens\";\nimport { getProvider } from \"src/utils/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport {\n  getActionTypeUIDFromVertex,\n  getInitInputForActionType,\n} from \"src/utils/action-types\";\n\nconst NodeVisualizer = () => {\n  const state = useStore(globalStore);\n  const wallet = useAnchorWallet();\n\n  // Control panel loaders\n  const [loadingAirdrop, setLoadingAirdrop] = useState(false);\n  const [loadingCompileAndRun, setLoadingCompileAndRun] = useState(false);\n  // End control panel loaders\n\n  return (\n    <Card>\n      <CardContent>\n        <h2>Visualizer</h2>\n        <GraphVisualizer />\n      </CardContent>\n      <CardActions>\n            <Button\n            variant=\"text\"\n            disabled={loadingCompileAndRun}\n            onClick={() => {\n                setLoadingCompileAndRun(true);\n                compileAndRunMallocSDK(wallet!)\n                .then((_) => setLoadingCompileAndRun(false))\n                .catch((e) => setLoadingCompileAndRun(false));\n            }}\n            >\n            {loadingCompileAndRun ? \"Running...\" : \"Compile and Run\"}\n            </Button>\n\n            <Button\n            variant=\"text\"\n            onClick={() => {\n                setLoadingAirdrop(true);\n                performUsdcAirdrop(wallet!.publicKey).then((_) =>\n                setLoadingAirdrop(false)\n                );\n            }}\n            disabled={loadingAirdrop}\n            >\n            {loadingAirdrop ? \"Loading Airdrop...\" : \"Airdrop Fake USDC\"}\n            </Button>\n\n            <Button variant=\"text\" onClick={() => setGlobalStoreFromFile()}>\n            Import\n            </Button>\n\n            <Button variant=\"text\" onClick={() => downloadGlobalStore()}>\n            Export\n            </Button>\n      </CardActions>\n    </Card>\n  );\n};\n\nexport default NodeVisualizer;\n","import React, { useState, FC } from \"react\";\nimport Card from \"@mui/material/Card\";\n\nimport NodeSelector from './node-selector';\nimport NodeInfo from './node-info';\nimport NodeVisualizer from './node-visualizer';\n\nconst TableGUI: FC = () => {\n\n    return (\n        <div style={{ width: '100%', display: 'flex', justifyContent: 'center', gap: '10px'}}>\n            <Card>\n                <div style={{ width: '100%', display: 'flex', justifyContent: 'space-around', alignItems: 'flex-start', gap: '10px'}}>\n                    <NodeSelector />\n                    <NodeInfo />\n                    <NodeVisualizer />\n                </div>\n            </Card>\n        </div>\n  );\n};\n\nexport default TableGUI;\n","import { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport Countdown from \"react-countdown\";\nimport { Button, CircularProgress, Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\n\nimport * as anchor from \"@project-serum/anchor\";\n\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\n\nimport {\n  awaitTransactionSignatureConfirmation,\n  shortenAddress,\n} from \"./utils/malloc\";\nimport { useStore } from \"react-stores\";\nimport LoadingTX from \"./components/tx-handler/LoadingTX\";\nimport TableGUI from \"./components/tablegui\";\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nconst CounterText = styled.span``; // add your styles here\n\nexport interface HomeProps {\n  config: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  txTimeout: number;\n}\n\nconst Home = (props: HomeProps) => {\n  const [balance, setBalance] = useState<number>();\n  const [isActive, setIsActive] = useState(false); // true when countdown completes\n  const [isSoldOut, setIsSoldOut] = useState(false); // true when items remaining is zero\n  const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n\n  const wallet = useWallet();\n\n  useEffect(() => {\n    (async () => {\n      if (wallet?.publicKey) {\n        const balance = await props.connection.getBalance(wallet.publicKey);\n        setBalance(balance / LAMPORTS_PER_SOL);\n      }\n    })();\n  }, [wallet, props.connection]);\n\n  return (\n    <main>\n      {wallet.connected && (\n        <p style={{ marginTop: 0 }}>\n          Address: {shortenAddress(wallet.publicKey?.toBase58() || \"\")}\n        </p>\n      )}\n\n      {wallet.connected && (\n        <p>Balance: {(balance || 0).toLocaleString()} SOL</p>\n      )}\n      {wallet.connected && \"WALLET CONNECTED\"}\n      {!wallet.connected && <ConnectButton>Connect Wallet</ConnectButton>}\n      <Snackbar\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n\n      {wallet.connected && <TableGUI />}\n    </main>\n  );\n};\n\ninterface AlertState {\n  open: boolean;\n  message: string;\n  severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nconst renderCounter = ({ days, hours, minutes, seconds, completed }: any) => {\n  return (\n    <CounterText>\n      {hours} hours, {minutes} minutes, {seconds} seconds\n    </CounterText>\n  );\n};\n\nexport default Home;\n","import \"./App.css\";\nimport { useMemo } from \"react\";\n\nimport Home from \"./Home\";\n\nimport * as anchor from \"@project-serum/anchor\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n  ConnectionProvider,\n  WalletProvider,\n} from \"@solana/wallet-adapter-react\";\n\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\nimport { getConstants } from \"./config/constants\";\n\nconst config = new anchor.web3.PublicKey(getConstants().MALLOC_PROGRAM_ID);\n\nconst network = getConstants().solana.NETWORK;\n\nconst rpcHost = getConstants().solana.RPC;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst txTimeout = 30000; // milliseconds (confirm this works for your project)\n\nconst App = () => {\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [getPhantomWallet(), getSolflareWallet(), getSolletWallet()],\n    []\n  );\n\n  return (\n    <ConnectionProvider endpoint={endpoint}>\n      <WalletProvider wallets={wallets} autoConnect>\n        <WalletDialogProvider>\n          <Home\n            config={config}\n            connection={connection}\n            txTimeout={txTimeout}\n          />\n        </WalletDialogProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { PublicKey } from \"@solana/web3.js\";\n\nexport enum Side {\n  Bid = 0,\n  Ask = 1,\n}\n\nexport interface SwapAccounts {\n  market: {\n    market: PublicKey;\n    requestQueue: PublicKey;\n    eventQueue: PublicKey;\n    bids: PublicKey;\n    asks: PublicKey;\n    coinVault: PublicKey;\n    pcVault: PublicKey;\n    vaultSigner: PublicKey;\n    // User params.\n    openOrders: PublicKey;\n    orderPayerTokenAccount: PublicKey;\n    coinWallet: PublicKey;\n  };\n  pcWallet: PublicKey;\n  authority: PublicKey;\n  dexProgram: PublicKey;\n  tokenProgram: PublicKey;\n  rent: PublicKey;\n}\n\nexport enum SwapInstructionByte {\n  BasicSwap = 0,\n}\n","import { BN, Instruction } from \"@project-serum/anchor\";\nimport { Provider, Wallet } from \"../../../../../../anchor/ts\";\nimport { transfer } from \"@project-serum/serum/lib/token-instructions\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport {\n  Account,\n  Connection,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { Action } from \"../interfaces\";\nimport { createTokenAccount, SendTxRequest } from \"@project-serum/common\";\n\nexport const tryCreateAssociatedAccountInst = async (\n  mint: PublicKey,\n  owner: PublicKey,\n  connection: Connection,\n  payer: PublicKey\n): Promise<{\n  associateTokAccount: PublicKey;\n  instr?: TransactionInstruction;\n}> => {\n  const associated = (\n    await PublicKey.findProgramAddress(\n      [\n        owner.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(mint).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n  const data = await connection.getAccountInfo(associated);\n  if (!data) {\n    const inst = Token.createAssociatedTokenAccountInstruction(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      new PublicKey(mint),\n      associated,\n      owner,\n      payer\n    );\n    return {\n      instr: inst,\n      associateTokAccount: associated,\n    };\n  } else {\n    return {\n      associateTokAccount: associated,\n    };\n  }\n};\n\nexport const tryCreateAssociatedAccount = async (\n  mint: PublicKey,\n  owner: PublicKey,\n  provider: Provider\n) => {\n  const { associateTokAccount, instr } = await tryCreateAssociatedAccountInst(\n    mint,\n    owner,\n    provider.connection,\n    provider.wallet.publicKey\n  );\n  if (!instr) return associateTokAccount;\n  const tx = new Transaction();\n  tx.add(instr);\n  await provider.send(tx);\n  return associateTokAccount;\n};\n\nexport interface AccountByMint {\n  [mint: string]: { publicKey: PublicKey };\n}\n\nexport const transferToTx = async (\n  source: PublicKey,\n  destination: PublicKey,\n  amount: BN,\n  authority: Signer | Wallet\n): Promise<SendTxRequest> => {\n  const signer = (authority as Signer).secretKey ? [authority as Account] : [];\n  const inst = transfer({\n    source,\n    destination,\n    amount,\n    owner: authority.publicKey,\n  });\n  const tx = new Transaction();\n  tx.add(inst);\n  return { tx, signers: signer };\n};\n\nexport type PreferredTokenAccounts = { [mint: string]: PublicKey };\n\n/**\n * Get the token account which the malloc sdk will use for a mint\n *\n * @param preferredTokenAccounts - a map of mints to token accounts which the caller would prefer to use per mint. If the account does not exist,\n * and is needed it will be created in the the returned txs\n */\nexport const getTokenAccountUsedByMalloc = async (\n  tokenAuthority: PublicKey,\n  mintAccount: PublicKey,\n  preferredTokenAccounts?: PreferredTokenAccounts\n): Promise<PublicKey> => {\n  if (\n    preferredTokenAccounts &&\n    preferredTokenAccounts[mintAccount.toBase58()]\n  ) {\n    return preferredTokenAccounts[mintAccount.toBase58()];\n  }\n  return await findAssociatedTokenAddress(tokenAuthority, mintAccount);\n};\n\n/**\n * Takes in a mapping of mints to token accounts. If a token account has yet to exist, one will be made\n * which is associated to the authority's address\n *\n * @param preferredTokenAccounts - a map of mints to token accounts which the caller would prefer to use per mint. If the account does not exist,\n * and is needed it will be created in the the returned txs\n */\nexport const createTokenAccountsForActions = async (\n  provider: Provider,\n  tokenAuthority: Signer | Wallet,\n  actions: Action[],\n  fundingAccount: Signer | Wallet,\n  preferredTokenAccounts?: PreferredTokenAccounts\n): Promise<{ accounts: AccountByMint; txs: SendTxRequest[] }> => {\n  const mints = getMintsNoDuplicates(\n    actions\n      .map((a) => {\n        const mints = [];\n        if (a.tokenCreationOptions?.skipOutTokenCreations || false) {\n          const skipIdxs = a.tokenCreationOptions.skipOutTokenCreations;\n          console.log(skipIdxs);\n          // Skip all the mints which are included by the skipIdxs\n          a.tokenMintOuts.forEach((mint, i) => {\n            if (!skipIdxs.includes(i)) mints.push(mint);\n          });\n        } else {\n          mints.push(...a.tokenMintOuts);\n        }\n        if (a.tokenCreationOptions?.skipInTokenCreation === true) {\n        } else {\n          mints.push(a.tokenMintIn);\n        }\n        return mints;\n      })\n      .flat()\n  );\n  console.log(mints);\n\n  let accounts: AccountByMint = {};\n  for (let i = 0; i < mints.length; i++) {\n    const mint = mints[i];\n    if ((preferredTokenAccounts || {})[mint])\n      accounts[mint] = { publicKey: preferredTokenAccounts[mint] };\n    // create the token account if not provided\n    else {\n      const pk = await findAssociatedTokenAddress(\n        tokenAuthority.publicKey,\n        mint\n      );\n      accounts[mint] = {\n        publicKey: pk, // TODO: check that this account does not yet exist\n      };\n    }\n  }\n\n  const createTokTx = await Promise.all(\n    mints.map(async (mint) => {\n      const associatedToSignerAccount = accounts[mint].publicKey;\n      const accountExists = await provider.connection.getAccountInfo(\n        associatedToSignerAccount\n      );\n\n      // Return if the account already exists\n      if (accountExists) {\n        console.log(\"ALREADY EXISTS\");\n        return null;\n      }\n      const insts = Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        new PublicKey(mint),\n        accounts[mint].publicKey,\n        tokenAuthority.publicKey,\n        fundingAccount.publicKey\n      );\n      const tx = new Transaction();\n      tx.add(insts);\n      const signers: Account[] = (fundingAccount as Signer).secretKey\n        ? [fundingAccount as Account]\n        : [];\n      return {\n        tx,\n        signers: signers,\n      };\n    })\n  );\n\n  return { accounts: accounts, txs: createTokTx.filter((i) => !!i) };\n};\n\n// TODO: if there are 2 token accounts of the same type, one of them not being made, then there will be an error out\n\n// See https://spl.solana.com/associated-token-account\nconst findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        walletAddress.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(tokenMintAddress).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getMintsNoDuplicates = (mints: PublicKey[]) => [\n  ...new Set(mints.map(pkToStr)),\n];\n\nconst pkToStr = (pk: PublicKey) => pk.toBase58();\nconst pkFromStr = (pk: string) => new PublicKey(pk);\n\nexport const toReadableNumber = (number: u64, decimals: number): string => {\n  function trimTrailingZeroes(value: string): string {\n    return value.replace(/\\.?0*$/, \"\");\n  }\n  function formatWithCommas(value: string): string {\n    const pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(value)) {\n      value = value.replace(pattern, \"$1,$2\");\n    }\n    return value;\n  }\n\n  const balance = number.toString();\n  const wholeStr = balance.substring(0, balance.length - decimals) || \"0\";\n  // TODO: correct?\n  const fractionStr = balance\n    .substring(balance.length - decimals)\n    .padStart(decimals, \"0\")\n    .substring(0, decimals);\n\n  return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);\n};\n\nexport const fromReadableNumber = (\n  number: number,\n  decimals: number\n): string => {\n  function trimLeadingZeroes(value: string): string {\n    value = value.replace(/^0+/, \"\");\n    if (value === \"\") {\n      return \"0\";\n    }\n    return value;\n  }\n\n  const split = number.toString().split(\".\");\n  const wholePart = split[0];\n  const fracPart = split[1] || \"\";\n  if (split.length > 2 || fracPart.length > decimals) {\n    throw new Error(`Cannot parse '${number}' as token amount`);\n  }\n  return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, \"0\"));\n};\n","export const CONSTRUCTION_ACCOUNT_SIZE = 2e4; // Around 3 kilobytes\nconst ONE_HOUR_MS = 1000 * 60 * 60;\nconst HOURS_PER_EPOCH = 48;\nexport const LIVE_N_EPOCHS = 3;\nexport const LIFETIME_RESULT_ACCOUNT_MS = ONE_HOUR_MS * (HOURS_PER_EPOCH * LIVE_N_EPOCHS); // Has to be more than 1 epoch, lets be sage\nexport const LIFETIME_CONSTRUCTION_ACCOUNT_MS =\n  ONE_HOUR_MS * (HOURS_PER_EPOCH * LIVE_N_EPOCHS);\n\n// Rent constants from https://docs.solana.com/developing/programming-model/accounts\n// TODO: should this be from a dynamic value?\nexport const LAMPORTS_PER_EPOCH = 19.055;\nexport const MS_PER_EPOCH = ONE_HOUR_MS * HOURS_PER_EPOCH;\n","// TODO: there is probably a faster way to do this\nexport const deepCloneObject = (obj: any): any => {\n  function clone(obj) {\n    if (obj == null || typeof obj != \"object\") return obj;\n\n    var temp = obj.constructor();\n\n    for (var key in obj) temp[key] = clone(obj[key]);\n    return temp;\n  }\n  return clone(obj);\n};\n","import * as anchor from \"@project-serum/anchor\";\nimport { MallocSdk } from \"@malloc/sdk\";\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { getConstants } from \"../config/constants\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  commitment: anchor.web3.Commitment = \"recent\",\n  queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result: any, context: any) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n};\n\n/* export */ const createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getTokenWallet = async (\n  wallet: anchor.web3.PublicKey,\n  mint: anchor.web3.PublicKey\n) => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const getMallocSdk = (wallet: anchor.Provider): MallocSdk => {\n  return new MallocSdk(\n    new PublicKey(getConstants().MALLOC_PROGRAM_ID || \"\"),\n    wallet\n  );\n};\n","import {\n  Account,\n  Connection,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { MintInfo, TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport {\n  ActionLib,\n  AccountsArray,\n  Action,\n  ActionMetadata,\n  BuildIsolatedActionFn,\n  BuildIsolatedActionFnOpts,\n  utils,\n} from \"@malloc/sdk\";\nimport { BN, Provider, web3 } from \"@project-serum/anchor\";\nimport { TokenInfo, TokenListContainer } from \"@solana/spl-token-registry\";\nimport {\n  connection,\n  createMintInstructions,\n  createTokenAccountInstrs,\n  parseMintAccount,\n  SendTxRequest,\n} from \"@project-serum/common\";\n\nconst actionTypeUID = \"MALLOC_SPL_MINT\";\n\ntype BuildIsolatedMintArgs = {\n  authority?: string;\n  decimals: string;\n  amountOut: string;\n};\n\nexport const buildIsolatedMintAction: BuildIsolatedActionFn<BuildIsolatedMintArgs> =\n  async (\n    inp: BuildIsolatedMintArgs,\n    inMint: string,\n    inTokenAccount: string,\n    dummyPassThroughActionPID: string,\n    provider: Provider,\n    opts?: BuildIsolatedActionFnOpts<BuildIsolatedMintArgs>\n  ) => {\n    const decimals = parseInt(inp.decimals);\n    const mint = new Keypair();\n    const amountOutExpanded = utils.tokens.fromReadableNumber(\n      parseFloat(inp.amountOut),\n      decimals\n    );\n\n    const outTokenAccount = await utils.tokens.getTokenAccountUsedByMalloc(\n      provider.wallet.publicKey,\n      mint.publicKey,\n      opts?.preferredTokenAccounts\n    );\n\n    const authority = new PublicKey(inp.authority || provider.wallet.publicKey);\n\n    return {\n      isolatedAction: {\n        addDefaultTokAccounts: false,\n        actionData: serializeData(amountOutExpanded.toString()),\n        tokenAccountOuts: [outTokenAccount],\n        actionAccounts: [],\n        actionProgram: new PublicKey(dummyPassThroughActionPID),\n        tokenMintIn: new PublicKey(inMint),\n        tokenMintOuts: [mint.publicKey],\n        additionalSigners: [mint],\n        tokenCreationOptions: {\n          skipOutTokenCreations: [0],\n        },\n        instructions: [\n          ...(await createMintInstructions(\n            provider,\n            authority,\n            mint.publicKey,\n            decimals\n          )),\n        ],\n      },\n    };\n  };\n\nconst serializeData = (amount: string) => Buffer.from(`[${amount}]`);\n\n/**\n * The file's main export\n */\nexport const MintAction: ActionLib<BuildIsolatedMintArgs> = {\n  buildIsolatedAction: buildIsolatedMintAction,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\nexport default MintAction;\n","import { ActionLib, BNIsh, BuildIsolatedActionFn, utils } from \"@malloc/sdk\";\nimport { serialize as borshSer } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport {\n  Account,\n  Ed25519Program,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n} from \"@solana/web3.js\";\nimport { Provider } from \"../../../../anchor/ts/src\";\nimport { SendTxRequest } from \"../../../../anchor/ts/src/provider\";\nimport { createMintInstructions } from \"@project-serum/common\";\n\n// TODO: optionality to not just create a new mint\n/**\n * @param authoritySecret - a hex encoded secret key\n * @param createMint.amount - the amount to mint to, this will be packed into the data and will overwrite amount_in. This is in human readable format\n */\ntype BuildMintToArgs = {\n  authoritySecret?: string;\n  // createMint?: {\n  // TODO: add back in the above once the frontend can give in a struct\n  decimals: number;\n  createMintSecretKey?: string; // The secret key of the mint in hex\n  initialSupply: string;\n  // };\n};\n\nconst actionTypeUID = \"MALLOC_SPL_MINT_TO\";\n\nclass ActionData extends utils.serde.Assignable {}\n\nconst schema = new Map([\n  [\n    ActionData,\n    {\n      kind: \"struct\",\n      fields: [[\"amount_override\", { kind: \"option\", type: \"u64\" }]],\n    },\n  ],\n]);\n\nexport const _mintToSerializeData = (amount?: BNIsh): Buffer => {\n  return Buffer.from(\n    borshSer(schema, new ActionData({ amount_override: new u64(amount) }))\n  );\n};\n\nconst buildIsolatedMintTo: BuildIsolatedActionFn<BuildMintToArgs> = async (\n  inp: BuildMintToArgs,\n  inputMint: string,\n  inputTokenAccount: string,\n  mintToPID,\n  provider: Provider\n) => {\n  // TODO: note the below is untested and will remain so till the hackathon is over\n  const authoritySigner = inp.authoritySecret\n    ? Keypair.fromSecretKey(\n        new Uint8Array(Buffer.from(inp.authoritySecret, \"hex\"))\n      )\n    : undefined;\n\n  // If the user is creating a new mint, then use the new mint address, otherwise use the input mint\n  const mint = inp.createMintSecretKey\n    ? Keypair.fromSecretKey(\n        new Uint8Array(Buffer.from(inp.createMintSecretKey, \"hex\"))\n      )\n    : new Keypair();\n\n  // If their is not specified recipient, mint to the caller\n  const associateTokAccountRecipient =\n    await utils.tokens.getTokenAccountUsedByMalloc(\n      provider.wallet.publicKey,\n      mint.publicKey\n    );\n\n  const optionalAmountWholeNumber = utils.tokens.fromReadableNumber(\n    parseFloat(inp.initialSupply),\n    inp.decimals\n  );\n\n  const atStartTxs: SendTxRequest[] = [];\n\n  const authority = new PublicKey(provider.wallet.publicKey);\n  const tx = new Transaction();\n  tx.add(\n    ...(await createMintInstructions(\n      provider,\n      authority,\n      mint.publicKey,\n      inp.decimals\n    ))\n  );\n  atStartTxs.push({\n    tx,\n    signers: [mint],\n  });\n\n  return {\n    isolatedAction: {\n      tokenMintIn: new PublicKey(inputMint),\n      actionData: _mintToSerializeData(optionalAmountWholeNumber),\n      actionProgram: new PublicKey(mintToPID),\n      actionAccounts: [\n        {\n          address: mint.publicKey,\n          isWriteable: true,\n        },\n        {\n          address: associateTokAccountRecipient,\n          isWriteable: true,\n        },\n        {\n          address: authoritySigner?.publicKey || provider.wallet.publicKey,\n          isSigner: true,\n        },\n        {\n          address: TOKEN_PROGRAM_ID,\n        },\n      ],\n      additionalSigners: authoritySigner ? [authoritySigner] : [],\n      tokenMintOuts: [mint.publicKey],\n      tokenAccountOuts: [associateTokAccountRecipient],\n      atStartOfPrepareTxs: atStartTxs,\n      // TODO: once JIT token creation is added, move creating the mint to an instruction and change the token creation to\n      // be right here!\n      // tokenCreationOptions: {\n      //   skipInTokenCreation: true,\n      // },\n    },\n  };\n};\n\nexport const MintAndMintToAction: ActionLib<BuildMintToArgs> = {\n  buildIsolatedAction: buildIsolatedMintTo,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\n","import { ActionLib, BuildIsolatedActionFn, utils } from \"@malloc/sdk\";\nimport {\n  PublicKey,\n  SYSVAR_CLOCK_PUBKEY,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { Provider } from \"../../../../anchor/ts/src\";\nimport * as solend from \"@solendprotocol/common\";\nimport {\n  getTokenAccountUsedByMalloc,\n  PreferredTokenAccounts,\n} from \"../../../malloc-core/ts-packages/malloc-sdk/lib/utils/tokens\";\nimport {\n  depositReserveLiquidityInstruction,\n  refreshReserveInstruction,\n} from \"@solana/spl-token-lending\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { isWeakMap } from \"util/types\";\n\ntype BuildSolendArgs = {};\n\nconst actionTypeUID = \"MALLOC_SPL_SOLEND\";\n\n// TODO: this only supports devnet right now\nconst buildIsolatedSolend: BuildIsolatedActionFn<BuildSolendArgs> = async (\n  inp: BuildSolendArgs,\n  mintAccount: string,\n  inputTokenAccount: string,\n  solendActionPID,\n  provider: Provider,\n  preferredTokenAccounts?: PreferredTokenAccounts\n) => {\n  const mintIn = new PublicKey(mintAccount);\n  const tokenAccountIn = new PublicKey(inputTokenAccount);\n\n  const solendConfig = solend.devnetConfig;\n  const assetSymbol = solendConfig.assets.find(\n    (asset) => asset.mintAddress === mintAccount\n  )?.symbol;\n  if (!assetSymbol) {\n    throw `Looks like solend does not support token of mint ${mintAccount}`;\n  }\n\n  const mainMarket = solendConfig.markets[0];\n  const reserve = mainMarket.reserves.find((r) => r.asset === assetSymbol);\n\n  if (!reserve) {\n    throw `Looks like Solend does not have a market for ${assetSymbol}`;\n  }\n\n  const collateralMint = new PublicKey(reserve.collateralMintAddress);\n  const destinationCollateralAccount = await getTokenAccountUsedByMalloc(\n    provider.wallet.publicKey,\n    collateralMint,\n    preferredTokenAccounts\n  );\n\n  // Set the amount to 0, this will later get filled in/ replaced by the contract\n  // const instr = depositReserveLiquidityInstruction(\n  //   0,\n  //   tokenAccountIn,\n  //   destinationCollateralAccount,\n  //   new PublicKey(reserve.address),\n  //   new PublicKey(reserve.liquidityAddress),\n  //   collateralMint,\n  //   new PublicKey(reserve.address),\n  //   new PublicKey(mainMarket.authorityAddress),\n  //   provider.wallet.publicKey\n  // );\n  // const outCollateralTokenAccount = await getTokenAccountUsedByMalloc()\n  const oracle = solendConfig.oracles.assets.find(\n    (o) => o.asset === assetSymbol\n  );\n  if (!oracle) throw `Could not find the oracle for ${assetSymbol}`;\n  const { data: refreshData } = refreshReserveInstruction(\n    new PublicKey(reserve.address),\n    new PublicKey(oracle.priceAddress)\n  );\n  return {\n    isolatedAction: {\n      tokenMintIn: mintIn,\n      actionData: Buffer.from([]),\n      actionProgram: new PublicKey(solendActionPID),\n      actionAccounts: [\n        {\n          address: new PublicKey(solendConfig.programID),\n        },\n        {\n          address: mintIn,\n        },\n        {\n          address: tokenAccountIn,\n          isWriteable: true,\n        },\n        { address: destinationCollateralAccount, isWriteable: true },\n        { address: new PublicKey(reserve.address), isWriteable: true },\n        { address: new PublicKey(reserve.liquidityAddress), isWriteable: true },\n        { address: collateralMint, isWriteable: true },\n        { address: new PublicKey(mainMarket.address), isWriteable: false },\n        { address: new PublicKey(mainMarket.authorityAddress) },\n        { address: provider.wallet.publicKey, isSigner: true },\n        { address: SYSVAR_CLOCK_PUBKEY },\n        { address: TOKEN_PROGRAM_ID },\n      ],\n      instructions: [\n        new TransactionInstruction({\n          data: refreshData,\n\n          programId: new PublicKey(solendConfig.programID),\n          keys: [\n            {\n              pubkey: new PublicKey(reserve.address),\n              isWritable: true,\n              isSigner: false,\n            },\n            {\n              pubkey: new PublicKey(oracle.priceAddress),\n              isWritable: false,\n              isSigner: false,\n            },\n            {\n              pubkey: new PublicKey(oracle.switchboardFeedAddress),\n              isWritable: false,\n              isSigner: false,\n            },\n            {\n              pubkey: SYSVAR_CLOCK_PUBKEY,\n              isSigner: false,\n              isWritable: false,\n            },\n          ],\n        }),\n      ],\n      additionalSigners: [],\n      tokenMintOuts: [collateralMint],\n      tokenAccountOuts: [destinationCollateralAccount],\n    },\n  };\n};\n\nexport const SolendAction: ActionLib<BuildSolendArgs> = {\n  buildIsolatedAction: buildIsolatedSolend,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\n","import {\n  Account,\n  Connection,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { MintInfo, TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport { Side, SwapAccounts, SwapInstructionByte } from \"./swap-interfaces\";\nimport {\n  ActionLib,\n  AccountsArray,\n  Action,\n  ActionMetadata,\n  BuildIsolatedActionFn,\n  BuildIsolatedActionFnOpts,\n  utils,\n} from \"@malloc/sdk\";\nimport { BN, Provider, web3 } from \"@project-serum/anchor\";\nimport { TokenInfo, TokenListContainer } from \"@solana/spl-token-registry\";\nimport { Market, OpenOrders, TokenInstructions } from \"@project-serum/serum\";\nimport {\n  connection,\n  parseMintAccount,\n  SendTxRequest,\n} from \"@project-serum/common\";\nimport { Swap } from \"@project-serum/swap\";\n\nexport * from \"./swap-interfaces\";\n\nconst actionTypeUID = \"MALLOC_SPL_SWAP\";\n\ninterface SwapInput {\n  // outTokenAccount: string; //TODO: hmmm...\n  outMint: string;\n  serumDexProgramId: string;\n  rent: string;\n  openOrdersAccount?: string;\n}\n\ntype BuildIsolatedSwapArgs = SwapInput & {\n  minOut: string;\n};\nexport const buildIsolatedSwapAction: BuildIsolatedActionFn<BuildIsolatedSwapArgs> =\n  async (\n    inp: BuildIsolatedSwapArgs,\n    inMint: string,\n    inTokenAccount: string,\n    swapPID: string,\n    provider: Provider,\n    opts?: BuildIsolatedActionFnOpts<BuildIsolatedSwapArgs>\n  ) => {\n    const outTokenAccount = await utils.tokens.getTokenAccountUsedByMalloc(\n      provider.wallet.publicKey,\n      new PublicKey(inp.outMint),\n      opts?.preferredTokenAccounts\n    );\n    const swapInfo = await buildSwapAccounts(\n      inp,\n      inMint,\n      inTokenAccount,\n      outTokenAccount.toBase58(),\n      provider\n    );\n\n    return {\n      isolatedAction: {\n        addDefaultTokAccounts: false,\n        actionData: packSwapData(\n          SwapInstructionByte.BasicSwap,\n          swapInfo.side,\n          new u64(inp.minOut)\n        ),\n        tokenAccountOuts: [outTokenAccount],\n        actionAccounts: swapAccountsToActionAccounts(\n          swapInfo.swapAccounts,\n          swapInfo.side\n        ),\n        actionProgram: new PublicKey(swapPID),\n        tokenMintIn: new PublicKey(inMint),\n        tokenMintOuts: [new PublicKey(inp.outMint)],\n        preActionTxs: swapInfo.openOrderInitTx\n          ? [swapInfo.openOrderInitTx]\n          : [],\n      },\n    };\n  };\n\nexport const buildSwapAccounts = async (\n  inp: SwapInput,\n  inMint: string,\n  inTokenAccount: string,\n  outTokenAccount: string,\n  provider: Provider\n): Promise<{\n  swapAccounts: SwapAccounts;\n  openOrderInitTx?: SendTxRequest;\n  market: Market;\n  side: Side;\n}> => {\n  const serumDexId = new PublicKey(inp.serumDexProgramId);\n  const marketRet = await getMarket(\n    provider.connection,\n    new PublicKey(inMint),\n    new PublicKey(inp.outMint),\n    serumDexId\n  );\n  if (!marketRet) throw \"No markets found\";\n\n  const { side, pk: marketPk } = marketRet;\n  const marketSel = await Market.load(\n    provider.connection,\n    marketPk,\n    {},\n    serumDexId\n  );\n\n  const openOrderAccountData = await getOpenOrdersAccount(\n    provider.connection,\n    marketSel,\n    provider.wallet.publicKey,\n    new PublicKey(inp.serumDexProgramId)\n  );\n\n  const [vaultSigner, _] = await getVaultOwnerAndNonce(\n    marketSel.decoded.ownAddress,\n    new PublicKey(inp.serumDexProgramId)\n  );\n\n  const coinWallet = side === Side.Bid ? outTokenAccount : inTokenAccount;\n  const pcWallet = side === Side.Bid ? inTokenAccount : outTokenAccount;\n\n  return {\n    market: marketSel,\n    swapAccounts: {\n      market: {\n        market: marketSel.decoded.ownAddress,\n        requestQueue: marketSel.decoded.requestQueue,\n        eventQueue: marketSel.decoded.eventQueue,\n        bids: marketSel.decoded.bids,\n        asks: marketSel.decoded.asks,\n        coinVault: marketSel.decoded.baseVault,\n        pcVault: marketSel.decoded.quoteVault,\n        vaultSigner: vaultSigner,\n        // User params.\n        openOrders: new PublicKey(\n          inp.openOrdersAccount || openOrderAccountData.openOrderPk\n        ),\n        orderPayerTokenAccount: new PublicKey(inTokenAccount),\n        coinWallet: new PublicKey(coinWallet),\n      },\n      pcWallet: new PublicKey(pcWallet),\n      authority: provider.wallet.publicKey,\n      dexProgram: new PublicKey(inp.serumDexProgramId),\n      tokenProgram: new PublicKey(TOKEN_PROGRAM_ID),\n      rent: new PublicKey(inp.rent),\n    },\n\n    openOrderInitTx: inp.openOrdersAccount\n      ? undefined\n      : openOrderAccountData.openOrderTx,\n    side,\n  };\n};\n\n/**\n * get the open order accounts associated with the market and owner\n *\n * If none exist, create a new account and return a tx to create/ init the account as well\n */\nconst getOpenOrdersAccount = async (\n  connection: Connection,\n  market: Market,\n  owner: PublicKey,\n  dexPID: PublicKey\n): Promise<{\n  openOrderPk: PublicKey;\n  openOrderTx?: SendTxRequest;\n}> => {\n  const openOrders = await OpenOrders.findForMarketAndOwner(\n    connection,\n    market.address,\n    owner,\n    dexPID\n  );\n  if (openOrders.length === 0) {\n    const openOrderAccount = new Account(new Keypair().secretKey);\n    const openOrdersTx = new Transaction();\n    openOrdersTx.add(\n      await OpenOrders.makeCreateAccountTransaction(\n        connection,\n        market.decoded.ownAddress,\n        owner,\n        openOrderAccount.publicKey,\n        dexPID\n      )\n    );\n\n    return {\n      openOrderPk: openOrderAccount.publicKey,\n      openOrderTx: {\n        tx: openOrdersTx,\n        signers: [openOrderAccount],\n      },\n    };\n  } else {\n    return {\n      openOrderPk: openOrders[0].publicKey,\n    };\n  }\n};\n\n// TODO: this just takes the first market available... have some sorta best market in the future?\n/**\n * base mint is the in mint\n * quote mint is the out mint\n */\nexport const getMarket = async (\n  connection: Connection,\n  inMint: PublicKey,\n  outMint: PublicKey,\n  serumDexProgramId: PublicKey\n) => {\n  // TODO: slightly confused about side\n  let side = Side.Ask;\n  let marketPks = await getMarketsFromBaseMinttoQuoteMint(\n    connection,\n    inMint,\n    outMint,\n    serumDexProgramId\n  );\n\n  // Try the other market side\n  if (!marketPks || marketPks.length === 0) {\n    marketPks = await getMarketsFromBaseMinttoQuoteMint(\n      connection,\n      outMint,\n      inMint,\n      serumDexProgramId\n    );\n    side = Side.Bid;\n  }\n  if (!marketPks || marketPks.length === 0) return null;\n  return { pk: marketPks[0], side };\n};\n\nexport const packSwapData = (\n  instrByte: SwapInstructionByte,\n  side: Side,\n  minOut: u64\n): Buffer => {\n  const packedMinOut = minOut.toArrayLike(Buffer, \"be\", 8);\n  const initPart = Buffer.from(new Uint8Array([instrByte, side]));\n  return Buffer.concat([initPart, packedMinOut]);\n};\n\nexport const swapAccountsToActionAccounts = (\n  swapAccounts: SwapAccounts,\n  side: Side,\n  referralAccount?: PublicKey\n): AccountsArray => {\n  const tokenAccount =\n    side === Side.Bid ? swapAccounts.pcWallet : swapAccounts.market.coinWallet;\n  const outAccount =\n    side === Side.Bid ? swapAccounts.market.coinWallet : swapAccounts.pcWallet;\n  const accounts = [\n    {\n      isWriteable: true,\n      address: tokenAccount,\n    },\n    {\n      address: swapAccounts.tokenProgram,\n    },\n    {\n      address: swapAccounts.authority,\n      isSigner: true,\n    },\n    {\n      address: swapAccounts.rent,\n    },\n    {\n      address: swapAccounts.dexProgram,\n    },\n    {\n      address: outAccount,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.market,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.openOrders,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.requestQueue,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.eventQueue,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.bids,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.asks,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.orderPayerTokenAccount,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.coinVault,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.pcVault,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.vaultSigner,\n    },\n  ];\n  if (referralAccount) {\n    accounts.push({\n      address: referralAccount,\n      isWriteable: true,\n    });\n  }\n  return accounts;\n};\n\nexport async function getVaultOwnerAndNonce(\n  marketPublicKey: PublicKey,\n  dexProgramId: PublicKey\n): Promise<[PublicKey, BN]> {\n  const nonce = new BN(0);\n  while (nonce.toNumber() < 255) {\n    try {\n      const vaultOwner = await PublicKey.createProgramAddress(\n        [marketPublicKey.toBuffer(), nonce.toArrayLike(Buffer, \"le\", 8)],\n        dexProgramId\n      );\n      return [vaultOwner, nonce];\n    } catch (e) {\n      nonce.iaddn(1);\n    }\n  }\n  throw new Error(\"Unable to find nonce\");\n}\n\nconst getMarketsFromBaseMinttoQuoteMint = async (\n  connection: Connection,\n  baseMint: PublicKey,\n  quoteMint: PublicKey,\n  serumProgId: PublicKey\n): Promise<PublicKey[]> => {\n  const layout = await Market.getLayout(serumProgId);\n\n  return (\n    await Market.findAccountsByMints(\n      connection,\n      baseMint,\n      quoteMint,\n      serumProgId\n    )\n  ).map((e) => e.publicKey);\n};\n\nconst getAllMarkets = async (conn: Connection, progId: PublicKey) => {\n  Market.findAccountsByMints;\n};\n\nexport const getDemoTokenInfo = async (\n  provider: Provider,\n  fakeUsdc: PublicKey | string,\n  fakeTokA: PublicKey | string\n): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(fakeUsdc);\n  const aMint = new PublicKey(fakeTokA);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: new PublicKey(fakeUsdc).toBase58(),\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE: A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: new PublicKey(fakeTokA).toBase58(),\n    },\n  ];\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n\n/**\n * The file's main export\n */\nexport const SwapAction: ActionLib<BuildIsolatedSwapArgs> = {\n  buildIsolatedAction: buildIsolatedSwapAction,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\nexport default SwapAction;\n","import { ActionLib, BuildIsolatedActionFn, utils } from \"@malloc/sdk\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Provider } from \"../../../../anchor/ts/src\";\n\ntype BuildTransferArgs = {\n  recipientWallet: string;\n};\n\nconst actionTypeUID = \"MALLOC_SPL_TRANSFER\";\n\nconst buildIsolatedTransfer: BuildIsolatedActionFn<BuildTransferArgs> = async (\n  inp: BuildTransferArgs,\n  mintAccount: string,\n  inputTokenAccount: string,\n  transferPID,\n  provider: Provider\n) => {\n  const mintIn = new PublicKey(mintAccount);\n  const recipient = new PublicKey(inp.recipientWallet);\n  const { associateTokAccount, instr: createTokInstr } =\n    await utils.tokens.tryCreateAssociatedAccountInst(\n      mintIn,\n      recipient,\n      provider.connection,\n      provider.wallet.publicKey\n    );\n\n  return {\n    isolatedAction: {\n      addDefaultTokAccounts: true,\n      tokenMintIn: mintIn,\n      actionData: Buffer.from([]),\n      actionProgram: new PublicKey(transferPID),\n      actionAccounts: [\n        {\n          address: associateTokAccount,\n          isWriteable: true,\n        },\n      ],\n      additionalSigners: [],\n      tokenMintOuts: [],\n      tokenAccountOuts: [],\n      // TODO: the following is a bit ghetto, but basically will ensure that the token account is only created if the recipient\n      // is not the caller. This ensures that the token account is not created again because its probably created by a former action/ token analyzer\n      instructions:\n        createTokInstr && !recipient.equals(provider.wallet.publicKey) // TODO: think of a better way to do this with tokens\n          ? [createTokInstr]\n          : undefined,\n    },\n  };\n};\n\nexport const TransferAction: ActionLib<BuildTransferArgs> = {\n  buildIsolatedAction: buildIsolatedTransfer,\n  actionTypeUID,\n  expectedNumberOfOutMints: 0,\n};\n","import { ActionMetadata } from \"./interfaces\";\n\n// TODO: there is a lot of cool stuff to do here\n\ntype ToHitArg = { called: number[] };\n\nexport const buildSeqListOfActionCalls = (\n  actionMetas: ActionMetadata[],\n  initIndices: number[]\n): number[] => {\n  const initHitCounts = [...Array(actionMetas.length)].fill(0);\n  const called = simulateDAG(\n    actionMetas.map((a, i) => {\n      return { ...a, id: i };\n    }),\n    initHitCounts,\n    initIndices\n  );\n\n  return called;\n};\n\n// Returns an ordered list of indices hit\nconst simulateDAG = (\n  actionMetas: (ActionMetadata & { id: number })[],\n  hitCounts: number[],\n  toHit: number[]\n): number[] => {\n  if (toHit.length === 0) return [];\n  const newHitCounts = hitCounts.map((e, i) => getOccurrence(toHit, i) + e)\n  const newRipeActions = actionMetas.filter(\n    (a) => a.ripeAmount === newHitCounts[a.id] && toHit.includes(a.id)\n  );\n  const newToHit = newRipeActions\n    .map((a) => a.nextNodes.map((o) => o.map((i) => i.actionIdx)))\n    .flat()\n    .flat();\n  return [\n    ...newRipeActions.map((a) => a.id),\n    ...simulateDAG(actionMetas, newHitCounts, newToHit),\n  ];\n};\n\nconst getOccurrence = <T>(array: T[], value: T) =>\n  array.filter((v) => v === value).length;\n","import { u64 } from \"@solana/spl-token\";\nimport { LAMPORTS_PER_EPOCH, MS_PER_EPOCH } from \"./constants\";\n\nexport const calculateRent = (size: number, durationMs: number): number => {\n  const rentCost = Math.ceil(LAMPORTS_PER_EPOCH * size * (durationMs / MS_PER_EPOCH));\n\treturn rentCost\n};\n","import MALLOC_IDL from \"./idls/malloc.json\";\nimport * as BufferLayout from \"buffer-layout\";\nimport ACTION_TEMPLATE_IDL from \"./idls/action_template.json\";\nimport { BN, Program, Provider, Wallet, web3 } from \"@project-serum/anchor\";\n// import { BN, Program, Provider, web3 } from \"../../../../../anchor/ts\";\nimport { SendTxRequest } from \"@project-serum/anchor/dist/provider\";\nimport { TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport {\n  Signer,\n  Transaction,\n  PublicKey,\n  Keypair,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n  SystemProgram,\n} from \"@solana/web3.js\";\nimport {\n  CONSTRUCTION_ACCOUNT_SIZE,\n  LIFETIME_CONSTRUCTION_ACCOUNT_MS,\n  LIFETIME_RESULT_ACCOUNT_MS,\n} from \"./constants\";\nimport { buildSeqListOfActionCalls } from \"./graph-utils\";\nimport {\n  ActionCtxFinal,\n  Action,\n  ActionMetadata,\n  BNIsh,\n  AccountsArray,\n  PartialNextActionCtx,\n  ProcessActionNext,\n} from \"./interfaces\";\nimport { calculateRent } from \"./solana-utils\";\nimport {\n  AccountByMint,\n  createTokenAccountsForActions,\n  transferToTx,\n} from \"./utils/tokens\";\n\nexport interface SendRequestsOpts {\n  onPrepareAccountsDone?: (txHashes: string[]) => Promise<any>;\n  prepareCommitment?: web3.ConfirmOptions;\n  actionCommitment?: web3.ConfirmOptions;\n}\n\nexport interface ConstructionData {\n  txsPrepare: SendTxRequest[];\n  txsActionCalls: SendTxRequest[];\n  construction: Signer;\n  resultAccounts: Signer[];\n  tokenAccounts: AccountByMint;\n}\n\n/**\n * @param authority - B58 Encoded public key of the authority\n * @param actions.tokenAccount - B58 Encoded public key of the token account\n */\nexport interface ConstructionStateSerialized {\n  construction: {\n    authority: string;\n    actions: (ActionMetadata & { tokenAccount: string })[];\n    actionCalls: { callAmount: string; numbTimesHit: number }[];\n    readyCallIdxList: number[];\n  };\n}\n\nexport interface BuildEphemeralOpts {\n  preferredTokenAccounts?: {\n    [mint: string]: PublicKey;\n  };\n}\n\nexport type BuildEphemeralTxsInstr = {\n  actions: Action[];\n  initialSplits: number[];\n  initialActionIndices: number[];\n  amount: BNIsh;\n  authority?: Signer;\n  amountInAccount: PublicKey;\n  amountInAuthority?: Signer;\n  opts?: BuildEphemeralOpts;\n};\n\nexport class MallocSdk {\n  private readonly mallocProgram: Program;\n\n  constructor(\n    private readonly MALLOC_PROGRAM_ID: PublicKey,\n    private readonly provider: Provider\n  ) {\n    this.mallocProgram = new Program(\n      MALLOC_IDL as any,\n      MALLOC_PROGRAM_ID,\n      provider\n    );\n    // TODO: make new program with idl\n  }\n\n  // TODO: prepare and run should j be one thing\n  // Then, to deal with fact that token accounts can j be created, token creation tx's should j happen immediately preceding the first action to use that token\n\n  // TODO create token accounts and store there associations\n  // Append on \"withdraw\" functionality and tx to transfer initial into account\n  async buildTxs({\n    actions,\n    initialSplits,\n    initialActionIndices,\n    amount,\n    authority: _authority,\n    amountInAccount,\n    amountInAuthority: _inAuth,\n    opts,\n  }: BuildEphemeralTxsInstr): Promise<ConstructionData> {\n    let amountInAuthority = _inAuth || (this.provider.wallet as Wallet);\n    let authority = _authority || (this.provider.wallet as Wallet);\n\n    const { accounts: tokenAccounts, txs: tokenTxs } =\n      // TODO: disable this and then later have an option to reenable\n      await createTokenAccountsForActions(\n        this.provider,\n        authority,\n        actions,\n        this.provider.wallet as Wallet,\n        opts?.preferredTokenAccounts\n      );\n    const { construction, tx: constructionTx } =\n      await createAndInitConstruction(\n        this.mallocProgram,\n        authority.publicKey,\n        actions.length\n      );\n    const addConstructionActionsTx = addActionsToConstruction(\n      this.mallocProgram,\n      construction.publicKey,\n      actions.map((a) => a.actionMetadata),\n      authority\n    );\n\n    if (!checkMintsAreTheSame(initialActionIndices.map((i) => actions[i]))) {\n      throw \"Expected all initial token types to be the same\";\n    }\n\n    if (initialActionIndices.length === 0)\n      throw \"Expected initial actions to have length more than 0\";\n\n    const initMint = actions[initialActionIndices[0]].tokenMintIn;\n\n    const transferTx = await transferToTx(\n      amountInAccount,\n      tokenAccounts[initMint.toBase58()].publicKey,\n      new BN(amount), // Add 1 to ensure the accounts don't go to 0 // TODO: does this make sense\n      amountInAuthority\n    );\n\n    const prepareConstructionTx = prepareConstruction(\n      this.mallocProgram,\n      construction.publicKey,\n      initialActionIndices,\n      initialSplits,\n      authority,\n      new BN(amount)\n    );\n\n    const hitOrder = buildSeqListOfActionCalls(\n      actions.map((a) => a.actionMetadata),\n      initialActionIndices\n    );\n    if (hitOrder.length !== actions.length)\n      throw \"An error occurred trying to forecast your construction\";\n\n    const initResultAccounts = await Promise.all(\n      actions.map((a) =>\n        initResultAccount(\n          new Program(\n            ACTION_TEMPLATE_IDL as any,\n            a.actionProgram,\n            this.provider\n          ),\n          // Set the number of out amounts to equal the amount of next nodes\n          a.actionMetadata.nextNodes.length\n        )\n      )\n    );\n\n    // The additional accounts added onto action action accounts follow conventional malloc standards for token\n    // TODO: have an option to not pass in the token accounts\n    const actionCtxFilled: PartialNextActionCtx[] = actions.map((action, i) => {\n      const toAdd = action.addDefaultTokAccounts\n        ? [\n            {\n              address: tokenAccounts[action.tokenMintIn.toBase58()].publicKey,\n              isWriteable: true,\n              isSigner: false,\n            },\n            {\n              address: TOKEN_PROGRAM_ID,\n              isWriteable: false,\n              isSigner: false,\n            },\n            {\n              address: authority.publicKey,\n              isSigner: true,\n              isWriteable: false,\n            },\n          ]\n        : [];\n\n      return {\n        ctx: {\n          resultAccount: initResultAccounts[i].resultAccount.publicKey,\n          actionProgram: action.actionProgram,\n        },\n        actionAccounts: [...toAdd, ...action.actionAccounts] as AccountsArray,\n      };\n    });\n\n    const processTxs = hitOrder.map((hitIndex) =>\n      processAction(\n        this.mallocProgram,\n        hitIndex,\n        construction.publicKey,\n        actionCtxFilled[hitIndex],\n        authority,\n        {\n          data: actions[hitIndex].actionData,\n          instructions: actions[hitIndex].instructions,\n          additionalSigners: actions[hitIndex].additionalSigners,\n          preActionTxs: actions[hitIndex].preActionTxs,\n        }\n      )\n    );\n\n    const atStartOfPrepareTxs = getAllAtStartOfPrepareTxs(actions);\n    // TODO: optional withdraw to accounts\n\n    const txsPrepare = [\n      ...atStartOfPrepareTxs,\n      ...tokenTxs,\n      transferTx,\n      constructionTx,\n      addConstructionActionsTx,\n      prepareConstructionTx,\n      ...initResultAccounts.map((i) => i.tx),\n    ];\n    const txsActionsCalls = [...processTxs.flat()];\n\n    return {\n      construction,\n      txsPrepare: txsPrepare,\n      txsActionCalls: txsActionsCalls,\n      tokenAccounts,\n      resultAccounts: initResultAccounts.map((a) => a.resultAccount),\n    };\n  }\n\n  async getConstructionState(\n    data: ConstructionData\n  ): Promise<ConstructionStateSerialized> {\n    const constructionState: any =\n      (await this.mallocProgram.account.construction.fetch(\n        data.construction.publicKey\n      )) as any;\n    const actionSerialize = (a: any) => {\n      return {\n        tokenAccount: new PublicKey(a.tokenAccount).toBase58(),\n        ripeAmount: a.ripeAmount,\n        nextNodes: a.nextNodes.map((o) =>\n          o.map((nextNode) => {\n            return {\n              actionIdx: nextNode.actionIdx,\n              fraction: new BN(nextNode.fraction).toString(),\n            };\n          })\n        ),\n      };\n    };\n    const actionCallSerialize = (a: any) => {\n      return {\n        numbTimesHit: a.numbTimesHit,\n        callAmount: new BN(a.callAmount).toString(),\n      };\n    };\n    return {\n      construction: {\n        authority: new PublicKey(constructionState.authority).toBase58(),\n        actions: constructionState.actions.map(actionSerialize),\n        actionCalls: constructionState.actionCalls.map(actionCallSerialize),\n        readyCallIdxList: constructionState.readyCallIdxList,\n      },\n    };\n  }\n\n  // TODO:!\n  async deleteEphemeralAccounts(constructionData: ConstructionData) {\n    const withdrawAllRentInstr = (account: Signer) => {};\n    constructionData.construction;\n  }\n\n  async sendRequests(\n    data: ConstructionData,\n    options?: SendRequestsOpts\n  ): Promise<string[]> {\n    await this.provider;\n    const txHashesPrepare =\n      data.txsPrepare.length > 0\n        ? await this.provider.sendAll(data.txsPrepare, {\n            // skipPreflight: true,\n            ...(options?.prepareCommitment || {}),\n          })\n        : [];\n    if (options?.onPrepareAccountsDone && txHashesPrepare.length > 0)\n      await options.onPrepareAccountsDone(txHashesPrepare);\n    const txHashes = await this.provider.sendAll(data.txsActionCalls, {\n      // skipPreflight: true,\n      ...(options?.actionCommitment || {}),\n    });\n    return [...txHashesPrepare, ...txHashes];\n  }\n}\n\nconst createAndInitConstruction = async (\n  program: Program,\n  authority: PublicKey,\n  numbActions: number\n): Promise<{ construction: Signer; tx: SendTxRequest }> => {\n  const ConstructionAccount = web3.Keypair.generate();\n  const tx = program.transaction.initConstruction(numbActions, {\n    accounts: {\n      construction: ConstructionAccount.publicKey,\n      authority,\n      rent: web3.SYSVAR_RENT_PUBKEY,\n    },\n    signers: [ConstructionAccount],\n    instructions: [\n      await SystemProgram.createAccount({\n        fromPubkey: program.provider.wallet.publicKey,\n        newAccountPubkey: ConstructionAccount.publicKey,\n        space: CONSTRUCTION_ACCOUNT_SIZE + 8,\n        lamports: calculateRent(\n          CONSTRUCTION_ACCOUNT_SIZE + 8,\n          LIFETIME_CONSTRUCTION_ACCOUNT_MS\n        ),\n        programId: program.programId,\n      }),\n      // await program.account.construction.createInstruction,\n    ],\n  });\n\n  return {\n    tx: { tx, signers: [ConstructionAccount] },\n    construction: ConstructionAccount,\n  };\n};\n\nconst addActionsToConstruction = (\n  program: Program,\n  construction: PublicKey,\n  actions: ActionMetadata[],\n  authority: Signer | Wallet\n): SendTxRequest => {\n  const signers = (authority as Signer).secretKey ? [authority as Signer] : [];\n  const actionMetadataWithU64: ActionMetadata[] = actions.map((action) => {\n    return {\n      ripeAmount: action.ripeAmount,\n      nextNodes: action.nextNodes.map((nextNode) =>\n        nextNode.map((n) => {\n          return {\n            actionIdx: n.actionIdx,\n            fraction: new u64(n.fraction),\n          };\n        })\n      ),\n    };\n  });\n  return {\n    tx: program.transaction.addActions(actionMetadataWithU64, {\n      accounts: {\n        authority: authority.publicKey,\n        construction: construction,\n        rent: web3.SYSVAR_RENT_PUBKEY,\n      },\n      signers: signers,\n    }),\n    signers,\n  };\n};\n\nconst getAllAtStartOfPrepareTxs = (actions: Action[]) =>\n  actions.map((a) => a.atStartOfPrepareTxs || []).flat();\n\nconst prepareConstruction = (\n  program: Program,\n  construction: PublicKey,\n  initActionIdx: number[],\n  initActionSplits: number[],\n  authority: Signer | Wallet,\n  amount: BN\n): SendTxRequest => {\n  const signers = (authority as Signer).secretKey ? [authority as Signer] : [];\n  return {\n    tx: program.transaction.prepareConstruction(\n      initActionIdx,\n      initActionSplits.map((i) => new BN(i)),\n      amount,\n      {\n        accounts: {\n          authority: authority.publicKey,\n          construction: construction,\n          rent: web3.SYSVAR_RENT_PUBKEY,\n        },\n        signers,\n      }\n    ),\n    signers,\n  };\n};\n\n/**\n * @param tokenAuthority - defaults to the authority if not provided\n */\nconst processAction = (\n  program: Program,\n  actionIdx: number,\n  construction: PublicKey,\n  actionAccountsCtx: PartialNextActionCtx,\n  authority: Signer | Wallet,\n  opts: {\n    data?: Buffer;\n    tokenAuthority?: Signer | Wallet;\n    instructions?: TransactionInstruction[];\n    additionalSigners?: Signer[];\n    preActionTxs?: SendTxRequest[];\n  }\n): SendTxRequest[] => {\n  const auth = (authority as Signer)?.secretKey ? [authority as Signer] : [];\n  const tokauth = (opts.tokenAuthority as Signer)?.secretKey\n    ? [opts.tokenAuthority as Signer]\n    : [];\n  const signersIsolated = opts.tokenAuthority\n    ? [...tokauth, ...auth]\n    : [...auth];\n  const signers = [...signersIsolated, ...(opts.additionalSigners || [])];\n  return [\n    ...(opts.preActionTxs || []),\n    {\n      tx: program.transaction.processAction(\n        actionIdx,\n        opts.data || Buffer.from([]),\n        {\n          accounts: {\n            construction: construction,\n            rent: web3.SYSVAR_RENT_PUBKEY,\n            authority: authority.publicKey,\n            actionCtxProxy: actionAccountsCtx.ctx,\n            actionAccounts: actionAccountsCtx.actionAccounts,\n          } as ProcessActionNext,\n          signers,\n          instructions: opts.instructions || undefined,\n        }\n      ),\n      signers,\n    },\n  ];\n};\n\nconst initResultAccount = async (\n  actionTemplateProgram: Program,\n  numberOfPossibleOutputTokens: number\n): Promise<{ tx: SendTxRequest; resultAccount: Signer }> => {\n  const result = Keypair.generate();\n  actionTemplateProgram.provider.connection.getMinimumBalanceForRentExemption;\n  const resultSize = calcSizeResultAccount(numberOfPossibleOutputTokens);\n  const tx = actionTemplateProgram.transaction.initResultAccount(\n    numberOfPossibleOutputTokens,\n    {\n      accounts: {\n        result: result.publicKey,\n        rent: web3.SYSVAR_RENT_PUBKEY,\n      },\n      instructions: [\n        await SystemProgram.createAccount({\n          fromPubkey: actionTemplateProgram.provider.wallet.publicKey,\n          newAccountPubkey: result.publicKey,\n          space: resultSize,\n          lamports: calculateRent(resultSize, LIFETIME_RESULT_ACCOUNT_MS),\n          programId: actionTemplateProgram.programId,\n        }),\n      ],\n      signers: [result],\n    }\n  );\n  return {\n    tx: { tx, signers: [result] },\n    resultAccount: result,\n  };\n};\n\n// From https://github.com/solana-labs/solana-program-library/blob/30406eea40671afefa18b5ae6c9b37ffcb6235d0/token/js/client/token.js#L1850\n/**\n * Construct a Close instruction\n *\n * @param programId SPL Token program account\n * @param account Account to close\n * @param dest Account to receive the remaining balance of the closed account\n * @param authority Account Close authority\n * @param multiSigners Signing accounts if `owner` is a multiSig\n */\nconst createCloseAccountInstruction = (\n  programId: PublicKey,\n  account: PublicKey,\n  dest: PublicKey,\n  owner: PublicKey\n): TransactionInstruction => {\n  throw \"TODO\";\n};\n\n// 8 for the discriminator, 32 for the owner pubkey, 4 for the number of results, and the rest for numb actions, then 64 as a buffer\nconst calcSizeResultAccount = (numberOfActions: number) =>\n  8 + 32 + 4 + numberOfActions * 8 + 64;\n\nconst checkMintsAreTheSame = (actions: Action[]) => {\n  if (actions.length === 0) return true;\n  const mint = actions[0].tokenMintIn.toBase58();\n  return actions.every((a) => a.tokenMintIn.toBase58() === mint);\n};\n","export * from \"./contexts\";\nexport * from \"./common\";\n","export const getConstants = () => {\n  const env = process.env.REACT_APP_SOLANA_NETWORK;\n  switch (env) {\n    case \"devnet\":\n      return {\n        MALLOC_PROGRAM_ID: \"9i4MAnhYagLr1vEo5jdmLehRe8Sm5Lx8fHaQNJfbFCve\",\n        mallocSpl: {\n          TRANSFER_PROGRAM_ID: \"ETpyJNQLorJbAcrPQpM9bkYxYMakegBh93kqZ1KnTBjr\",\n          SWAP_PROGRAM_ID: \"7T6seoCvCQeUeSTf2EAwX5SnyrZvX7BFUMHi74ZodBKH\",\n          DUMMY_PASS_THROUGH: \"DBhGd4VREBAw14vV1yaLXfCTtanPBwQfEErg1fe27diJ\",\n          MINT_TO: \"77WQMNHSBe6BNdMY8R1FD4JX89o2fXr5FhKNerTcJsHJ\",\n          SOLEND_ACTION: \"BVmJHQLHAAdgALGi6rdGxdsk5ate41kbpDMGL9XAVanP\",\n        },\n        projectSerum: {\n          DEX_PROGRAM_ID: \"DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY\",\n        },\n        demo: {\n          FAKE_USDC: \"AkzN2jJrorpUY2ApfL2UsBeTfuv1XHFKGLQurZJg6BhN\",\n          FAKE_USDC_GD: \"2BB7fDrLgBNSMCLqD835GisCHrHrGHsS8SJr6brtnWk2\",\n          FAKE_TOKEN_A: \"9GmQdigrAFdX67EMrVFwMepEN8rEdMdp8CPUEPJRY8sj\",\n        },\n        INITIAL_SPLITTER_ID_UUID: \"initial\",\n        solana: {\n          RPC: \"https://explorer-api.devnet.solana.com\",\n          NETWORK: env,\n        },\n      };\n\n    default:\n      throw \"Unexpected env\";\n  }\n  throw \"Unexpected env\";\n};\n","import { Provider } from \"@project-serum/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport {\n  Action,\n  ActionMetadata,\n  BuildActionMap,\n  Construction,\n  NextNode,\n  NonUserSpecificConstruction,\n} from \"..\";\nimport { buildSeqListOfActionCalls } from \"../graph-utils\";\nimport { deepCloneObject } from \"../utils/object\";\nimport {\n  getTokenAccountUsedByMalloc,\n  PreferredTokenAccounts,\n} from \"../utils/tokens\";\n\nconst getPreviousActions = (\n  actionIdx: number,\n  actions: (Action | undefined)[]\n): { idx: number; idxInNextNodes: [number, number] }[] => {\n  // First add indices to each action\n  // Then remove the undefined actions\n  // Then search if the action has the actionIdx\n  return actions\n    .map((a, i) => {\n      return a ? { ...a, idx: i } : a;\n    })\n    .filter((a) => !!a)\n    .map((a: Action & { idx: number }) => {\n      const idxInNextNodes: [number, number] = [-1, -1];\n      // TODO: note this assumes that each action is only called once from a prior\n      for (let i = 0; i < a.actionMetadata.nextNodes.length; i++) {\n        idxInNextNodes[1] = a.actionMetadata.nextNodes[i]\n          .map((item) => item.actionIdx)\n          .indexOf(actionIdx);\n        if (idxInNextNodes[1] !== -1) {\n          idxInNextNodes[0] = i;\n          break;\n        }\n      }\n      if (idxInNextNodes[0] === -1 || idxInNextNodes[1] === -1)\n        return undefined;\n      return {\n        idx: a.idx,\n        idxInNextNodes,\n      };\n    })\n    .filter((i) => !!i);\n};\n\n/**\n * Get the mint from prior actions\n *\n * This assumes that the action given is not an initial action\n */\nconst getMintAccountFromPriorActions = (\n  actionIdx: number,\n  actions: (Action | undefined)[]\n): string => {\n  const previousActions = getPreviousActions(actionIdx, actions);\n  const mints = previousActions.map((prev) => {\n    const action = actions[prev.idx] as Action; // assume its not undefined because getPreviousAction ensures its not undefined\n    const mint = action.tokenMintOuts[prev.idxInNextNodes[0]];\n    return mint.toBase58();\n  });\n  if (mints.length < 1)\n    throw `Expected to find a previous action for a non initial action`;\n  const firstMint = mints[0];\n  if (!mints.every((mint) => mint === firstMint))\n    throw `Expected all previous mints to be the same for the action`;\n  return firstMint;\n};\n\nexport const buildConstructionFromNonUserSpecific = async (\n  construction: NonUserSpecificConstruction,\n  buildActionMap: BuildActionMap,\n  initTokenAccount: string,\n  initMintAccount: string,\n  provider: Provider,\n  preferredTokenAccounts?: PreferredTokenAccounts\n): Promise<Construction> => {\n  const orderActionsHit = buildSeqListOfActionCalls(\n    construction.actionDatas.map((a) => a.actionMetadata),\n    construction.initialActionIndices\n  );\n\n  if (orderActionsHit.length !== construction.actionDatas.length)\n    throw `An unexpected error occurred, the order of actions hit should match the length of actions`;\n\n  const actions: (Action | undefined)[] = [\n    ...Array(construction.actionDatas.length),\n  ];\n  for (let i = 0; i < orderActionsHit.length; i++) {\n    const actionIdx = orderActionsHit[i];\n    const mintAccount = construction.initialActionIndices.includes(actionIdx)\n      ? initMintAccount\n      : getMintAccountFromPriorActions(actionIdx, actions);\n    const actionData = construction.actionDatas[actionIdx];\n    const buildFN = buildActionMap[actionData.actionTypeUID].buildIsolatedAction;\n    if (!buildFN)\n      throw `Could not find a builder function for action with UID ${actionData.actionTypeUID}`;\n    const tokenAccount = construction.initialActionIndices.includes(i)\n      ? initTokenAccount\n      : (\n          await getTokenAccountUsedByMalloc(\n            provider.wallet.publicKey,\n            new PublicKey(mintAccount),\n            preferredTokenAccounts\n          )\n        ).toBase58();\n    const { isolatedAction } = await buildFN(\n      actionData.buildActionInputs,\n      mintAccount,\n      tokenAccount,\n      actionData.actionPID,\n      provider,\n      {\n        preferredTokenAccounts,\n      }\n    );\n    const action = {\n      ...isolatedAction,\n      actionMetadata: actionData.actionMetadata,\n    };\n    actions[actionIdx] = action;\n  }\n\n  return {\n    actions,\n    initialActionIndices: construction.initialActionIndices,\n    initialSplits: construction.initialSplits,\n    amount: new BN(construction.amount),\n  };\n};\n\nconst offsetNextNodes = (\n  nextNodes: ActionMetadata[\"nextNodes\"],\n  offset: number\n): ActionMetadata[\"nextNodes\"] =>\n  nextNodes.map((nextNodeSet) =>\n    nextNodeSet.map((n) => {\n      return {\n        actionIdx: n.actionIdx + offset,\n        fraction: n.fraction,\n      } as NextNode;\n    })\n  );\n\n/**\n * Merge two constructions into 1. One is the parent and keeps its initial indices and amounts,\n * the other discards the amount value and initial indices/ splits and replaces them with the specified inputs\n *\n * @param appendChildInitToParent - where to append the initial action indices of the child construction\n * to the parent.\n */\nexport const mergeConstructions = (\n  parentConstruction: NonUserSpecificConstruction,\n  childConstruction: NonUserSpecificConstruction,\n  appendChildInitToParent: {\n    appendToInitial?: boolean;\n    indexInParent?: {\n      actionIdx: number;\n      nextNodeIdx: number;\n    };\n    splitFrac: number | string;\n  }[]\n): NonUserSpecificConstruction => {\n  // deep copy the child and parent\n  const childConstructionCloned = deepCloneObject(childConstruction);\n  const parentConstructionClone = deepCloneObject(parentConstruction);\n\n  if (\n    appendChildInitToParent.length! ==\n      childConstructionCloned.initialActionIndices.length &&\n    appendChildInitToParent.length !==\n      childConstructionCloned.initialSplits.length\n  ) {\n    throw `Expected the info to append the child to the parent to provide the same number of indices as the number of initial splits in the child`;\n  }\n  const newActionDatasArray = [\n    ...parentConstructionClone.actionDatas,\n    ...childConstructionCloned.actionDatas.map((a) => {\n      return {\n        ...a,\n        actionMetadata: {\n          ...a.actionMetadata,\n          nextNodes: offsetNextNodes(\n            a.actionMetadata.nextNodes,\n            parentConstructionClone.actionDatas.length\n          ),\n        },\n      };\n    }),\n  ];\n\n  const childInitialActionsToAdd = [];\n  for (let i = 0; i < appendChildInitToParent.length; i++) {\n    if (appendChildInitToParent[i].appendToInitial) {\n      childInitialActionsToAdd.push({\n        idx: i + parentConstructionClone.actionDatas.length,\n        fraction: appendChildInitToParent[i].splitFrac,\n      });\n    } else if (appendChildInitToParent[i].indexInParent) {\n      newActionDatasArray[\n        appendChildInitToParent[i].indexInParent.actionIdx\n      ].actionMetadata.nextNodes[\n        appendChildInitToParent[i].indexInParent.nextNodeIdx\n      ].push({\n        fraction: appendChildInitToParent[i].splitFrac,\n        actionIdx: i + parentConstructionClone.actionDatas.length,\n      });\n    } else {\n      throw `Expected the appendChildInitToParent to either append to initial or contain info as to where to append in the parent`;\n    }\n  }\n\n  const newInitialActionIndices = [\n    ...parentConstructionClone.initialActionIndices,\n    ...childInitialActionsToAdd.map((c) => c.idx),\n  ];\n  const newIninitialSplits = [\n    ...parentConstructionClone.initialSplits,\n    ...childInitialActionsToAdd.map((c) => c.fraction),\n  ];\n  return {\n    actionDatas: newActionDatasArray,\n    initialActionIndices: newInitialActionIndices,\n    initialSplits: newIninitialSplits,\n    amount: parentConstructionClone.amount,\n  };\n};\n","export class Assignable {\n\tconstructor(properties) {\n\t\t\tObject.keys(properties).map((key) => {\n\t\t\t\t\tthis[key] = properties[key];\n\t\t\t});\n\t}\n}"],"sourceRoot":""}