{"version":3,"sources":["../../../malloc-core/ts-packages/malloc-sdk/lib/index.ts","interfaces.ts","utils/files.ts","utils/graph.ts","globalStore.ts","../../../malloc-spl/src/index.ts","state/flowchart-store.ts","utils/spl-tokens.ts","utils/anchor.ts","utils/action-types.ts","components/node-selector.tsx","components/tokens/TokenAccountChooser.tsx","components/table/table-cells.tsx","components/node-info.tsx","components/graph-visualizer.jsx","utils/errors.ts","utils/sdk-interpelator.ts","components/usdc-airdrop/perform-usdc-airdrop.ts","components/node-visualizer.tsx","components/tablegui.tsx","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx","../../../malloc-spl/src/swap/swap-interfaces.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/constants.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/utils/tokens.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/utils/object.ts","utils/malloc.ts","../../../malloc-spl/src/mint/index.ts","../../../malloc-spl/src/mint-to/index.ts","../../../malloc-spl/src/swap/index.ts","../../../malloc-spl/src/transfer/index.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/graph-utils.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/solana-utils.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/malloc-sdk.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/interfaces/index.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/builder/index.ts","config/constants.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/utils/serde.ts"],"names":["InputClassNames","saveStringToFile","data","filename","JSON","stringify","undefined","blob","Blob","type","e","document","createEvent","a","createElement","download","href","window","URL","createObjectURL","dataset","downloadurl","join","initMouseEvent","dispatchEvent","console","error","getFileContent","fileDialog","accept","getSourceNode","g","SOURCE_NODE_ID","getSourceNodeAccount","inp","value","getSourceNodeAmount","getAllVertices","Object","keys","getVertexType","v","split","getNextVertices","vertex","next_actions","map","nextActionSet","slice","nextAction","amount","parseInt","id","filter","i","getNextActionRow","nextMintIdx","className","actionVertex","wholeNumber","ACTION_TYPES","INIT_NEXT_ACTION","readOnly","initState","selected","counter","new_action","graph","sourceMint","hiddenInputData","input","CellClassNames","tokenAccountOnlyInit","fractionNumber","globalStore","Store","setGlobalStoreFromFile","fileContents","length","alert","text","parsed","parse","log","setState","downloadGlobalStore","state","MallocSPLBuildActionMap","addActionToMap","actionLib","actionTypeUID","SwapAction","TransferAction","MintAction","MintAndMintToAction","solanaSplStore","derivedTokenAccounts","tokenList","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","ASSOCIATED_TOKEN_PROGRAM_ID","getTokenLists","provider","getCached","TokenListProvider","resolve","tokens","filterByClusterSlug","getConstants","solana","NETWORK","getList","getDemoTokenInfo","usdcMint","PublicKey","demo","FAKE_USDC","aMint","FAKE_TOKEN_A","getMintInfo","usdcInfo","aInfo","chainId","name","symbol","address","findAssociatedTokenAddress","walletAddress","tokenMintAddress","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","associated","findAllAssociatedTokenAddress","mints","Promise","all","m","getTokenAccountInfo","tokenAddr","connection","getAccountInfo","account","parseTokenAccount","mintAddr","parseMintAccount","getProvider","wallet","Provider","Connection","RPC","getActionTypeUIDFromVertex","vertexType","getActionPIDFromVertex","mallocSpl","SWAP_PROGRAM_ID","TRANSFER_PROGRAM_ID","MINT_TO","NodeSelector","useStore","actions","buttonStyle","useAnchorWallet","maxWidth","maxHeight","minWidth","minHeight","useState","Card","CardContent","size","aria-label","style","width","onChange","target","key","index","Button","variant","onClick","node_id","toString","init","other","mintAccount","hiddenData","rent","SYSVAR_RENT_PUBKEY","toBase58","serumDexProgramId","projectSerum","DEX_PROGRAM_ID","getInitInputForActionType","new_node","Array","expectedNumberOfOutMints","getModalStyle","top","left","transform","useStyles","makeStyles","theme","createStyles","paper","position","backgroundColor","palette","background","border","boxShadow","shadows","padding","spacing","TokenLine","tok","setChoosen","display","gridTemplateColumns","gap","info","shortenAddress","mint","balance","utils","toReadableNumber","u64","decimals","TokenAccountChooser","props","onlyWithInitializedAccounts","classes","React","modalStyle","open","setOpen","customTokenAccount","setCustomTokenAccount","customMintAccount","setCustomMintAccount","choosen","solanaSplStoreHook","loadTokens","publicKey","t","associatedAddr","addr","bals","accounts","accountsFiltered","accountsMapped","useEffect","useRef","handleClose","onClose","choosenType","tokenAccount","tokAccountData","mintInfo","bal","body","onBlur","currentTarget","blur","height","zIndex","justifyItems","justifyContent","alignItems","overflow","includeCustomTokenAccount","TextField","label","onFocus","buttonText","InputEditor","Input","cell","isWholeNumber","isFractionNumber","TokenOrMintEditor","onlyWithInitialized","splTok","ActionVertexEditor","vertices","initIdx","indexOf","splice","getActionVertices","active","setActive","pause","setPause","paused","Select","labelId","MenuItem","onMouseOver","TableCellEditor","nextActionMintIdx","mintAccountOnlyInit","NodeInfo","setInput","mintName","sourceAccount","DataEditor","next_action_by_mint","_data","nextActions","object","deepCloneObject","x","setHardCodedNextActions","CardActions","temp","GraphVisualizer","setData","svgRef","nodes","links","source","types","color","d3","linkArc","d","r","Math","hypot","y","create","simulation","force","strength","svg","current","attr","append","selectAll","link","location","node","call","on","event","alphaTarget","restart","fx","fy","drag","clone","lower","ref","newData","pop","handleError","errorType","eCast","msg","fullError","ErrorGenerator","tokAccount","newFrontendError","PID","MALLOC_PROGRAM_ID","getMallocSdk","MallocSdk","getInputFromActionInput","actionInput","ret","inpItem","getActionData","actionId","allActionIds","incomingVertices","some","nextEdgeSet","includes","getAllIncomingVertexIds","nextNodes","next","actionIdx","fraction","getNextNodes","buildActionInputs","actionPID","actionMetadata","ripeAmount","_buildNonUserSpecificConstruction","hiddenInputDatas","actionVertices","initialSplits","initialActionIndices","actionDatas","getInitialInfo","inAccount","sourceNode","tokenInInfo","amountInF","parseFloat","amountIn","fromReadableNumber","nextFromSource","initialMint","n","compileStateIntoSDKInput","preferredTokenAccounts","nonUserSpecific","builder","buildConstructionFromNonUserSpecific","construction","amountInAccount","opts","run","sdk","buildTxs","sendRequests","prepareCommitment","skipPreflight","preflightCommitment","commitment","actionCommitment","compileAndRunMallocSDK","buildInst","txs","richUSDCAirdroperSK","Uint8Array","richUSDCSigner","Wallet","Keypair","fromSecretKey","getRichUsdcProvider","endpointURL","performUsdcAirdrop","userAddr","tryCreateAssociatedAccount","airdrop","FAKE_USDC_GD","instr","Token","createAssociatedTokenAccountInstruction","tx","Transaction","add","send","gdUsdc","airDropToTokenAccounts","amountAirdrop","transferTxs","createTransferInstruction","NodeVisualizer","loadingAirdrop","setLoadingAirdrop","loadingCompileAndRun","setLoadingCompileAndRun","disabled","then","_","catch","TableGUI","ConnectButton","styled","WalletDialogButton","Home","span","setBalance","message","severity","alertState","setAlertState","useWallet","getBalance","LAMPORTS_PER_SOL","connected","marginTop","toLocaleString","Snackbar","autoHideDuration","Alert","config","anchor","network","rpcHost","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSolletWallet","autoConnect","txTimeout","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById","Side","SwapInstructionByte","CONSTRUCTION_ACCOUNT_SIZE","LIFETIME_RESULT_ACCOUNT_MS","ONE_HOUR_MS","LIFETIME_CONSTRUCTION_ACCOUNT_MS","LAMPORTS_PER_EPOCH","MS_PER_EPOCH","tryCreateAssociatedAccountInst","owner","payer","inst","associateTokAccount","transferToTx","destination","authority","signer","secretKey","transfer","signers","getTokenAccountUsedByMalloc","tokenAuthority","createTokenAccountsForActions","fundingAccount","getMintsNoDuplicates","tokenCreationOptions","skipOutTokenCreations","skipIdxs","tokenMintOuts","forEach","push","skipInTokenCreation","tokenMintIn","flat","pk","associatedToSignerAccount","insts","createTokTx","Set","pkToStr","number","wholeStr","substring","fractionStr","padStart","pattern","test","replace","formatWithCommas","wholePart","fracPart","Error","padEnd","obj","constructor","chars","buildIsolatedMintAction","inMint","inTokenAccount","dummyPassThroughActionPID","amountOutExpanded","amountOut","outTokenAccount","serializeData","createMintInstructions","addDefaultTokAccounts","actionData","tokenAccountOuts","actionAccounts","actionProgram","additionalSigners","instructions","isolatedAction","Buffer","from","buildIsolatedAction","ActionData","serde","Assignable","schema","Map","kind","fields","inputMint","inputTokenAccount","mintToPID","authoritySigner","authoritySecret","createMintSecretKey","associateTokAccountRecipient","optionalAmountWholeNumber","initialSupply","atStartTxs","borshSer","amount_override","isWriteable","isSigner","atStartOfPrepareTxs","buildIsolatedSwapAction","swapPID","outMint","buildSwapAccounts","swapInfo","packSwapData","BasicSwap","side","minOut","swapAccountsToActionAccounts","swapAccounts","preActionTxs","openOrderInitTx","serumDexId","getMarket","marketRet","marketPk","Market","load","marketSel","getOpenOrdersAccount","openOrderAccountData","getVaultOwnerAndNonce","decoded","ownAddress","vaultSigner","coinWallet","Bid","pcWallet","market","requestQueue","eventQueue","bids","asks","coinVault","baseVault","pcVault","quoteVault","openOrders","openOrdersAccount","openOrderPk","orderPayerTokenAccount","dexProgram","tokenProgram","openOrderTx","dexPID","OpenOrders","findForMarketAndOwner","openOrderAccount","Account","openOrdersTx","makeCreateAccountTransaction","Ask","getMarketsFromBaseMinttoQuoteMint","marketPks","instrByte","packedMinOut","toArrayLike","initPart","concat","referralAccount","outAccount","marketPublicKey","dexProgramId","nonce","BN","toNumber","createProgramAddress","vaultOwner","iaddn","baseMint","quoteMint","serumProgId","getLayout","findAccountsByMints","transferPID","mintIn","recipient","recipientWallet","createTokInstr","equals","buildSeqListOfActionCalls","actionMetas","initIndices","initHitCounts","fill","simulateDAG","hitCounts","toHit","newHitCounts","getOccurrence","newRipeActions","newToHit","o","array","calculateRent","durationMs","ceil","mallocProgram","this","Program","MALLOC_IDL","_authority","_inAuth","amountInAuthority","tokenAccounts","tokenTxs","createAndInitConstruction","constructionTx","addConstructionActionsTx","addActionsToConstruction","checkMintsAreTheSame","initMint","transferTx","prepareConstructionTx","prepareConstruction","hitOrder","initResultAccount","ACTION_TEMPLATE_IDL","initResultAccounts","actionCtxFilled","action","toAdd","ctx","resultAccount","processTxs","hitIndex","processAction","getAllAtStartOfPrepareTxs","txsPrepare","txsActionsCalls","txsActionCalls","resultAccounts","fetch","constructionState","actionSerialize","nextNode","actionCallSerialize","numbTimesHit","callAmount","actionCalls","readyCallIdxList","constructionData","options","sendAll","txHashesPrepare","onPrepareAccountsDone","txHashes","program","numbActions","ConstructionAccount","web3","generate","transaction","SystemProgram","createAccount","fromPubkey","newAccountPubkey","space","lamports","programId","initConstruction","actionMetadataWithU64","addActions","initActionIdx","initActionSplits","actionAccountsCtx","auth","tokauth","signersIsolated","actionCtxProxy","actionTemplateProgram","numberOfPossibleOutputTokens","result","getMinimumBalanceForRentExemption","resultSize","calcSizeResultAccount","numberOfActions","every","getMintAccountFromPriorActions","idx","idxInNextNodes","item","getPreviousActions","prev","firstMint","buildActionMap","initTokenAccount","initMintAccount","orderActionsHit","buildFN","mergeConstructions","parentConstruction","childConstruction","appendChildInitToParent","childConstructionCloned","parentConstructionClone","newActionDatasArray","offset","nextNodeSet","childInitialActionsToAdd","appendToInitial","splitFrac","indexInParent","nextNodeIdx","c","env","process","DUMMY_PASS_THROUGH","INITIAL_SPLITTER_ID_UUID","properties"],"mappings":"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","file":"static/js/main.422f6abe.chunk.js","sourcesContent":["export * from \"./malloc-sdk\";\nexport * from \"./interfaces\";\nexport * as utils from \"./utils\";\nexport * as serializer from \"./serializer\";\nexport * as builder from './builder'\nimport _MallocIdl from \"./idls/malloc.json\";\nexport const MallocIdl = _MallocIdl;\n","import { MintInfo, u64 } from \"@solana/spl-token\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { FlowElement } from \"react-flow-renderer\";\nimport internal from \"stream\";\n\nexport enum InputClassNames {\n  actionVertex = \"ACTION_VERTEX\",\n  tokenAccount = \"TOKEN_ACCOUNT\",\n  mintAccount = \"MINT_ACCOUNT\",\n  tokenAccountOnlyInit = \"TOKEN_ACCOUNT_ONLY_INIT\",\n  mintAccountOnlyInit = \"MINT_ACCOUNT_ONLY_INIT\",\n  wholeNumber = \"WHOLE_NUMBER\",\n  fractionNumber = \"FRACTION_NUMBER\",\n  other = \"OTHER\",\n}\n\nexport type SPLToken = { account: string } & {\n  info: Partial<TokenInfo> & { decimals: number; mint: PublicKey };\n  balance: string | u64 | null;\n};\n\nexport type NextAction = [\n  { value: string; readOnly?: boolean; className?: string },\n  { value: string; readOnly?: boolean; className?: string }\n];\n\nexport type Input = [\n  { value: string; readOnly: true },\n  { value: string; className?: string }\n][];\nexport type SourceNodeInput = [\n  [{ value: string; readOnly: true }, { value: string; className?: string }],\n  [{ value: string; readOnly: true }, { value: string; className?: string }]\n];\nexport type ActionEdge = { id: string; amount: number };\nexport type NodeType = { input: Input; next_actions: NextAction[][] };\nexport type GraphType = { [id: string]: NodeType };\nexport type HiddenInputData = { [id: string]: any };\n","import fileDialog from \"file-dialog\";\n/* function to save JSON to file from browser\n * adapted from http://bgrins.github.io/devtools-snippets/#console-save\n * @param {Object} data -- json object to save\n * @param {String} file -- file name to save to\n */\nexport const saveStringToFile = (data: any, filename: string) => {\n  if (!data) {\n    console.error(\"No data\");\n    return;\n  }\n\n  if (!filename) filename = \"console.json\";\n\n  if (typeof data === \"object\") {\n    data = JSON.stringify(data, undefined, 4);\n  }\n\n  var blob = new Blob([data], { type: \"text/json\" }),\n    e = document.createEvent(\"MouseEvents\"),\n    a = document.createElement(\"a\");\n\n  a.download = filename;\n  a.href = window.URL.createObjectURL(blob);\n  a.dataset.downloadurl = [\"text/json\", a.download, a.href].join(\":\");\n  e.initMouseEvent(\n    \"click\",\n    true,\n    false,\n    window,\n    0,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null\n  );\n  a.dispatchEvent(e);\n};\n\nexport const getFileContent = async () => {\n\treturn await fileDialog({\n\t\taccept: 'application/json'\n\t})\n};\n","import { SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { getConstants } from \"src/config/constants\";\nimport { ActionTypes, INIT_NEXT_ACTION, SOURCE_NODE_ID } from \"src/globalStore\";\nimport {\n  ActionEdge,\n  GraphType,\n  HiddenInputData,\n  Input,\n  InputClassNames,\n  NextAction,\n  SourceNodeInput,\n} from \"src/interfaces\";\n\nexport const getSourceNode = (g: GraphType) => g[SOURCE_NODE_ID];\n\nexport const getSourceNodeAccount = (inp: SourceNodeInput) => inp[0][1].value;\nexport const getSourceNodeAmount = (inp: SourceNodeInput) => inp[1][1].value;\nexport const getAllVertices = (g: GraphType): string[] => Object.keys(g);\nexport const getActionVertices = (g: GraphType): string[] => {\n  const all = Object.keys(g);\n  const initIdx = all.indexOf(SOURCE_NODE_ID);\n  all.splice(initIdx, 1);\n  return all;\n};\n\nexport const getVertexType = (v: string): ActionTypes =>\n  v.split(\"-\")[0] as ActionTypes;\n\n// Discard the first element as those are just labels\nexport const getNextVertices = (\n  g: GraphType,\n  vertex: string\n): ActionEdge[][] => {\n  const nextActions = g[vertex].next_actions;\n  const ret = nextActions.map((nextActionSet) => {\n    const nextActionRemoveLabel = nextActionSet.slice(1);\n    const edgesRet = nextActionRemoveLabel.map((nextAction: NextAction) => {\n      if (!nextAction[1].value && !nextAction[0].value) {\n        return null;\n      }\n      return {\n        amount: parseInt(nextAction[1].value),\n        id: nextAction[0].value,\n      } as ActionEdge;\n    });\n    // Remove empty rows\n    return edgesRet.filter((e, i) => e !== null) as ActionEdge[];\n  });\n  return ret;\n};\n\nexport const getNextActionRow = (nextMintIdx: number) => {\n  return [\n    { value: \"\", className: `${InputClassNames.actionVertex}-${nextMintIdx}` },\n    { value: \"\", className: InputClassNames.wholeNumber },\n  ] as NextAction;\n};\n","import { Store } from \"react-stores\";\nimport {\n  Input,\n  ActionEdge,\n  NodeType,\n  GraphType,\n  SourceNodeInput,\n  NextAction,\n  HiddenInputData,\n  InputClassNames as CellClassNames,\n} from \"src/interfaces\";\nimport { getFileContent, saveStringToFile } from \"./utils/files\";\nimport { getNextActionRow } from \"./utils/graph\";\n\nexport interface MallocState {\n  selected: string;\n  counter: number;\n  new_action: string;\n  graph: GraphType;\n  sourceMint: string;\n  hiddenInputData: HiddenInputData;\n}\n\nexport const SOURCE_NODE_ID = \"SOURCE-0\";\n\nexport type ActionTypes = \"SERUM_SWAP\" | \"TRANSFER\" | \"MINT\";\nexport const ACTION_TYPES: ActionTypes[] = [\"SERUM_SWAP\", \"TRANSFER\", \"MINT\"];\n\nexport const INIT_NEXT_ACTION: NextAction[] = [\n  [\n    { value: \"NextActionID\", readOnly: true },\n    { value: \"Parts of 1,000\", readOnly: true },\n  ],\n  getNextActionRow(0),\n];\n\nconst initState: MallocState = {\n  selected: SOURCE_NODE_ID,\n  counter: 1,\n  new_action: \"SERUM_SWAP\",\n  graph: {},\n  sourceMint: \"<UNSET>\",\n  hiddenInputData: {},\n};\n\ninitState.graph[SOURCE_NODE_ID] = {\n  input: [\n    [\n      {\n        value: \"InputTokenAccount\",\n        readOnly: true,\n      },\n      { value: \"\", className: CellClassNames.tokenAccountOnlyInit },\n    ],\n    [\n      {\n        value: \"Amount\",\n        readOnly: true,\n      },\n      { value: \"\", className: CellClassNames.fractionNumber },\n    ],\n  ] as SourceNodeInput,\n  next_actions: [INIT_NEXT_ACTION],\n};\n\nexport const globalStore = new Store<MallocState>(initState);\n\nexport const getGlobalStore = () => globalStore.state;\n\nexport const setGlobalStoreFromFile = async () => {\n  const fileContents = await getFileContent();\n  if (fileContents.length < 1) {\n    alert(\"Please select a file\");\n    return;\n  }\n  // TODO: use have the input be the nonspecific construction (and validated via malloc sdk) and then have a function which interpolates\n  const parsed = JSON.parse(await fileContents[0].text()) as MallocState;\n  console.log(parsed);\n  // Set the token account in to be undefined\n  parsed.graph[SOURCE_NODE_ID].input[0][1].value = \"\";\n  globalStore.setState(parsed);\n};\n\nexport const downloadGlobalStore = async () => {\n  await saveStringToFile(JSON.stringify(globalStore.state), \"flow.json\");\n};\n","import { ActionLib, BuildActionMap } from \"@malloc/sdk\";\nimport MintAction from \"./mint\";\nimport { MintAndMintToAction } from \"./mint-to\";\nimport SwapAction from \"./swap\";\nimport { TransferAction } from \"./transfer\";\n\nexport { SwapAction } from \"./swap\";\nexport { TransferAction } from \"./transfer\";\nexport { MintAction } from \"./mint\";\nexport { MintAndMintToAction } from \"./mint-to\";\n\nexport const MallocSPLBuildActionMap: BuildActionMap = {};\n\n// Add the spl actions to the default mapping\nconst addActionToMap = (actionLib: ActionLib<any>) => {\n  MallocSPLBuildActionMap[actionLib.actionTypeUID] = actionLib;\n};\n\naddActionToMap(SwapAction);\naddActionToMap(TransferAction);\naddActionToMap(MintAction);\naddActionToMap(MintAndMintToAction);\n","import { Elements, FlowElement } from \"react-flow-renderer\";\nimport { Store } from \"react-stores\";\nimport { SPLToken } from \"../interfaces\";\nimport {\n  AccountsArray,\n  Action,\n  IsolatedAction,\n} from \"../../../../malloc-core/ts-packages/malloc-sdk/lib/\";\nimport { getConstants } from \"../config/constants\";\nimport { PublicKey, Signer } from \"@solana/web3.js\";\nimport { u64 } from \"@solana/spl-token\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\n\nexport interface IFlowChart {\n  elements: Elements<any>;\n  initSplits: number[];\n  initTokenAccount?: PublicKey;\n  initAmount: u64;\n}\n\nexport interface SolanaSpl {\n  derivedTokenAccounts: SPLToken[] | null;\n  tokenList: TokenInfo[] | null;\n}\n\nexport const solanaSplStore = new Store<SolanaSpl>({\n  derivedTokenAccounts: null,\n  tokenList: null,\n});\n","import { getProvider, Provider } from \"@project-serum/anchor\";\nimport { parseTokenAccount, parseMintAccount } from \"@project-serum/common\";\nimport {\n  AccountInfo,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  MintInfo,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport {\n  TokenListProvider,\n  TokenInfo,\n  TokenListContainer,\n} from \"@solana/spl-token-registry\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\nimport { solanaSplStore } from \"../state/flowchart-store\";\n\n// TODO: where does this come from?\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: PublicKey =\n  ASSOCIATED_TOKEN_PROGRAM_ID;\n\n// TODO: have a store for token metadata which has a list of all tokens as well as their metadata\n\n// See https://github.com/solana-labs/token-list\nexport const getTokenLists = async (\n  provider: Provider\n): Promise<TokenInfo[]> => {\n  const getCached = async () => {\n    if (solanaSplStore.state.tokenList) return solanaSplStore.state.tokenList;\n    const tokens = await new TokenListProvider().resolve();\n    const tokenList = tokens\n      .filterByClusterSlug(getConstants().solana.NETWORK)\n      .getList();\n    solanaSplStore.setState({\n      ...solanaSplStore.state,\n      tokenList,\n    });\n    return tokenList;\n  };\n  const tokenList = await getCached();\n\n  // Add in demo tokens\n  if (getConstants().solana.NETWORK === \"devnet\") {\n    return [...tokenList, ...(await getDemoTokenInfo(provider))];\n  } else {\n    return tokenList;\n  }\n};\n\nconst getDemoTokenInfo = async (provider: Provider): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(getConstants().demo.FAKE_USDC);\n  const aMint = new PublicKey(getConstants().demo.FAKE_TOKEN_A);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: getConstants().demo.FAKE_USDC,\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE: A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: getConstants().demo.FAKE_TOKEN_A,\n    },\n  ];\n};\n\nexport const getTokenListContainer = async (\n  provider: Provider\n): Promise<TokenListContainer> =>\n  new TokenListContainer(await getTokenLists(provider));\n\n// See https://spl.solana.com/associated-token-account\nexport const findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  const associated = await PublicKey.findProgramAddress(\n    [\n      walletAddress.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      new PublicKey(tokenMintAddress).toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  return associated[0];\n};\nexport const findAllAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  mints: (PublicKey | string)[]\n): Promise<PublicKey[]> =>\n  Promise.all(mints.map((m) => findAssociatedTokenAddress(walletAddress, m)));\n\nexport const getTokenAccountInfo = async (\n  provider: Provider,\n  tokenAddr: PublicKey\n): Promise<AccountInfo | null> => {\n  const account = await provider.connection.getAccountInfo(tokenAddr);\n  if (!account) return null;\n  try {\n    const data = parseTokenAccount(account.data);\n    return data;\n  } catch (e) {\n    console.error(\"An error occured parsing the data, returning null\", e);\n    return null;\n  }\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n","import { Provider } from \"@project-serum/anchor\";\nimport { AnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\n\nexport const getProvider = (wallet: AnchorWallet): Provider => {\n  return new Provider(new Connection(getConstants().solana.RPC), wallet, {});\n};\n","import { utils } from \"@malloc/sdk\";\nimport {\n  MintAction,\n  MintAndMintToAction,\n  SwapAction,\n  TransferAction,\n} from \"@malloc/spl\";\nimport { SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\nimport { getConstants } from \"src/config/constants\";\nimport { ActionTypes } from \"src/globalStore\";\nimport {\n  HiddenInputData,\n  Input,\n  InputClassNames,\n  NextAction,\n} from \"src/interfaces\";\nimport { getVertexType } from \"./graph\";\n\nexport const getActionTypeUIDFromVertex = (vertexType: ActionTypes) => {\n  if (vertexType === \"SERUM_SWAP\") {\n    return SwapAction.actionTypeUID;\n  } else if (vertexType === \"TRANSFER\") {\n    return TransferAction.actionTypeUID;\n  } else if (vertexType === \"MINT\") {\n    return MintAndMintToAction.actionTypeUID;\n  } else throw `unexpected vertex id of ${vertexType}`;\n};\n\n// TODO: move this over to Malloc SPL and use action type uids instead\nexport const getActionPIDFromVertex = (vertexType: ActionTypes) => {\n  if (vertexType === \"SERUM_SWAP\") {\n    return getConstants().mallocSpl.SWAP_PROGRAM_ID;\n  } else if (vertexType === \"TRANSFER\") {\n    return getConstants().mallocSpl.TRANSFER_PROGRAM_ID;\n  } else if (vertexType === \"MINT\") {\n    return getConstants().mallocSpl.MINT_TO;\n  }\n  throw `unexpected vertex id of ${vertexType}`;\n};\n\nexport const getInitInputForActionType = (\n  type: ActionTypes\n): { input: Input; hiddenData?: HiddenInputData } => {\n  switch (type) {\n    case \"MINT\":\n      return {\n        input: [\n          [\n            {\n              value: \"decimals\",\n              readOnly: true,\n            },\n            {\n              value: \"6\",\n              className: InputClassNames.wholeNumber,\n            },\n          ],\n          [\n            {\n              value: \"initialSupply\",\n              readOnly: true,\n            },\n            {\n              value: \"\",\n              className: InputClassNames.fractionNumber,\n            },\n          ],\n        ],\n      };\n\n    case \"TRANSFER\":\n      return {\n        input: [\n          [\n            {\n              value: \"recipientWallet\",\n              readOnly: true,\n            },\n            { value: \"\", className: InputClassNames.other },\n          ],\n        ],\n      };\n\n    case \"SERUM_SWAP\":\n      return {\n        input: [\n          [\n            {\n              value: \"outMint\",\n              readOnly: true,\n            },\n            { value: \"\", className: InputClassNames.mintAccount },\n          ],\n          [\n            {\n              value: \"minOut\",\n              readOnly: true,\n            },\n            { value: \"\", className: InputClassNames.wholeNumber },\n          ],\n        ],\n        hiddenData: {\n          rent: SYSVAR_RENT_PUBKEY.toBase58(),\n          serumDexProgramId: getConstants().projectSerum.DEX_PROGRAM_ID,\n        },\n      };\n\n    default:\n      throw `Unexpected action type ${type}`;\n  }\n};\n\nexport const setHardCodedNextActions = (\n  nextActions: NextAction[]\n): NextAction[] => {\n  const data = utils.object.deepCloneObject(nextActions);\n  for (let x = 0; x < data.length; x++) {\n    // TODO: this shouldn't be hardcoded\n    if (getVertexType(data[x][0]!.value) === \"MINT\") {\n      data[x][1]!.value = \"0\";\n      data[x][1]!.readOnly = true;\n    }\n  }\n  return data\n};\n","import React, { useState, FC } from 'react';\nimport Card from '@mui/material/Card';\nimport CardActions from '@mui/material/CardActions';\nimport CardContent from '@mui/material/CardContent';\nimport Button from '@mui/material/Button';\nimport Spreadsheet from \"react-spreadsheet\";\n\nimport {\n    Input,\n    ActionEdge,\n    NodeType,\n    GraphType,\n    NextAction,\n    InputClassNames,\n    SourceNodeInput,\n  } from \"src/interfaces\";\n  import { useStore } from \"react-stores\";\n  import {\n    ActionTypes,\n    ACTION_TYPES,\n    downloadGlobalStore,\n    globalStore,\n    INIT_NEXT_ACTION,\n    setGlobalStoreFromFile,\n    SOURCE_NODE_ID,\n  } from \"../globalStore\";\n  import {\n    compileAndRunMallocSDK,\n  } from \"src/utils/sdk-interpelator\";\n  import { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\n  import {\n    getSourceNodeAccount,\n  } from \"src/utils/graph\";\n  import { MallocSPLBuildActionMap } from \"@malloc/spl\";\n  import { TableCellEditor } from \"./table/table-cells\";\n  import { performUsdcAirdrop } from \"./usdc-airdrop/perform-usdc-airdrop\";\n  import { saveStringToFile } from \"src/utils/files\";\n  import { Satellite } from \"@material-ui/icons\";\n  import { getMintInfo, getTokenAccountInfo } from \"src/utils/spl-tokens\";\n  import { getProvider } from \"src/utils/anchor\";\n  import { PublicKey } from \"@solana/web3.js\";\n  import { getActionTypeUIDFromVertex, getInitInputForActionType } from \"src/utils/action-types\";\n  \n\nconst NodeSelector: FC = () => {\n\n    const state = useStore(globalStore);\n    const actions = ACTION_TYPES;\n    const wallet = useAnchorWallet();\n    const buttonStyle = {\n        maxWidth: \"20px\",\n        maxHeight: \"20px\",\n        minWidth: \"20px\",\n        minHeight: \"20px\",\n    };\n\n    // Control panel loaders\n    const [loadingAirdrop, setLoadingAirdrop] = useState(false);\n    const [loadingCompileAndRun, setLoadingCompileAndRun] = useState(false);\n    // End control panel loaders\n\n    const setInput = async (data: Input) => {\n        state.graph[state.selected].input = data as Input;\n        let mintName = state.sourceMint;\n        if (state.selected === SOURCE_NODE_ID) {\n        const sourceAccount = getSourceNodeAccount(data as SourceNodeInput);\n        if (sourceAccount) {\n            const info = await getTokenAccountInfo(\n            getProvider(wallet!),\n            new PublicKey(sourceAccount)\n            );\n            if (info) {\n            mintName = info.mint.toBase58();\n            }\n        }\n        }\n        globalStore.setState({\n        ...state,\n        sourceMint: mintName,\n        graph: { ...state.graph },\n        });\n    };\n\n    return (\n        <Card>\n            <CardContent>\n              <h2>Node Id</h2>\n\n              <select\n                id=\"node-selector\"\n                className=\"form-select\"\n                size={10}\n                aria-label=\"size 3 select example\"\n                style={{ width: \"200px\" }}\n                onChange={(e) => {\n                  globalStore.setState({ selected: e.target.value });\n                }}\n              >\n                {Object.keys(state.graph).map(function (key, value) {\n                  return <option value={key}>{key}</option>;\n                })}\n              </select>\n            </CardContent>\n\n            <select\n              className=\"form-select\"\n              aria-label=\"Default select example\"\n              onChange={(e) => {\n                globalStore.setState({ new_action: e.target.value });\n              }}\n            >\n              {actions.map((value, index) => {\n                return <option value={value}>{value}</option>;\n              })}\n            </select>\n\n            <Button\n              variant=\"text\"\n              style={buttonStyle}\n              onClick={() => {\n                let node_id = state.new_action + \"-\" + state.counter.toString();\n                const init = getInitInputForActionType(\n                    state.new_action as ActionTypes\n                  );\n                  let new_node: NodeType = {\n                    input: init.input,\n                    // TODO: make a seperate fn\n                    next_actions: [\n                      ...Array(\n                        MallocSPLBuildActionMap[\n                          getActionTypeUIDFromVertex(\n                            state.new_action as ActionTypes\n                          )\n                        ].expectedNumberOfOutMints\n                      ),\n                    ].map((i) => INIT_NEXT_ACTION),\n                  };\n                  state.graph[node_id] = new_node;\n                  state.hiddenInputData[node_id] = init.hiddenData || {};\n                  globalStore.setState({\n                    ...state,\n                    selected: node_id,\n                    counter: state.counter + 1,\n                    graph: { ...state.graph },\n                  });\n                }}\n              >\n                +\n              </Button>\n              <Button\n                variant=\"text\"\n                style={buttonStyle}\n                onClick={() => {\n                  if (state.selected == \"SOURCE-0\") return;\n                  delete state.graph[state.selected];\n                  globalStore.setState({\n                    ...state,\n                    selected: \"SOURCE-0\",\n                    graph: { ...state.graph },\n                  });\n                }}\n              >\n                -\n              </Button>\n            </Card>\n    )\n}\n\nexport default NodeSelector\n","import React, { Ref, useRef } from \"react\";\nimport { makeStyles, Theme, createStyles } from \"@material-ui/core/styles\";\nimport Modal from \"@material-ui/core/Modal\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { useMemo } from \"react\";\nimport { useEffect } from \"react\";\nimport {\n  findAllAssociatedTokenAddress,\n  findAssociatedTokenAddress,\n  getMintInfo,\n  getTokenAccountInfo,\n  getTokenLists,\n} from \"../../utils/spl-tokens\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { SPLToken } from \"../../interfaces\";\nimport { shortenAddress } from \"../../utils/malloc\";\nimport { Provider } from \"@project-serum/anchor\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { isBundle } from \"typescript\";\nimport { useState } from \"react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { useStore } from \"react-stores\";\nimport { solanaSplStore } from \"../../state/flowchart-store\";\nimport { u64 } from \"@solana/spl-token\";\nimport { utils } from \"@malloc/sdk\";\n\nfunction getModalStyle() {\n  const top = 50;\n  const left = 50;\n\n  return {\n    top: `${top}%`,\n    left: `${left}%`,\n    transform: `translate(-${top}%, -${left}%)`,\n  };\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    paper: {\n      position: \"absolute\",\n      width: \"auto\",\n      backgroundColor: theme.palette.background.paper,\n      border: \"2px solid #000\",\n      boxShadow: theme.shadows[5],\n      padding: theme.spacing(2, 4, 3),\n    },\n  })\n);\n\nconst TokenLine = ({\n  tok,\n  setChoosen,\n}: {\n  tok: SPLToken;\n  setChoosen: () => void;\n}) => {\n  return (\n    <div\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: \"1fr 1fr 1fr 1fr 1fr\",\n        width: \"100%\",\n        gap: \"5px\",\n      }}\n    >\n      <button onClick={setChoosen}>Choose</button>\n      <div>{tok.info.name}</div>\n      <div>{shortenAddress(tok.info.mint.toBase58())}</div>\n      <div>\n        {shortenAddress(tok.account)}\n        {tok.balance ? \"\" : \" (currently nonexistent)\"}\n      </div>\n      <div>\n        {utils.tokens.toReadableNumber(\n          new u64(tok.balance || 0),\n          tok.info.decimals\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default function TokenAccountChooser(props: {\n  buttonText?: string;\n  onlyWithInitializedAccounts?: boolean;\n  onClose: (tok?: SPLToken) => void;\n  includeCustomTokenAccount?: boolean;\n}) {\n  const onlyWithInitializedAccounts = props.onlyWithInitializedAccounts ?? true;\n  const classes = useStyles();\n  // getModalStyle is not a pure function, we roll the style only on the first render\n  const [modalStyle] = React.useState(getModalStyle);\n  const [open, setOpen] = React.useState(false);\n  const [customTokenAccount, setCustomTokenAccount] = React.useState(\"\");\n  const [customMintAccount, setCustomMintAccount] = React.useState(\"\");\n  const wallet = useAnchorWallet();\n  // If it is -1, then the custom state is choosen\n  const [choosen, setChoosen] = useState(-1);\n  const solanaSplStoreHook = useStore(solanaSplStore);\n\n  const provider = getProvider(wallet!);\n\n  const loadTokens = async () => {\n    const tokenList = await getTokenLists(provider);\n    const associatedAddr = await findAllAssociatedTokenAddress(\n      wallet?.publicKey!,\n      tokenList.map((t) => t.address)\n    );\n\n    const bals = await Promise.all(\n      associatedAddr.map(async (addr) => {\n        const data = await getTokenAccountInfo(provider, addr);\n        return data?.amount;\n      })\n    );\n    const accounts = associatedAddr.map((addr, i) => {\n      return {\n        account: addr.toBase58(),\n        info: tokenList[i],\n        balance: bals[i],\n      };\n    });\n    const accountsFiltered = onlyWithInitializedAccounts\n      ? accounts.filter((i) => i.balance)\n      : accounts;\n    const accountsMapped = accountsFiltered.map((i) => {\n      return {\n        ...i,\n        info: {\n          ...i.info,\n          mint: new PublicKey(i.info.address),\n        },\n        balance: i.balance?.toString() || null,\n      };\n    });\n\n    solanaSplStore.setState({\n      ...solanaSplStoreHook,\n      derivedTokenAccounts: accountsMapped,\n    });\n  };\n\n  useEffect(() => {\n    loadTokens();\n  }, []);\n\n  const modalRef = useRef(null);\n\n  const handleOpen = () => {\n    loadTokens();\n    setOpen(true);\n  };\n\n  const handleClose = async () => {\n    if (!solanaSplStoreHook.derivedTokenAccounts) {\n      setOpen(false);\n      props.onClose();\n      return;\n    }\n    if (choosen >= 0)\n      props.onClose(solanaSplStoreHook.derivedTokenAccounts[choosen]);\n    else {\n      const choosenType = choosen === -1 ? \"TOKEN\" : \"MINT\";\n      if (\n        (choosenType === \"TOKEN\" && !customTokenAccount) ||\n        (choosenType === \"MINT\" && !customMintAccount)\n      ) {\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n\n      const tokenAccount =\n        choosenType === \"TOKEN\"\n          ? customTokenAccount\n          : (\n              await findAssociatedTokenAddress(\n                wallet!.publicKey,\n                customMintAccount\n              )\n            ).toBase58();\n      const tokAccountData = await getTokenAccountInfo(\n        provider,\n        new PublicKey(tokenAccount)\n      );\n      if (choosenType === \"TOKEN\" && !tokAccountData) {\n        alert(\"Looks like an invalid SPL Token Account was provided\");\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n      if (\n        choosenType === \"MINT\" &&\n        props.onlyWithInitializedAccounts !== false &&\n        !tokAccountData\n      ) {\n        alert(\n          \"Looks like there is no initialized associated account with this mint\"\n        );\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n      const mintAddr =\n        choosenType === \"TOKEN\"\n          ? tokAccountData!.mint\n          : new PublicKey(customMintAccount);\n\n      const mintInfo = await getMintInfo(provider, mintAddr);\n      if (!mintInfo) {\n        alert(\"Looks like the mint associated with this token is invalid\");\n        setOpen(false);\n        props.onClose();\n        return;\n      }\n      const bal = tokAccountData?.amount || new u64(0);\n      props.onClose({\n        balance: bal,\n        account: tokenAccount,\n        info: {\n          ...mintInfo,\n          mint: mintAddr,\n        },\n      });\n    }\n    setOpen(false);\n    props.onClose();\n  };\n\n  const body = (\n    <div\n      onBlur={handleClose}\n      className=\"wrapper\"\n      // TODO: this is a bit ghetto but react modal isn't working with the cells\n      onClick={(e) => e.currentTarget.blur()}\n      style={{\n        position: \"fixed\",\n        top: \"0\",\n        left: \"0\",\n        height: \"100vh\",\n        width: \"100vw\",\n        zIndex: 100,\n        display: \"grid\",\n        justifyItems: \"center\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n      }}\n    >\n      <div style={{ ...modalStyle }} className={classes.paper}>\n        <h2 id=\"simple-modal-title\">Choose a token account</h2>\n        <p id=\"simple-modal-description\">\n          Choose from either your associated token accounts or add a custom\n          address\n        </p>\n        <div\n          className=\"options\"\n          style={{ overflow: \"scroll\", maxHeight: \"70vh\" }}\n        >\n          <div\n            style={{\n              display: \"grid\",\n              gridTemplateColumns: \"1fr 1fr 1fr 1fr 1fr\",\n            }}\n          >\n            <span></span>\n            <div>Mint Name</div>\n            <div>Mint Address</div>\n            <div>Token Account Address</div>\n            <div>Amount</div>\n          </div>\n          {!solanaSplStoreHook.derivedTokenAccounts\n            ? \"Loading...\"\n            : solanaSplStoreHook.derivedTokenAccounts.map((tok, i) => (\n                <div\n                  key={`token-derived-account-${i}`}\n                  style={{\n                    padding: \"0.5rem\",\n                    border: choosen === i ? \"1px solid black\" : \"0px\",\n                  }}\n                >\n                  <TokenLine\n                    tok={tok}\n                    setChoosen={() => {\n                      setChoosen(i);\n                    }}\n                  />\n                  <br />\n                </div>\n              ))}\n          {/* TODO: add balance to the left of this once filled out */}\n          {props.includeCustomTokenAccount && (\n            <div\n              style={{\n                padding: \"0.5rem\",\n                border: choosen === -1 ? \"1px solid black\" : \"0px\",\n              }}\n            >\n              <TextField\n                label=\"Custom Token Account\"\n                value={customTokenAccount}\n                onChange={(e) => setCustomTokenAccount(e.target.value)}\n                onFocus={() => setChoosen(-1)}\n              />\n            </div>\n          )}\n          <p>Or</p>\n          <div\n            style={{\n              padding: \"0.5rem\",\n              border: choosen === -2 ? \"1px solid black\" : \"0px\",\n            }}\n          >\n            <TextField\n              label=\"Custom Mint Account\"\n              value={customMintAccount}\n              onChange={(e) => setCustomMintAccount(e.target.value)}\n              onFocus={() => setChoosen(-2)}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <div>\n      <button type=\"button\" onClick={handleOpen}>\n        {props.buttonText || \"Choose Token Account\"}\n      </button>\n\n      {/* <Modal\n        open={open}\n        ref={modalRef}\n        onClose={handleClose}\n        aria-labelledby=\"simple-modal-title\"\n        aria-describedby=\"simple-modal-description\"\n      > */}\n      {open && body}\n      {/* </Modal> */}\n    </div>\n  );\n}\n","import Input from \"@material-ui/core/Input\";\nimport { getVertexType } from \"src/utils/graph\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport Select from \"@mui/material/Select\";\nimport FocusTrap from \"focus-trap-react\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport {\n  CellBase,\n  DataEditorComponent,\n  DataEditorProps,\n} from \"react-spreadsheet\";\nimport { useStore } from \"react-stores\";\nimport { globalStore, MallocState } from \"src/globalStore\";\nimport { InputClassNames } from \"src/interfaces\";\nimport { getActionVertices } from \"src/utils/graph\";\nimport TokenAccountChooser from \"../tokens/TokenAccountChooser\";\n\nconst InputEditor = (\n  props: DataEditorProps<CellBase> & {\n    isWholeNumber?: boolean;\n    isFractionNumber?: boolean;\n  }\n) => {\n  return (\n    <Input\n      onChange={(e) => {\n        props.onChange({\n          ...props.cell,\n          value: props.isWholeNumber\n            ? parseInt(e.target.value).toString()\n            : e.target.value,\n        });\n      }}\n      value={props.cell?.value || \"\"}\n      type={props.isFractionNumber || props.isWholeNumber ? \"number\" : \"text\"}\n    />\n  );\n};\n\nconst TokenOrMintEditor = (\n  props: DataEditorProps<CellBase> & {\n    type: \"mint\" | \"token\";\n    onlyWithInitialized: boolean;\n  }\n) => {\n  return (\n    <div>\n      <TokenAccountChooser\n        buttonText={\"select\"}\n        onlyWithInitializedAccounts={props.onlyWithInitialized}\n        onClose={(splTok) => {\n          if (splTok) {\n            const value =\n              props.type === \"token\"\n                ? splTok.account\n                : splTok.info.mint.toBase58();\n            props.onChange({\n              ...props.cell,\n              value,\n            });\n          }\n        }}\n      />\n    </div>\n  );\n};\n\nconst ActionVertexEditor = (\n  props: DataEditorProps<CellBase> & {\n    nextActionMintIdx: number;\n  }\n) => {\n  const store = useStore(globalStore);\n  const vertices = getActionVertices(store.graph);\n  const [active, setActive] = useState(true);\n  const [pause, setPause] = useState(false);\n\n  const setState = (id: string) => {\n    props.onChange({ ...props.cell, value: id });\n    setActive(false);\n  };\n\n  return (\n    <div>\n      <FocusTrap active={active} paused={pause}>\n        <Select\n          labelId=\"demo-simple-select-label\"\n          id=\"demo-simple-select\"\n          value={props.cell?.value}\n          label=\"Age\"\n          style={{\n            height: \"20px\",\n          }}\n        >\n          {vertices.map((id) => {\n            return (\n              <span key={`select-opts-${id}`}>\n                <MenuItem\n                  style={{ zIndex: 100 }}\n                  value={id}\n                  onMouseOver={() => setPause(true)}\n                  onFocus={() => setState(id)}\n                >\n                  {id}\n                </MenuItem>\n              </span>\n            );\n          })}\n        </Select>\n      </FocusTrap>\n    </div>\n  );\n};\n\nexport const TableCellEditor: DataEditorComponent<CellBase> = (\n  props: DataEditorProps<CellBase>\n) => {\n  const className = (props.cell?.className || \"\").split(\"-\")[0];\n  switch (className) {\n    case InputClassNames.actionVertex:\n      const nextActionMintIdx = parseInt(\n        props.cell!.className!.split(\"-\")[1] || \"\"\n      );\n      return ActionVertexEditor({ ...props, nextActionMintIdx });\n    case InputClassNames.mintAccountOnlyInit:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"mint\",\n        onlyWithInitialized: true,\n      });\n    case InputClassNames.tokenAccountOnlyInit:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"token\",\n        onlyWithInitialized: true,\n      });\n    case InputClassNames.mintAccount:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"mint\",\n        onlyWithInitialized: false,\n      });\n    case InputClassNames.tokenAccount:\n      return TokenOrMintEditor({\n        ...props,\n        type: \"token\",\n        onlyWithInitialized: false,\n      });\n    case InputClassNames.other:\n      return InputEditor(props);\n    case InputClassNames.wholeNumber:\n      return InputEditor({ ...props, isWholeNumber: true });\n    case InputClassNames.fractionNumber:\n      return InputEditor({ ...props, isFractionNumber: true });\n    default:\n      return InputEditor(props);\n  }\n};\n","import React, { useState, FC } from \"react\";\nimport Card from \"@mui/material/Card\";\nimport CardActions from \"@mui/material/CardActions\";\nimport CardContent from \"@mui/material/CardContent\";\nimport Button from \"@mui/material/Button\";\nimport Spreadsheet from \"react-spreadsheet\";\n\nimport {\n  Input,\n  ActionEdge,\n  NodeType,\n  GraphType,\n  NextAction,\n  InputClassNames,\n  SourceNodeInput,\n} from \"src/interfaces\";\nimport { useStore } from \"react-stores\";\nimport {\n  globalStore,\n  setGlobalStoreFromFile,\n  SOURCE_NODE_ID,\n} from \"../globalStore\";\nimport { compileAndRunMallocSDK } from \"src/utils/sdk-interpelator\";\nimport { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\nimport {\n  getNextActionRow,\n  getSourceNodeAccount,\n  getVertexType,\n} from \"src/utils/graph\";\nimport { MallocSPLBuildActionMap } from \"@malloc/spl\";\nimport { TableCellEditor } from \"./table/table-cells\";\nimport { performUsdcAirdrop } from \"./usdc-airdrop/perform-usdc-airdrop\";\nimport { saveStringToFile } from \"src/utils/files\";\nimport { Satellite } from \"@material-ui/icons\";\nimport { getMintInfo, getTokenAccountInfo } from \"src/utils/spl-tokens\";\nimport { getProvider } from \"src/utils/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport {\n  getActionTypeUIDFromVertex,\n  getInitInputForActionType,\n  setHardCodedNextActions,\n} from \"src/utils/action-types\";\nimport { utils } from \"@malloc/sdk\";\n\nconst NodeInfo: FC = () => {\n  const state = useStore(globalStore);\n  const wallet = useAnchorWallet();\n\n  const setInput = async (data: Input) => {\n    state.graph[state.selected].input = data as Input;\n    let mintName = state.sourceMint;\n    if (state.selected === SOURCE_NODE_ID) {\n      const sourceAccount = getSourceNodeAccount(data as SourceNodeInput);\n      if (sourceAccount) {\n        const info = await getTokenAccountInfo(\n          getProvider(wallet!),\n          new PublicKey(sourceAccount)\n        );\n        if (info) {\n          mintName = info.mint.toBase58();\n        }\n      }\n    }\n    globalStore.setState({\n      ...state,\n      sourceMint: mintName,\n      graph: { ...state.graph },\n    });\n  };\n\n  return (\n    <Card>\n      <CardContent>\n        <h2>{state.selected} info</h2>\n\n        {state.selected === SOURCE_NODE_ID && (\n          <p>Source Mint: {state.sourceMint}</p>\n        )}\n\n        <h5>Input</h5>\n        <Spreadsheet\n          data={state.graph[state.selected].input}\n          onChange={(data) => setInput(data as Input)}\n          DataEditor={TableCellEditor}\n        />\n\n        <h5>Next Action</h5>\n        {state.graph[state.selected].next_actions.map(\n          (next_action_by_mint, i) => {\n            return (\n              <div key={`next-action-${i}`}>\n                <Spreadsheet\n                  data={state.graph[state.selected].next_actions[i]}\n                  onChange={(_data) => {\n                    state.graph[state.selected].next_actions[i] =\n                      setHardCodedNextActions(_data as NextAction[]);\n                    globalStore.setState({\n                      ...state,\n                      graph: { ...state.graph },\n                    });\n                    console.log(state.graph[state.selected].next_actions);\n                  }}\n                  DataEditor={TableCellEditor}\n                />\n                <CardActions>\n                  <Button\n                    variant=\"outlined\"\n                    onClick={() => {\n                      state.graph[state.selected].next_actions[i] = [\n                        ...state.graph[state.selected].next_actions[i],\n                        getNextActionRow(i),\n                      ];\n                      globalStore.setState({\n                        ...state,\n                        graph: { ...state.graph },\n                      });\n                      console.log(\n                        \"new action\",\n                        state.graph[state.selected].next_actions\n                      );\n                    }}\n                  >\n                    New Action\n                  </Button>\n\n                  <Button\n                    variant=\"outlined\"\n                    onClick={() => {\n                      if (state.graph[state.selected].next_actions.length > 2) {\n                        let temp = state.graph[state.selected].next_actions;\n                        state.graph[state.selected].next_actions = temp.slice(\n                          0,\n                          temp.length - 1\n                        );\n                        globalStore.setState({\n                          ...state,\n                          graph: { ...state.graph },\n                        });\n                        console.log(\n                          \"remove action\",\n                          state.graph[state.selected].next_actions\n                        );\n                      }\n                    }}\n                  >\n                    Remove Action\n                  </Button>\n                </CardActions>\n              </div>\n            );\n          }\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default NodeInfo;\n","import React, { useState, useEffect, useRef } from 'react'\nimport { Swatches } from \"d3-color\"\nimport * as d3 from \"d3\";\n\n\nconst GraphVisualizer = (graph) => {\n\n    const [data, setData] = useState([5, 3, 6, 1, 2]);\n\n    const svgRef = useRef();\n\n    useEffect(() => {\n        // ...D3 code\n\n        // DATA\n\n        let nodes = [\n            {id: \"Microsoft\"},\n            {id: \"Amazon\"},\n            {id: \"HTC\"},\n            \n        ]\n\n        let links = [\n            {\n                source: \"Microsoft\",\n                target: \"Amazon\",\n                type: \"licensing\"\n            },\n            {\n                source: \"Microsoft\",\n                target: \"HTC\",\n                type: \"licensing\"\n            }\n        ]\n\n        let types = [\n            \"licensing\",\n        ]\n\n        const data = {\n            nodes,\n            links\n        }\n\n        // STYLING\n\n        let [width, height] = [300, 300]\n        let color = d3.scaleOrdinal(types, d3.schemeCategory10)\n\n        let linkArc = (d) => {\n            const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);\n            return `\n              M${d.source.x},${d.source.y}\n              A${r},${r} 0 0,1 ${d.target.x},${d.target.y}\n            `;\n        }\n\n        let drag = simulation => {\n  \n            function dragstarted(event, d) {\n              if (!event.active) simulation.alphaTarget(0.3).restart();\n              d.fx = d.x;\n              d.fy = d.y;\n            }\n            \n            function dragged(event, d) {\n              d.fx = event.x;\n              d.fy = event.y;\n            }\n            \n            function dragended(event, d) {\n              if (!event.active) simulation.alphaTarget(0);\n              d.fx = null;\n              d.fy = null;\n            }\n            \n            return d3.drag()\n                .on(\"start\", dragstarted)\n                .on(\"drag\", dragged)\n                .on(\"end\", dragended);\n          }\n\n        links = data.links.map(d => Object.create(d));\n        nodes = data.nodes.map(d => Object.create(d));\n      \n        const simulation = d3.forceSimulation(nodes)\n            .force(\"link\", d3.forceLink(links).id(d => d.id))\n            .force(\"charge\", d3.forceManyBody().strength(-400))\n            .force(\"x\", d3.forceX())\n            .force(\"y\", d3.forceY());\n      \n        const svg = d3.select(svgRef.current)\n            .attr(\"viewBox\", [-width / 2, -height / 2, width, height])\n            .style(\"font\", \"12px sans-serif\");\n      \n        // Per-type markers, as they don't inherit styles.\n        svg.append(\"defs\").selectAll(\"marker\")\n          .data(types)\n          .join(\"marker\")\n            .attr(\"id\", d => `arrow-${d}`)\n            .attr(\"viewBox\", \"0 -5 10 10\")\n            .attr(\"refX\", 15)\n            .attr(\"refY\", -0.5)\n            .attr(\"markerWidth\", 6)\n            .attr(\"markerHeight\", 6)\n            .attr(\"orient\", \"auto\")\n          .append(\"path\")\n            .attr(\"fill\", color)\n            .attr(\"d\", \"M0,-5L10,0L0,5\");\n      \n        const link = svg.append(\"g\")\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", 1.5)\n          .selectAll(\"path\")\n          .data(links)\n          .join(\"path\")\n            .attr(\"stroke\", d => color(d.type))\n            .attr(\"marker-end\", d => `url(${new URL(`#arrow-${d.type}`, location)})`);\n      \n        const node = svg.append(\"g\")\n            .attr(\"fill\", \"currentColor\")\n            .attr(\"stroke-linecap\", \"round\")\n            .attr(\"stroke-linejoin\", \"round\")\n          .selectAll(\"g\")\n          .data(nodes)\n          .join(\"g\")\n            .call(drag(simulation));\n      \n        node.append(\"circle\")\n            .attr(\"stroke\", \"white\")\n            .attr(\"stroke-width\", 1.5)\n            .attr(\"r\", 4);\n      \n        node.append(\"text\")\n            .attr(\"x\", 8)\n            .attr(\"y\", \"0.31em\")\n            .text(d => d.id)\n          .clone(true).lower()\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke\", \"white\")\n            .attr(\"stroke-width\", 3);\n      \n        simulation.on(\"tick\", () => {\n          link.attr(\"d\", linkArc);\n          node.attr(\"transform\", d => `translate(${d.x},${d.y})`);\n        });\n        \n\n    }, []);\n\n    const update = () => {\n        const newData = data.map(value => value + 5);\n        setData(newData);\n    };\n\n    const removeLast = () => {\n        const newData = [...data];\n        newData.pop();\n        setData(newData);\n    };\n\n    return (\n        <div style={{ border: \"2px solid black\", padding: \"10px\", width: \"300px\" }}>\n          <svg ref={svgRef}></svg>\n          <br />\n          <button onClick={update}>Update</button>\n          <br />\n          <button onClick={removeLast}>Remove</button>\n        </div>\n    );\n}\n\nexport default GraphVisualizer\n","import { PublicKey } from \"@solana/web3.js\";\n\nexport const frontendErrorTypeID = \"MALLOC_FLOWCHART_ERROR\";\n\nexport type FrontendError = {\n  type: \"MALLOC_FLOWCHART_ERROR\";\n  msg: string;\n  fullError?: any;\n};\n\nexport const handleError = (e: any) => {\n  console.error(e)\n  if (e?.errorType === frontendErrorTypeID) {\n    const eCast = e as FrontendError;\n    alert(eCast.msg)\n    if(eCast.fullError) throw eCast.fullError\n  } else {\n    alert(`An unexpected error occured: ${e}`)\n    throw e;\n  }\n};\n\nexport const ErrorGenerator = {\n  TOKEN_ACCOUNT_DOES_NOT_EXIST: (tokAccount: PublicKey | string) =>\n    newFrontendError(\n      `The token account ${tokAccount.toString()} does not exist`\n    ),\n  INVALID_AMOUNT_INPUT: (amount: string) =>\n    newFrontendError(`${amount} is not a valid number for the input`),\n  MINT_ACCOUNT_DOES_NOT_EXIST: (\n    mintAccount: PublicKey | string,\n    tokAccount?: PublicKey | string\n  ) =>\n    newFrontendError(\n      tokAccount\n        ? `The mint ${mintAccount.toString()} found from token ${tokAccount.toString()} does not exist`\n        : `The mint ${mintAccount.toString()} does not exist`\n    ),\n};\n\nconst newFrontendError = (msg: string, e?: any) => {\n  return {\n    msg,\n    fullError: e,\n    type: \"MALLOC_FLOWCHART_ERROR\",\n  } as FrontendError;\n};\n","import {\n  Action,\n  utils as mallocUtils,\n  BuildEphemeralTxsInstr,\n  builder,\n  MallocSdk,\n  NonUserSpecificConstruction,\n  NonUserSpecificConstructionAction,\n  ActionMetadata,\n  utils,\n} from \"@malloc/sdk\";\nimport { BN, Provider } from \"@project-serum/anchor\";\nimport { AnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getConstants } from \"src/config/constants\";\nimport {\n  ActionTypes,\n  getGlobalStore,\n  globalStore,\n  SOURCE_NODE_ID,\n} from \"src/globalStore\";\nimport {\n  GraphType,\n  HiddenInputData,\n  Input,\n  NodeType,\n  SourceNodeInput,\n} from \"src/interfaces\";\nimport { getProvider } from \"./anchor\";\nimport { ErrorGenerator, handleError } from \"./errors\";\nimport {\n  getAllVertices,\n  getNextVertices,\n  getSourceNode,\n  getSourceNodeAccount,\n  getSourceNodeAmount,\n  getVertexType,\n} from \"./graph\";\nimport { getMintInfo, getTokenAccountInfo } from \"./spl-tokens\";\nimport {\n  MallocSPLBuildActionMap,\n  SwapAction,\n  TransferAction,\n} from \"@malloc/spl\";\nimport { GroupAddSharp } from \"@material-ui/icons\";\nimport {\n  getActionPIDFromVertex,\n  getActionTypeUIDFromVertex,\n} from \"./action-types\";\n\nconst PID = new PublicKey(getConstants().MALLOC_PROGRAM_ID);\nconst getMallocSdk = (wallet: AnchorWallet) =>\n  new MallocSdk(PID, getProvider(wallet));\n\nconst getAllIncomingVertexIds = (actionId: string, graph: GraphType) =>\n  getAllVertices(graph).filter((v) =>\n    getNextVertices(graph, v).some((nextEdgeSet) =>\n      nextEdgeSet.map((i) => i.id).includes(actionId)\n    )\n  );\n\nconst getInputFromActionInput = (\n  actionInput: Input,\n  hiddenInputData: any\n): any => {\n  const ret = {} as any;\n  actionInput.map((inpItem) => {\n    ret[inpItem[0].value] = inpItem[1].value;\n  });\n  return { ...ret, ...hiddenInputData };\n};\n\nconst getNextNodes = (\n  allActionIds: string[],\n  actionId: string,\n  graph: GraphType\n): ActionMetadata[\"nextNodes\"] => {\n  const nextActions = getNextVertices(graph, actionId);\n\n  const groupedByMints: ActionMetadata[\"nextNodes\"] = nextActions.map(\n    (nextActionSet) => {\n      return nextActionSet.map((next) => {\n        return {\n          actionIdx: allActionIds.indexOf(next.id),\n          fraction: next.amount,\n        };\n      });\n    }\n  );\n\n  return groupedByMints;\n};\n\nconst getActionData = (\n  actionId: string,\n  allActionIds: string[],\n  graph: GraphType,\n  hiddenInputData: HiddenInputData\n): NonUserSpecificConstructionAction => {\n  const incomingVertices = getAllIncomingVertexIds(actionId, graph);\n\n  const nextNodes: ActionMetadata[\"nextNodes\"] = getNextNodes(\n    allActionIds,\n    actionId,\n    graph\n  );\n\n  const vertexType = getVertexType(actionId);\n  return {\n    actionTypeUID: getActionTypeUIDFromVertex(vertexType),\n    buildActionInputs: getInputFromActionInput(\n      graph[actionId].input,\n      hiddenInputData[actionId]\n    ),\n    actionPID: getActionPIDFromVertex(vertexType),\n    actionMetadata: {\n      ripeAmount: incomingVertices.length,\n      nextNodes,\n    },\n  };\n};\n\nconst _buildNonUserSpecificConstruction = async (\n  g: GraphType,\n  hiddenInputDatas: HiddenInputData,\n  actionVertices: string[],\n  initialSplits: number[],\n  initialActionIndices: number[],\n  amount: string\n): Promise<NonUserSpecificConstruction> => {\n  const vertices = getAllVertices(g);\n\n  return {\n    actionDatas: actionVertices.map((v) =>\n      getActionData(v, actionVertices, g, hiddenInputDatas)\n    ),\n    initialSplits,\n    initialActionIndices,\n    amount,\n  };\n};\n\nconst getInitialInfo = async (\n  g: GraphType,\n  inAccount: PublicKey,\n  actionVertices: string[],\n  provider: Provider\n) => {\n  const sourceNode = getSourceNode(g);\n  const tokenInInfo = await getTokenAccountInfo(provider, inAccount);\n  if (!tokenInInfo) {\n    throw ErrorGenerator.TOKEN_ACCOUNT_DOES_NOT_EXIST(inAccount);\n  }\n\n  const mint = tokenInInfo.mint;\n  const mintInfo = await getMintInfo(provider, mint);\n\n  if (!mintInfo) {\n    throw ErrorGenerator.MINT_ACCOUNT_DOES_NOT_EXIST(mint, inAccount);\n  }\n\n  let amountInF: number;\n  try {\n    amountInF = parseFloat(\n      getSourceNodeAmount(sourceNode.input as SourceNodeInput)\n    );\n  } catch (e) {\n    throw ErrorGenerator.INVALID_AMOUNT_INPUT(\n      getSourceNodeAmount(sourceNode.input as SourceNodeInput)\n    );\n  }\n  const amountIn = utils.tokens.fromReadableNumber(\n    amountInF,\n    mintInfo.decimals\n  );\n  const nextFromSource = getNextVertices(g, SOURCE_NODE_ID)[0];\n\n  return {\n    amount: amountIn,\n    initialMint: mint,\n    initialSplits: nextFromSource.map((n) => n.amount),\n    initialActionIndices: nextFromSource.map((n) =>\n      actionVertices.indexOf(n.id)\n    ),\n  };\n};\n\nconst compileStateIntoSDKInput = async (\n  wallet: AnchorWallet,\n  preferredTokenAccounts?: mallocUtils.tokens.PreferredTokenAccounts\n): Promise<BuildEphemeralTxsInstr> => {\n  const { graph, hiddenInputData: hiddenData } = getGlobalStore();\n\n  const inAccount = new PublicKey(\n    getSourceNodeAccount(getSourceNode(graph).input as SourceNodeInput)\n  );\n\n  const provider = getProvider(wallet);\n  const vertices = getAllVertices(graph);\n  const actionVertices = vertices.slice(1);\n  const { initialSplits, initialActionIndices, initialMint, amount } =\n    await getInitialInfo(graph, inAccount, actionVertices, provider);\n\n  // Get the non specific\n  const nonUserSpecific = await _buildNonUserSpecificConstruction(\n    graph,\n    hiddenData,\n    actionVertices,\n    initialSplits,\n    initialActionIndices,\n    amount\n  );\n\n  const construction = await builder.buildConstructionFromNonUserSpecific(\n    nonUserSpecific,\n    MallocSPLBuildActionMap,\n    inAccount.toBase58(),\n    initialMint.toBase58(),\n    provider\n  );\n\n  return {\n    actions: construction.actions,\n    initialSplits: construction.initialSplits,\n    amount: construction.amount,\n    initialActionIndices: construction.initialActionIndices,\n    amountInAccount: inAccount,\n    opts: { preferredTokenAccounts },\n  };\n};\n\nconst run = async (\n  inp: BuildEphemeralTxsInstr,\n  wallet: AnchorWallet\n): Promise<string[]> => {\n  const sdk = getMallocSdk(wallet);\n  const data = await sdk.buildTxs(inp);\n  return await sdk.sendRequests(data, {\n    prepareCommitment: {\n      skipPreflight: false,\n      preflightCommitment: \"single\",\n      commitment: \"single\",\n    },\n    actionCommitment: {\n      skipPreflight: false,\n      preflightCommitment: \"single\",\n      commitment: \"single\",\n    },\n  });\n};\n\nexport const compileAndRunMallocSDK = async (wallet: AnchorWallet) => {\n  try {\n    const buildInst = await compileStateIntoSDKInput(wallet);\n    const txs = await run(buildInst, wallet);\n    alert(`DONE AND SUCCESSFUL with tx: ${txs}`);\n  } catch (e) {\n    handleError(e);\n  }\n};\n","import { Wallet } from \"@project-serum/anchor\";\nimport { createTokenAccount, Provider } from \"@project-serum/common\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { Connection, Keypair, PublicKey, Transaction } from \"@solana/web3.js\";\nimport { getConstants } from \"../../config/constants\";\n\nconst richUSDCAirdroperSK = new Uint8Array([\n  8, 57, 204, 222, 105, 129, 113, 8, 245, 54, 20, 45, 122, 175, 82, 37, 32, 44,\n  46, 6, 54, 35, 168, 208, 213, 194, 164, 50, 97, 226, 134, 119, 136, 196, 213,\n  189, 243, 233, 16, 53, 22, 220, 245, 4, 17, 203, 251, 233, 20, 7, 178, 5, 36,\n  19, 66, 89, 210, 148, 19, 225, 117, 61, 214, 253,\n]);\n\nconst richUSDCSigner = new Wallet(Keypair.fromSecretKey(richUSDCAirdroperSK));\n\nconst getRichUsdcProvider = (endpointURL: string) =>\n  new Provider(new Connection(endpointURL), richUSDCSigner, {\n    commitment: \"confirmed\",\n  });\n\nexport const performUsdcAirdrop = async (userAddr: PublicKey) => {\n  try {\n    const tokAccount = await tryCreateAssociatedAccount(\n      new PublicKey(getConstants().demo.FAKE_USDC),\n      userAddr,\n      getRichUsdcProvider(getConstants().solana.RPC)\n    );\n    await airdrop(new PublicKey(getConstants().demo.FAKE_USDC_GD), [\n      tokAccount,\n    ]);\n    alert(\"Done with your airdrop\");\n  } catch (e) {\n    console.error(e);\n    alert(`An error occurred with the airdrop ${JSON.stringify(e)}`);\n  }\n};\n\nconst tryCreateAssociatedAccount = async (\n  mint: PublicKey,\n  account: PublicKey,\n  provider: Provider\n): Promise<PublicKey> => {\n  const associated = (\n    await PublicKey.findProgramAddress(\n      [\n        account.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(mint).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n  const data = await provider.connection.getAccountInfo(associated);\n  if (!data) {\n    const instr = Token.createAssociatedTokenAccountInstruction(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      mint,\n      associated,\n      account,\n      provider.wallet.publicKey\n    );\n    const tx = new Transaction();\n    tx.add(instr);\n    await provider.send(tx, []);\n    return associated;\n  }\n  return associated;\n};\n\nconst airdrop = async (\n  gdUsdc: PublicKey,\n  airDropToTokenAccounts: PublicKey[]\n) => {\n  const decimals = 6;\n  const amountAirdrop = 4 * 10 ** decimals;\n\n  const transferTxs: Transaction = new Transaction();\n  airDropToTokenAccounts.map((tokAccount) => {\n    transferTxs.add(\n      Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        gdUsdc,\n        tokAccount,\n        richUSDCSigner.publicKey,\n        [],\n        amountAirdrop\n      )\n    );\n  });\n\n  await getRichUsdcProvider(getConstants().solana.RPC).send(transferTxs, [], {\n    skipPreflight: true,\n  });\n};\n","import React, { useState, FC } from 'react';\nimport Card from '@mui/material/Card';\nimport CardActions from '@mui/material/CardActions';\nimport CardContent from '@mui/material/CardContent';\nimport Button from '@mui/material/Button';\nimport GraphVisualizer from './graph-visualizer';\n\nimport {\n    Input,\n    ActionEdge,\n    NodeType,\n    GraphType,\n    NextAction,\n    InputClassNames,\n    SourceNodeInput,\n  } from \"src/interfaces\";\n  import { useStore } from \"react-stores\";\n  import {\n    ActionTypes,\n    ACTION_TYPES,\n    downloadGlobalStore,\n    globalStore,\n    INIT_NEXT_ACTION,\n    setGlobalStoreFromFile,\n    SOURCE_NODE_ID,\n  } from \"../globalStore\";\n  import {\n    compileAndRunMallocSDK,\n  } from \"src/utils/sdk-interpelator\";\n  import { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\n  import {\n    getSourceNodeAccount,\n  } from \"src/utils/graph\";\n  import { MallocSPLBuildActionMap } from \"@malloc/spl\";\n  import { TableCellEditor } from \"./table/table-cells\";\n  import { performUsdcAirdrop } from \"./usdc-airdrop/perform-usdc-airdrop\";\n  import { saveStringToFile } from \"src/utils/files\";\n  import { Satellite } from \"@material-ui/icons\";\n  import { getMintInfo, getTokenAccountInfo } from \"src/utils/spl-tokens\";\n  import { getProvider } from \"src/utils/anchor\";\n  import { PublicKey } from \"@solana/web3.js\";\n  import { getActionTypeUIDFromVertex, getInitInputForActionType } from \"src/utils/action-types\";\n\nconst NodeVisualizer = () => {\n\n    const state = useStore(globalStore);\n    const wallet = useAnchorWallet();\n\n    // Control panel loaders\n    const [loadingAirdrop, setLoadingAirdrop] = useState(false);\n    const [loadingCompileAndRun, setLoadingCompileAndRun] = useState(false);\n    // End control panel loaders\n\n    return (\n        <Card>\n            <CardContent>\n              <h2>Visualizer</h2>\n              <GraphVisualizer />\n            </CardContent>\n            <CardActions>\n              <Button\n                variant=\"outlined\"\n                disabled={loadingCompileAndRun}\n                onClick={() => {\n                  setLoadingCompileAndRun(true);\n                  compileAndRunMallocSDK(wallet!)\n                    .then((_) => setLoadingCompileAndRun(false))\n                    .catch((e) => setLoadingCompileAndRun(false));\n                }}\n              >\n                {loadingCompileAndRun ? \"Running...\" : \"Compile and Run\"}\n              </Button>\n              <Button\n                variant=\"outlined\"\n                onClick={() => {\n                  setLoadingAirdrop(true);\n                  performUsdcAirdrop(wallet!.publicKey).then((_) =>\n                    setLoadingAirdrop(false)\n                  );\n                }}\n                disabled={loadingAirdrop}\n              >\n                {loadingAirdrop ? \"Loading Airdrop...\" : \"Airdrop Fake USDC\"}\n              </Button>\n              <Button\n                variant=\"outlined\"\n                onClick={() => setGlobalStoreFromFile()}\n              >\n                Import\n              </Button>\n              <Button variant=\"outlined\" onClick={() => downloadGlobalStore()}>\n                Export\n              </Button>\n            </CardActions>\n          </Card>\n    )\n}\n\nexport default NodeVisualizer\n","import React, { useState, FC } from \"react\";\nimport Card from \"@mui/material/Card\";\n// import CardActions from \"@mui/material/CardActions\";\n// import CardContent from \"@mui/material/CardContent\";\n// import Button from \"@mui/material/Button\";\n\nimport NodeSelector from './node-selector';\nimport NodeInfo from './node-info';\nimport NodeVisualizer from './node-visualizer';\n\nconst TableGUI: FC = () => {\n\n    return (\n        <div style={{ width: '100%', display: 'flex', justifyContent: 'center', gap: '10px'}}>\n            <Card>\n                <div style={{ width: '100%', display: 'flex', justifyContent: 'space-around', alignItems: 'flex-start', gap: '10px'}}>\n                    <NodeSelector />\n                    <NodeInfo />\n                    <NodeVisualizer />\n                </div>\n            </Card>\n        </div>\n  );\n};\n\nexport default TableGUI;\n","import { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport Countdown from \"react-countdown\";\nimport { Button, CircularProgress, Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\n\nimport * as anchor from \"@project-serum/anchor\";\n\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\n\nimport {\n  awaitTransactionSignatureConfirmation,\n  shortenAddress,\n} from \"./utils/malloc\";\nimport { useStore } from \"react-stores\";\nimport LoadingTX from \"./components/tx-handler/LoadingTX\";\nimport TableGUI from \"./components/tablegui\";\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nconst CounterText = styled.span``; // add your styles here\n\nexport interface HomeProps {\n  config: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  txTimeout: number;\n}\n\nconst Home = (props: HomeProps) => {\n  const [balance, setBalance] = useState<number>();\n  const [isActive, setIsActive] = useState(false); // true when countdown completes\n  const [isSoldOut, setIsSoldOut] = useState(false); // true when items remaining is zero\n  const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n\n  const wallet = useWallet();\n\n  useEffect(() => {\n    (async () => {\n      if (wallet?.publicKey) {\n        const balance = await props.connection.getBalance(wallet.publicKey);\n        setBalance(balance / LAMPORTS_PER_SOL);\n      }\n    })();\n  }, [wallet, props.connection]);\n\n  return (\n    <main>\n      {wallet.connected && (\n        <p style={{ marginTop: 0 }}>\n          Address: {shortenAddress(wallet.publicKey?.toBase58() || \"\")}\n        </p>\n      )}\n\n      {wallet.connected && (\n        <p>Balance: {(balance || 0).toLocaleString()} SOL</p>\n      )}\n      {wallet.connected && \"WALLET CONNECTED\"}\n      {!wallet.connected && <ConnectButton>Connect Wallet</ConnectButton>}\n      <Snackbar\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n\n      {wallet.connected && <TableGUI />}\n    </main>\n  );\n};\n\ninterface AlertState {\n  open: boolean;\n  message: string;\n  severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nconst renderCounter = ({ days, hours, minutes, seconds, completed }: any) => {\n  return (\n    <CounterText>\n      {hours} hours, {minutes} minutes, {seconds} seconds\n    </CounterText>\n  );\n};\n\nexport default Home;\n","import \"./App.css\";\nimport { useMemo } from \"react\";\n\nimport Home from \"./Home\";\n\nimport * as anchor from \"@project-serum/anchor\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n  ConnectionProvider,\n  WalletProvider,\n} from \"@solana/wallet-adapter-react\";\n\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\nimport { getConstants } from \"./config/constants\";\n\nconst config = new anchor.web3.PublicKey(getConstants().MALLOC_PROGRAM_ID);\n\nconst network = getConstants().solana.NETWORK;\n\nconst rpcHost = getConstants().solana.RPC;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst txTimeout = 30000; // milliseconds (confirm this works for your project)\n\nconst App = () => {\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [getPhantomWallet(), getSolflareWallet(), getSolletWallet()],\n    []\n  );\n\n  return (\n    <ConnectionProvider endpoint={endpoint}>\n      <WalletProvider wallets={wallets} autoConnect>\n        <WalletDialogProvider>\n          <Home\n            config={config}\n            connection={connection}\n            txTimeout={txTimeout}\n          />\n        </WalletDialogProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { PublicKey } from \"@solana/web3.js\";\n\nexport enum Side {\n  Bid = 0,\n  Ask = 1,\n}\n\nexport interface SwapAccounts {\n  market: {\n    market: PublicKey;\n    requestQueue: PublicKey;\n    eventQueue: PublicKey;\n    bids: PublicKey;\n    asks: PublicKey;\n    coinVault: PublicKey;\n    pcVault: PublicKey;\n    vaultSigner: PublicKey;\n    // User params.\n    openOrders: PublicKey;\n    orderPayerTokenAccount: PublicKey;\n    coinWallet: PublicKey;\n  };\n  pcWallet: PublicKey;\n  authority: PublicKey;\n  dexProgram: PublicKey;\n  tokenProgram: PublicKey;\n  rent: PublicKey;\n}\n\nexport enum SwapInstructionByte {\n  BasicSwap = 0,\n}\n","export const CONSTRUCTION_ACCOUNT_SIZE = 2e4; // Around 3 kilobytes\nconst ONE_HOUR_MS = 1000 * 60 * 60;\nconst HOURS_PER_EPOCH = 48;\nexport const LIVE_N_EPOCHS = 3;\nexport const LIFETIME_RESULT_ACCOUNT_MS = ONE_HOUR_MS * (HOURS_PER_EPOCH * LIVE_N_EPOCHS); // Has to be more than 1 epoch, lets be sage\nexport const LIFETIME_CONSTRUCTION_ACCOUNT_MS =\n  ONE_HOUR_MS * (HOURS_PER_EPOCH * LIVE_N_EPOCHS);\n\n// Rent constants from https://docs.solana.com/developing/programming-model/accounts\n// TODO: should this be from a dynamic value?\nexport const LAMPORTS_PER_EPOCH = 19.055;\nexport const MS_PER_EPOCH = ONE_HOUR_MS * HOURS_PER_EPOCH;\n","import { BN, Instruction } from \"@project-serum/anchor\";\nimport { Provider, Wallet } from \"../../../../../../anchor/ts\";\nimport { transfer } from \"@project-serum/serum/lib/token-instructions\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport {\n  Account,\n  Connection,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { Action } from \"../interfaces\";\nimport { createTokenAccount, SendTxRequest } from \"@project-serum/common\";\n\nexport const tryCreateAssociatedAccountInst = async (\n  mint: PublicKey,\n  owner: PublicKey,\n  connection: Connection,\n  payer: PublicKey\n): Promise<{\n  associateTokAccount: PublicKey;\n  instr?: TransactionInstruction;\n}> => {\n  const associated = (\n    await PublicKey.findProgramAddress(\n      [\n        owner.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(mint).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n  const data = await connection.getAccountInfo(associated);\n  if (!data) {\n    const inst = Token.createAssociatedTokenAccountInstruction(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      new PublicKey(mint),\n      associated,\n      owner,\n      payer\n    );\n    return {\n      instr: inst,\n      associateTokAccount: associated,\n    };\n  } else {\n    return {\n      associateTokAccount: associated,\n    };\n  }\n};\n\nexport const tryCreateAssociatedAccount = async (\n  mint: PublicKey,\n  owner: PublicKey,\n  provider: Provider\n) => {\n  const { associateTokAccount, instr } = await tryCreateAssociatedAccountInst(\n    mint,\n    owner,\n    provider.connection,\n    provider.wallet.publicKey\n  );\n  if (!instr) return associateTokAccount;\n  const tx = new Transaction();\n  tx.add(instr);\n  await provider.send(tx);\n  return associateTokAccount;\n};\n\nexport interface AccountByMint {\n  [mint: string]: { publicKey: PublicKey };\n}\n\nexport const transferToTx = async (\n  source: PublicKey,\n  destination: PublicKey,\n  amount: BN,\n  authority: Signer | Wallet\n): Promise<SendTxRequest> => {\n  const signer = (authority as Signer).secretKey ? [authority as Account] : [];\n  const inst = transfer({\n    source,\n    destination,\n    amount,\n    owner: authority.publicKey,\n  });\n  const tx = new Transaction();\n  tx.add(inst);\n  return { tx, signers: signer };\n};\n\nexport type PreferredTokenAccounts = { [mint: string]: PublicKey };\n\n/**\n * Get the token account which the malloc sdk will use for a mint\n *\n * @param preferredTokenAccounts - a map of mints to token accounts which the caller would prefer to use per mint. If the account does not exist,\n * and is needed it will be created in the the returned txs\n */\nexport const getTokenAccountUsedByMalloc = async (\n  tokenAuthority: PublicKey,\n  mintAccount: PublicKey,\n  preferredTokenAccounts?: PreferredTokenAccounts\n): Promise<PublicKey> => {\n  if (\n    preferredTokenAccounts &&\n    preferredTokenAccounts[mintAccount.toBase58()]\n  ) {\n    return preferredTokenAccounts[mintAccount.toBase58()];\n  }\n  return await findAssociatedTokenAddress(tokenAuthority, mintAccount);\n};\n\n/**\n * Takes in a mapping of mints to token accounts. If a token account has yet to exist, one will be made\n * which is associated to the authority's address\n *\n * @param preferredTokenAccounts - a map of mints to token accounts which the caller would prefer to use per mint. If the account does not exist,\n * and is needed it will be created in the the returned txs\n */\nexport const createTokenAccountsForActions = async (\n  provider: Provider,\n  tokenAuthority: Signer | Wallet,\n  actions: Action[],\n  fundingAccount: Signer | Wallet,\n  preferredTokenAccounts?: PreferredTokenAccounts\n): Promise<{ accounts: AccountByMint; txs: SendTxRequest[] }> => {\n  const mints = getMintsNoDuplicates(\n    actions\n      .map((a) => {\n        const mints = [];\n        if (a.tokenCreationOptions?.skipOutTokenCreations || false) {\n          const skipIdxs = a.tokenCreationOptions.skipOutTokenCreations;\n          console.log(skipIdxs);\n          // Skip all the mints which are included by the skipIdxs\n          a.tokenMintOuts.forEach((mint, i) => {\n            if (!skipIdxs.includes(i)) mints.push(mint);\n          });\n        } else {\n          mints.push(...a.tokenMintOuts);\n        }\n        if (a.tokenCreationOptions?.skipInTokenCreation === true) {\n        } else {\n          mints.push(a.tokenMintIn);\n        }\n        return mints;\n      })\n      .flat()\n  );\n  console.log(mints);\n\n  let accounts: AccountByMint = {};\n  for (let i = 0; i < mints.length; i++) {\n    const mint = mints[i];\n    if ((preferredTokenAccounts || {})[mint])\n      accounts[mint] = { publicKey: preferredTokenAccounts[mint] };\n    // create the token account if not provided\n    else {\n      const pk = await findAssociatedTokenAddress(\n        tokenAuthority.publicKey,\n        mint\n      );\n      accounts[mint] = {\n        publicKey: pk, // TODO: check that this account does not yet exist\n      };\n    }\n  }\n\n  const createTokTx = await Promise.all(\n    mints.map(async (mint) => {\n      const associatedToSignerAccount = accounts[mint].publicKey;\n      const accountExists = await provider.connection.getAccountInfo(\n        associatedToSignerAccount\n      );\n\n      // Return if the account already exists\n      if (accountExists) {\n        console.log(\"ALREADY EXISTS\");\n        return null;\n      }\n      const insts = Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        new PublicKey(mint),\n        accounts[mint].publicKey,\n        tokenAuthority.publicKey,\n        fundingAccount.publicKey\n      );\n      const tx = new Transaction();\n      tx.add(insts);\n      const signers: Account[] = (fundingAccount as Signer).secretKey\n        ? [fundingAccount as Account]\n        : [];\n      return {\n        tx,\n        signers: signers,\n      };\n    })\n  );\n\n  return { accounts: accounts, txs: createTokTx.filter((i) => !!i) };\n};\n\n// TODO: if there are 2 token accounts of the same type, one of them not being made, then there will be an error out\n\n// See https://spl.solana.com/associated-token-account\nconst findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        walletAddress.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(tokenMintAddress).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getMintsNoDuplicates = (mints: PublicKey[]) => [\n  ...new Set(mints.map(pkToStr)),\n];\n\nconst pkToStr = (pk: PublicKey) => pk.toBase58();\nconst pkFromStr = (pk: string) => new PublicKey(pk);\n\nexport const toReadableNumber = (number: u64, decimals: number): string => {\n  function trimTrailingZeroes(value: string): string {\n    return value.replace(/\\.?0*$/, \"\");\n  }\n  function formatWithCommas(value: string): string {\n    const pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(value)) {\n      value = value.replace(pattern, \"$1,$2\");\n    }\n    return value;\n  }\n\n  const balance = number.toString();\n  const wholeStr = balance.substring(0, balance.length - decimals) || \"0\";\n  // TODO: correct?\n  const fractionStr = balance\n    .substring(balance.length - decimals)\n    .padStart(decimals, \"0\")\n    .substring(0, decimals);\n\n  return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);\n};\n\nexport const fromReadableNumber = (\n  number: number,\n  decimals: number\n): string => {\n  function trimLeadingZeroes(value: string): string {\n    value = value.replace(/^0+/, \"\");\n    if (value === \"\") {\n      return \"0\";\n    }\n    return value;\n  }\n\n  const split = number.toString().split(\".\");\n  const wholePart = split[0];\n  const fracPart = split[1] || \"\";\n  if (split.length > 2 || fracPart.length > decimals) {\n    throw new Error(`Cannot parse '${number}' as token amount`);\n  }\n  return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, \"0\"));\n};\n","// TODO: there is probably a faster way to do this\nexport const deepCloneObject = (obj: any): any => {\n  function clone(obj) {\n    if (obj == null || typeof obj != \"object\") return obj;\n\n    var temp = obj.constructor();\n\n    for (var key in obj) temp[key] = clone(obj[key]);\n    return temp;\n  }\n  return clone(obj);\n};\n","import * as anchor from \"@project-serum/anchor\";\nimport { MallocSdk } from \"@malloc/sdk\";\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { getConstants } from \"../config/constants\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  commitment: anchor.web3.Commitment = \"recent\",\n  queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result: any, context: any) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n};\n\n/* export */ const createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getTokenWallet = async (\n  wallet: anchor.web3.PublicKey,\n  mint: anchor.web3.PublicKey\n) => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const getMallocSdk = (wallet: anchor.Provider): MallocSdk => {\n  return new MallocSdk(\n    new PublicKey(getConstants().MALLOC_PROGRAM_ID || \"\"),\n    wallet\n  );\n};\n","import {\n  Account,\n  Connection,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { MintInfo, TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport {\n  ActionLib,\n  AccountsArray,\n  Action,\n  ActionMetadata,\n  BuildIsolatedActionFn,\n  BuildIsolatedActionFnOpts,\n  utils,\n} from \"@malloc/sdk\";\nimport { BN, Provider, web3 } from \"@project-serum/anchor\";\nimport { TokenInfo, TokenListContainer } from \"@solana/spl-token-registry\";\nimport {\n  connection,\n  createMintInstructions,\n  createTokenAccountInstrs,\n  parseMintAccount,\n  SendTxRequest,\n} from \"@project-serum/common\";\n\nconst actionTypeUID = \"MALLOC_SPL_MINT\";\n\ntype BuildIsolatedMintArgs = {\n  authority?: string;\n  decimals: string;\n  amountOut: string;\n};\n\nexport const buildIsolatedMintAction: BuildIsolatedActionFn<BuildIsolatedMintArgs> =\n  async (\n    inp: BuildIsolatedMintArgs,\n    inMint: string,\n    inTokenAccount: string,\n    dummyPassThroughActionPID: string,\n    provider: Provider,\n    opts?: BuildIsolatedActionFnOpts<BuildIsolatedMintArgs>\n  ) => {\n    const decimals = parseInt(inp.decimals);\n    const mint = new Keypair();\n    const amountOutExpanded = utils.tokens.fromReadableNumber(\n      parseFloat(inp.amountOut),\n      decimals\n    );\n\n    const outTokenAccount = await utils.tokens.getTokenAccountUsedByMalloc(\n      provider.wallet.publicKey,\n      mint.publicKey,\n      opts?.preferredTokenAccounts\n    );\n\n    const authority = new PublicKey(inp.authority || provider.wallet.publicKey);\n\n    return {\n      isolatedAction: {\n        addDefaultTokAccounts: false,\n        actionData: serializeData(amountOutExpanded.toString()),\n        tokenAccountOuts: [outTokenAccount],\n        actionAccounts: [],\n        actionProgram: new PublicKey(dummyPassThroughActionPID),\n        tokenMintIn: new PublicKey(inMint),\n        tokenMintOuts: [mint.publicKey],\n        additionalSigners: [mint],\n        tokenCreationOptions: {\n          skipOutTokenCreations: [0],\n        },\n        instructions: [\n          ...(await createMintInstructions(\n            provider,\n            authority,\n            mint.publicKey,\n            decimals\n          )),\n        ],\n      },\n    };\n  };\n\nconst serializeData = (amount: string) => Buffer.from(`[${amount}]`);\n\n/**\n * The file's main export\n */\nexport const MintAction: ActionLib<BuildIsolatedMintArgs> = {\n  buildIsolatedAction: buildIsolatedMintAction,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\nexport default MintAction;\n","import { ActionLib, BNIsh, BuildIsolatedActionFn, utils } from \"@malloc/sdk\";\nimport { serialize as borshSer } from \"borsh\";\nimport { TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport {\n  Account,\n  Ed25519Program,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n} from \"@solana/web3.js\";\nimport { Provider } from \"../../../../anchor/ts/src\";\nimport { SendTxRequest } from \"../../../../anchor/ts/src/provider\";\nimport { createMintInstructions } from \"@project-serum/common\";\n\n// TODO: optionality to not just create a new mint\n/**\n * @param authoritySecret - a hex encoded secret key\n * @param createMint.amount - the amount to mint to, this will be packed into the data and will overwrite amount_in. This is in human readable format\n */\ntype BuildMintToArgs = {\n  authoritySecret?: string;\n  // createMint?: {\n  // TODO: add back in the above once the frontend can give in a struct\n  decimals: number;\n  createMintSecretKey?: string; // The secret key of the mint in hex\n  initialSupply: string;\n  // };\n};\n\nconst actionTypeUID = \"MALLOC_SPL_MINT_TO\";\n\nclass ActionData extends utils.serde.Assignable {}\n\nconst schema = new Map([\n  [\n    ActionData,\n    {\n      kind: \"struct\",\n      fields: [[\"amount_override\", { kind: \"option\", type: \"u64\" }]],\n    },\n  ],\n]);\n\nexport const _mintToSerializeData = (amount?: BNIsh): Buffer => {\n  return Buffer.from(\n    borshSer(schema, new ActionData({ amount_override: new u64(amount) }))\n  );\n};\n\nconst buildIsolatedMintTo: BuildIsolatedActionFn<BuildMintToArgs> = async (\n  inp: BuildMintToArgs,\n  inputMint: string,\n  inputTokenAccount: string,\n  mintToPID,\n  provider: Provider\n) => {\n  // TODO: note the below is untested and will remain so till the hackathon is over\n  const authoritySigner = inp.authoritySecret\n    ? Keypair.fromSecretKey(\n        new Uint8Array(Buffer.from(inp.authoritySecret, \"hex\"))\n      )\n    : undefined;\n\n  // If the user is creating a new mint, then use the new mint address, otherwise use the input mint\n  const mint = inp.createMintSecretKey\n    ? Keypair.fromSecretKey(\n        new Uint8Array(Buffer.from(inp.createMintSecretKey, \"hex\"))\n      )\n    : new Keypair();\n\n  // If their is not specified recipient, mint to the caller\n  const associateTokAccountRecipient =\n    await utils.tokens.getTokenAccountUsedByMalloc(\n      provider.wallet.publicKey,\n      mint.publicKey\n    );\n\n  const optionalAmountWholeNumber = utils.tokens.fromReadableNumber(\n    parseFloat(inp.initialSupply),\n    inp.decimals\n  );\n\n  const atStartTxs: SendTxRequest[] = [];\n\n  const authority = new PublicKey(provider.wallet.publicKey);\n  const tx = new Transaction();\n  tx.add(\n    ...(await createMintInstructions(\n      provider,\n      authority,\n      mint.publicKey,\n      inp.decimals\n    ))\n  );\n  atStartTxs.push({\n    tx,\n    signers: [mint],\n  });\n\n  return {\n    isolatedAction: {\n      tokenMintIn: new PublicKey(inputMint),\n      actionData: _mintToSerializeData(optionalAmountWholeNumber),\n      actionProgram: new PublicKey(mintToPID),\n      actionAccounts: [\n        {\n          address: mint.publicKey,\n          isWriteable: true,\n        },\n        {\n          address: associateTokAccountRecipient,\n          isWriteable: true,\n        },\n        {\n          address: authoritySigner?.publicKey || provider.wallet.publicKey,\n          isSigner: true,\n        },\n        {\n          address: TOKEN_PROGRAM_ID,\n        },\n      ],\n      additionalSigners: authoritySigner ? [authoritySigner] : [],\n      tokenMintOuts: [mint.publicKey],\n      tokenAccountOuts: [associateTokAccountRecipient],\n      atStartOfPrepareTxs: atStartTxs,\n      // TODO: once JIT token creation is added, move creating the mint to an instruction and change the token creation to\n      // be right here!\n      // tokenCreationOptions: {\n      //   skipInTokenCreation: true,\n      // },\n    },\n  };\n};\n\nexport const MintAndMintToAction: ActionLib<BuildMintToArgs> = {\n  buildIsolatedAction: buildIsolatedMintTo,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\n","import {\n  Account,\n  Connection,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { MintInfo, TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport { Side, SwapAccounts, SwapInstructionByte } from \"./swap-interfaces\";\nimport {\n  ActionLib,\n  AccountsArray,\n  Action,\n  ActionMetadata,\n  BuildIsolatedActionFn,\n  BuildIsolatedActionFnOpts,\n  utils,\n} from \"@malloc/sdk\";\nimport { BN, Provider, web3 } from \"@project-serum/anchor\";\nimport { TokenInfo, TokenListContainer } from \"@solana/spl-token-registry\";\nimport { Market, OpenOrders, TokenInstructions } from \"@project-serum/serum\";\nimport {\n  connection,\n  parseMintAccount,\n  SendTxRequest,\n} from \"@project-serum/common\";\nimport { Swap } from \"@project-serum/swap\";\n\nexport * from \"./swap-interfaces\";\n\nconst actionTypeUID = \"MALLOC_SPL_SWAP\";\n\ninterface SwapInput {\n  // outTokenAccount: string; //TODO: hmmm...\n  outMint: string;\n  serumDexProgramId: string;\n  rent: string;\n  openOrdersAccount?: string;\n}\n\ntype BuildIsolatedSwapArgs = SwapInput & {\n  minOut: string;\n};\nexport const buildIsolatedSwapAction: BuildIsolatedActionFn<BuildIsolatedSwapArgs> =\n  async (\n    inp: BuildIsolatedSwapArgs,\n    inMint: string,\n    inTokenAccount: string,\n    swapPID: string,\n    provider: Provider,\n    opts?: BuildIsolatedActionFnOpts<BuildIsolatedSwapArgs>\n  ) => {\n    const outTokenAccount = await utils.tokens.getTokenAccountUsedByMalloc(\n      provider.wallet.publicKey,\n      new PublicKey(inp.outMint),\n      opts?.preferredTokenAccounts\n    );\n    const swapInfo = await buildSwapAccounts(\n      inp,\n      inMint,\n      inTokenAccount,\n      outTokenAccount.toBase58(),\n      provider\n    );\n\n    return {\n      isolatedAction: {\n        addDefaultTokAccounts: false,\n        actionData: packSwapData(\n          SwapInstructionByte.BasicSwap,\n          swapInfo.side,\n          new u64(inp.minOut)\n        ),\n        tokenAccountOuts: [outTokenAccount],\n        actionAccounts: swapAccountsToActionAccounts(\n          swapInfo.swapAccounts,\n          swapInfo.side\n        ),\n        actionProgram: new PublicKey(swapPID),\n        tokenMintIn: new PublicKey(inMint),\n        tokenMintOuts: [new PublicKey(inp.outMint)],\n        preActionTxs: swapInfo.openOrderInitTx\n          ? [swapInfo.openOrderInitTx]\n          : [],\n      },\n    };\n  };\n\nexport const buildSwapAccounts = async (\n  inp: SwapInput,\n  inMint: string,\n  inTokenAccount: string,\n  outTokenAccount: string,\n  provider: Provider\n): Promise<{\n  swapAccounts: SwapAccounts;\n  openOrderInitTx?: SendTxRequest;\n  market: Market;\n  side: Side;\n}> => {\n  const serumDexId = new PublicKey(inp.serumDexProgramId);\n  const marketRet = await getMarket(\n    provider.connection,\n    new PublicKey(inMint),\n    new PublicKey(inp.outMint),\n    serumDexId\n  );\n  if (!marketRet) throw \"No markets found\";\n\n  const { side, pk: marketPk } = marketRet;\n  const marketSel = await Market.load(\n    provider.connection,\n    marketPk,\n    {},\n    serumDexId\n  );\n\n  const openOrderAccountData = await getOpenOrdersAccount(\n    provider.connection,\n    marketSel,\n    provider.wallet.publicKey,\n    new PublicKey(inp.serumDexProgramId)\n  );\n\n  const [vaultSigner, _] = await getVaultOwnerAndNonce(\n    marketSel.decoded.ownAddress,\n    new PublicKey(inp.serumDexProgramId)\n  );\n\n  const coinWallet = side === Side.Bid ? outTokenAccount : inTokenAccount;\n  const pcWallet = side === Side.Bid ? inTokenAccount : outTokenAccount;\n\n  return {\n    market: marketSel,\n    swapAccounts: {\n      market: {\n        market: marketSel.decoded.ownAddress,\n        requestQueue: marketSel.decoded.requestQueue,\n        eventQueue: marketSel.decoded.eventQueue,\n        bids: marketSel.decoded.bids,\n        asks: marketSel.decoded.asks,\n        coinVault: marketSel.decoded.baseVault,\n        pcVault: marketSel.decoded.quoteVault,\n        vaultSigner: vaultSigner,\n        // User params.\n        openOrders: new PublicKey(\n          inp.openOrdersAccount || openOrderAccountData.openOrderPk\n        ),\n        orderPayerTokenAccount: new PublicKey(inTokenAccount),\n        coinWallet: new PublicKey(coinWallet),\n      },\n      pcWallet: new PublicKey(pcWallet),\n      authority: provider.wallet.publicKey,\n      dexProgram: new PublicKey(inp.serumDexProgramId),\n      tokenProgram: new PublicKey(TOKEN_PROGRAM_ID),\n      rent: new PublicKey(inp.rent),\n    },\n\n    openOrderInitTx: inp.openOrdersAccount\n      ? undefined\n      : openOrderAccountData.openOrderTx,\n    side,\n  };\n};\n\n/**\n * get the open order accounts associated with the market and owner\n *\n * If none exist, create a new account and return a tx to create/ init the account as well\n */\nconst getOpenOrdersAccount = async (\n  connection: Connection,\n  market: Market,\n  owner: PublicKey,\n  dexPID: PublicKey\n): Promise<{\n  openOrderPk: PublicKey;\n  openOrderTx?: SendTxRequest;\n}> => {\n  const openOrders = await OpenOrders.findForMarketAndOwner(\n    connection,\n    market.address,\n    owner,\n    dexPID\n  );\n  if (openOrders.length === 0) {\n    const openOrderAccount = new Account(new Keypair().secretKey);\n    const openOrdersTx = new Transaction();\n    openOrdersTx.add(\n      await OpenOrders.makeCreateAccountTransaction(\n        connection,\n        market.decoded.ownAddress,\n        owner,\n        openOrderAccount.publicKey,\n        dexPID\n      )\n    );\n\n    return {\n      openOrderPk: openOrderAccount.publicKey,\n      openOrderTx: {\n        tx: openOrdersTx,\n        signers: [openOrderAccount],\n      },\n    };\n  } else {\n    return {\n      openOrderPk: openOrders[0].publicKey,\n    };\n  }\n};\n\n// TODO: this just takes the first market available... have some sorta best market in the future?\nexport const getMarket = async (\n  connection: Connection,\n  inMint: PublicKey,\n  outMint: PublicKey,\n  serumDexProgramId: PublicKey\n) => {\n  // TODO: slightly confused about side\n  let side = Side.Ask;\n  let marketPks = await getMarketsFromBaseMinttoQuoteMint(\n    connection,\n    inMint,\n    outMint,\n    serumDexProgramId\n  );\n\n  // Try the other market side\n  if (!marketPks || marketPks.length === 0) {\n    marketPks = await getMarketsFromBaseMinttoQuoteMint(\n      connection,\n      outMint,\n      inMint,\n      serumDexProgramId\n    );\n    side = Side.Bid;\n  }\n  if (!marketPks || marketPks.length === 0) return null;\n  return { pk: marketPks[0], side };\n};\n\nexport const packSwapData = (\n  instrByte: SwapInstructionByte,\n  side: Side,\n  minOut: u64\n): Buffer => {\n  const packedMinOut = minOut.toArrayLike(Buffer, \"be\", 8);\n  const initPart = Buffer.from(new Uint8Array([instrByte, side]));\n  return Buffer.concat([initPart, packedMinOut]);\n};\n\nexport const swapAccountsToActionAccounts = (\n  swapAccounts: SwapAccounts,\n  side: Side,\n  referralAccount?: PublicKey\n): AccountsArray => {\n  const tokenAccount =\n    side === Side.Bid ? swapAccounts.pcWallet : swapAccounts.market.coinWallet;\n  const outAccount =\n    side === Side.Bid ? swapAccounts.market.coinWallet : swapAccounts.pcWallet;\n  const accounts = [\n    {\n      isWriteable: true,\n      address: tokenAccount,\n    },\n    {\n      address: swapAccounts.tokenProgram,\n    },\n    {\n      address: swapAccounts.authority,\n      isSigner: true,\n    },\n    {\n      address: swapAccounts.rent,\n    },\n    {\n      address: swapAccounts.dexProgram,\n    },\n    {\n      address: outAccount,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.market,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.openOrders,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.requestQueue,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.eventQueue,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.bids,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.asks,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.orderPayerTokenAccount,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.coinVault,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.pcVault,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.vaultSigner,\n    },\n  ];\n  if (referralAccount) {\n    accounts.push({\n      address: referralAccount,\n      isWriteable: true,\n    });\n  }\n  return accounts;\n};\n\nexport async function getVaultOwnerAndNonce(\n  marketPublicKey: PublicKey,\n  dexProgramId: PublicKey\n): Promise<[PublicKey, BN]> {\n  const nonce = new BN(0);\n  while (nonce.toNumber() < 255) {\n    try {\n      const vaultOwner = await PublicKey.createProgramAddress(\n        [marketPublicKey.toBuffer(), nonce.toArrayLike(Buffer, \"le\", 8)],\n        dexProgramId\n      );\n      return [vaultOwner, nonce];\n    } catch (e) {\n      nonce.iaddn(1);\n    }\n  }\n  throw new Error(\"Unable to find nonce\");\n}\n\nconst getMarketsFromBaseMinttoQuoteMint = async (\n  connection: Connection,\n  baseMint: PublicKey,\n  quoteMint: PublicKey,\n  serumProgId: PublicKey\n): Promise<PublicKey[]> => {\n  const layout = await Market.getLayout(serumProgId);\n\n  return (\n    await Market.findAccountsByMints(\n      connection,\n      baseMint,\n      quoteMint,\n      serumProgId\n    )\n  ).map((e) => e.publicKey);\n};\n\nconst getAllMarkets = async (conn: Connection, progId: PublicKey) => {\n  Market.findAccountsByMints;\n};\n\nexport const getDemoTokenInfo = async (\n  provider: Provider,\n  fakeUsdc: PublicKey | string,\n  fakeTokA: PublicKey | string\n): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(fakeUsdc);\n  const aMint = new PublicKey(fakeTokA);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: new PublicKey(fakeUsdc).toBase58(),\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE: A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: new PublicKey(fakeTokA).toBase58(),\n    },\n  ];\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n\n/**\n * The file's main export\n */\nexport const SwapAction: ActionLib<BuildIsolatedSwapArgs> = {\n  buildIsolatedAction: buildIsolatedSwapAction,\n  actionTypeUID,\n  expectedNumberOfOutMints: 1,\n};\nexport default SwapAction;\n","import { ActionLib, BuildIsolatedActionFn, utils } from \"@malloc/sdk\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { Provider } from \"../../../../anchor/ts/src\";\n\ntype BuildTransferArgs = {\n  recipientWallet: string;\n};\n\nconst actionTypeUID = \"MALLOC_SPL_TRANSFER\";\n\nconst buildIsolatedTransfer: BuildIsolatedActionFn<BuildTransferArgs> = async (\n  inp: BuildTransferArgs,\n  mintAccount: string,\n  inputTokenAccount: string,\n  transferPID,\n  provider: Provider\n) => {\n  const mintIn = new PublicKey(mintAccount);\n  const recipient = new PublicKey(inp.recipientWallet);\n  const { associateTokAccount, instr: createTokInstr } =\n    await utils.tokens.tryCreateAssociatedAccountInst(\n      mintIn,\n      recipient,\n      provider.connection,\n      provider.wallet.publicKey\n    );\n\n  return {\n    isolatedAction: {\n      addDefaultTokAccounts: true,\n      tokenMintIn: mintIn,\n      actionData: Buffer.from([]),\n      actionProgram: new PublicKey(transferPID),\n      actionAccounts: [\n        {\n          address: associateTokAccount,\n          isWriteable: true,\n        },\n      ],\n      additionalSigners: [],\n      tokenMintOuts: [],\n      tokenAccountOuts: [],\n      // TODO: the following is a bit ghetto, but basically will ensure that the token account is only created if the recipient\n      // is not the caller. This ensures that the token account is not created again because its probably created by a former action/ token analyzer\n      instructions:\n        createTokInstr && !recipient.equals(provider.wallet.publicKey) // TODO: think of a better way to do this with tokens\n          ? [createTokInstr]\n          : undefined,\n    },\n  };\n};\n\nexport const TransferAction: ActionLib<BuildTransferArgs> = {\n  buildIsolatedAction: buildIsolatedTransfer,\n  actionTypeUID,\n  expectedNumberOfOutMints: 0,\n};\n","import { ActionMetadata } from \"./interfaces\";\n\n// TODO: there is a lot of cool stuff to do here\n\ntype ToHitArg = { called: number[] };\n\nexport const buildSeqListOfActionCalls = (\n  actionMetas: ActionMetadata[],\n  initIndices: number[]\n): number[] => {\n  const initHitCounts = [...Array(actionMetas.length)].fill(0);\n  const called = simulateDAG(\n    actionMetas.map((a, i) => {\n      return { ...a, id: i };\n    }),\n    initHitCounts,\n    initIndices\n  );\n\n  return called;\n};\n\n// Returns an ordered list of indices hit\nconst simulateDAG = (\n  actionMetas: (ActionMetadata & { id: number })[],\n  hitCounts: number[],\n  toHit: number[]\n): number[] => {\n  if (toHit.length === 0) return [];\n  const newHitCounts = hitCounts.map((e, i) => getOccurrence(toHit, i) + e)\n  const newRipeActions = actionMetas.filter(\n    (a) => a.ripeAmount === newHitCounts[a.id] && toHit.includes(a.id)\n  );\n  const newToHit = newRipeActions\n    .map((a) => a.nextNodes.map((o) => o.map((i) => i.actionIdx)))\n    .flat()\n    .flat();\n  return [\n    ...newRipeActions.map((a) => a.id),\n    ...simulateDAG(actionMetas, newHitCounts, newToHit),\n  ];\n};\n\nconst getOccurrence = <T>(array: T[], value: T) =>\n  array.filter((v) => v === value).length;\n","import { u64 } from \"@solana/spl-token\";\nimport { LAMPORTS_PER_EPOCH, MS_PER_EPOCH } from \"./constants\";\n\nexport const calculateRent = (size: number, durationMs: number): number => {\n  const rentCost = Math.ceil(LAMPORTS_PER_EPOCH * size * (durationMs / MS_PER_EPOCH));\n\treturn rentCost\n};\n","import MALLOC_IDL from \"./idls/malloc.json\";\nimport * as BufferLayout from \"buffer-layout\";\nimport ACTION_TEMPLATE_IDL from \"./idls/action_template.json\";\nimport { BN, Program, Provider, Wallet, web3 } from \"@project-serum/anchor\";\n// import { BN, Program, Provider, web3 } from \"../../../../../anchor/ts\";\nimport { SendTxRequest } from \"@project-serum/anchor/dist/provider\";\nimport { TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport {\n  Signer,\n  Transaction,\n  PublicKey,\n  Keypair,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n  SystemProgram,\n} from \"@solana/web3.js\";\nimport {\n  CONSTRUCTION_ACCOUNT_SIZE,\n  LIFETIME_CONSTRUCTION_ACCOUNT_MS,\n  LIFETIME_RESULT_ACCOUNT_MS,\n} from \"./constants\";\nimport { buildSeqListOfActionCalls } from \"./graph-utils\";\nimport {\n  ActionCtxFinal,\n  Action,\n  ActionMetadata,\n  BNIsh,\n  AccountsArray,\n  PartialNextActionCtx,\n  ProcessActionNext,\n} from \"./interfaces\";\nimport { calculateRent } from \"./solana-utils\";\nimport {\n  AccountByMint,\n  createTokenAccountsForActions,\n  transferToTx,\n} from \"./utils/tokens\";\n\nexport interface SendRequestsOpts {\n  onPrepareAccountsDone?: (txHashes: string[]) => Promise<any>;\n  prepareCommitment?: web3.ConfirmOptions;\n  actionCommitment?: web3.ConfirmOptions;\n}\n\nexport interface ConstructionData {\n  txsPrepare: SendTxRequest[];\n  txsActionCalls: SendTxRequest[];\n  construction: Signer;\n  resultAccounts: Signer[];\n  tokenAccounts: AccountByMint;\n}\n\n/**\n * @param authority - B58 Encoded public key of the authority\n * @param actions.tokenAccount - B58 Encoded public key of the token account\n */\nexport interface ConstructionStateSerialized {\n  construction: {\n    authority: string;\n    actions: (ActionMetadata & { tokenAccount: string })[];\n    actionCalls: { callAmount: string; numbTimesHit: number }[];\n    readyCallIdxList: number[];\n  };\n}\n\nexport interface BuildEphemeralOpts {\n  preferredTokenAccounts?: {\n    [mint: string]: PublicKey;\n  };\n}\n\nexport type BuildEphemeralTxsInstr = {\n  actions: Action[];\n  initialSplits: number[];\n  initialActionIndices: number[];\n  amount: BNIsh;\n  authority?: Signer;\n  amountInAccount: PublicKey;\n  amountInAuthority?: Signer;\n  opts?: BuildEphemeralOpts;\n};\n\nexport class MallocSdk {\n  private readonly mallocProgram: Program;\n\n  constructor(\n    private readonly MALLOC_PROGRAM_ID: PublicKey,\n    private readonly provider: Provider\n  ) {\n    this.mallocProgram = new Program(\n      MALLOC_IDL as any,\n      MALLOC_PROGRAM_ID,\n      provider\n    );\n    // TODO: make new program with idl\n  }\n\n  // TODO: prepare and run should j be one thing\n  // Then, to deal with fact that token accounts can j be created, token creation tx's should j happen immediately preceding the first action to use that token\n\n  // TODO create token accounts and store there associations\n  // Append on \"withdraw\" functionality and tx to transfer initial into account\n  async buildTxs({\n    actions,\n    initialSplits,\n    initialActionIndices,\n    amount,\n    authority: _authority,\n    amountInAccount,\n    amountInAuthority: _inAuth,\n    opts,\n  }: BuildEphemeralTxsInstr): Promise<ConstructionData> {\n    let amountInAuthority = _inAuth || (this.provider.wallet as Wallet);\n    let authority = _authority || (this.provider.wallet as Wallet);\n\n    const { accounts: tokenAccounts, txs: tokenTxs } =\n      // TODO: disable this and then later have an option to reenable\n      await createTokenAccountsForActions(\n        this.provider,\n        authority,\n        actions,\n        this.provider.wallet as Wallet,\n        opts?.preferredTokenAccounts\n      );\n    const { construction, tx: constructionTx } =\n      await createAndInitConstruction(\n        this.mallocProgram,\n        authority.publicKey,\n        actions.length\n      );\n    const addConstructionActionsTx = addActionsToConstruction(\n      this.mallocProgram,\n      construction.publicKey,\n      actions.map((a) => a.actionMetadata),\n      authority\n    );\n\n    if (!checkMintsAreTheSame(initialActionIndices.map((i) => actions[i]))) {\n      throw \"Expected all initial token types to be the same\";\n    }\n\n    if (initialActionIndices.length === 0)\n      throw \"Expected initial actions to have length more than 0\";\n\n    const initMint = actions[initialActionIndices[0]].tokenMintIn;\n\n    const transferTx = await transferToTx(\n      amountInAccount,\n      tokenAccounts[initMint.toBase58()].publicKey,\n      new BN(amount), // Add 1 to ensure the accounts don't go to 0 // TODO: does this make sense\n      amountInAuthority\n    );\n\n    const prepareConstructionTx = prepareConstruction(\n      this.mallocProgram,\n      construction.publicKey,\n      initialActionIndices,\n      initialSplits,\n      authority,\n      new BN(amount)\n    );\n\n    const hitOrder = buildSeqListOfActionCalls(\n      actions.map((a) => a.actionMetadata),\n      initialActionIndices\n    );\n    if (hitOrder.length !== actions.length)\n      throw \"An error occurred trying to forecast your construction\";\n\n    const initResultAccounts = await Promise.all(\n      actions.map((a) =>\n        initResultAccount(\n          new Program(\n            ACTION_TEMPLATE_IDL as any,\n            a.actionProgram,\n            this.provider\n          ),\n          // Set the number of out amounts to equal the amount of next nodes\n          a.actionMetadata.nextNodes.length\n        )\n      )\n    );\n\n    // The additional accounts added onto action action accounts follow conventional malloc standards for token\n    // TODO: have an option to not pass in the token accounts\n    const actionCtxFilled: PartialNextActionCtx[] = actions.map((action, i) => {\n      const toAdd = action.addDefaultTokAccounts\n        ? [\n            {\n              address: tokenAccounts[action.tokenMintIn.toBase58()].publicKey,\n              isWriteable: true,\n              isSigner: false,\n            },\n            {\n              address: TOKEN_PROGRAM_ID,\n              isWriteable: false,\n              isSigner: false,\n            },\n            {\n              address: authority.publicKey,\n              isSigner: true,\n              isWriteable: false,\n            },\n          ]\n        : [];\n\n      return {\n        ctx: {\n          resultAccount: initResultAccounts[i].resultAccount.publicKey,\n          actionProgram: action.actionProgram,\n        },\n        actionAccounts: [...toAdd, ...action.actionAccounts] as AccountsArray,\n      };\n    });\n\n    const processTxs = hitOrder.map((hitIndex) =>\n      processAction(\n        this.mallocProgram,\n        hitIndex,\n        construction.publicKey,\n        actionCtxFilled[hitIndex],\n        authority,\n        {\n          data: actions[hitIndex].actionData,\n          instructions: actions[hitIndex].instructions,\n          additionalSigners: actions[hitIndex].additionalSigners,\n          preActionTxs: actions[hitIndex].preActionTxs,\n        }\n      )\n    );\n\n    const atStartOfPrepareTxs = getAllAtStartOfPrepareTxs(actions);\n    // TODO: optional withdraw to accounts\n\n    const txsPrepare = [\n      ...atStartOfPrepareTxs,\n      ...tokenTxs,\n      transferTx,\n      constructionTx,\n      addConstructionActionsTx,\n      prepareConstructionTx,\n      ...initResultAccounts.map((i) => i.tx),\n    ];\n    const txsActionsCalls = [...processTxs.flat()];\n\n    return {\n      construction,\n      txsPrepare: txsPrepare,\n      txsActionCalls: txsActionsCalls,\n      tokenAccounts,\n      resultAccounts: initResultAccounts.map((a) => a.resultAccount),\n    };\n  }\n\n  async getConstructionState(\n    data: ConstructionData\n  ): Promise<ConstructionStateSerialized> {\n    const constructionState: any =\n      (await this.mallocProgram.account.construction.fetch(\n        data.construction.publicKey\n      )) as any;\n    const actionSerialize = (a: any) => {\n      return {\n        tokenAccount: new PublicKey(a.tokenAccount).toBase58(),\n        ripeAmount: a.ripeAmount,\n        nextNodes: a.nextNodes.map((o) =>\n          o.map((nextNode) => {\n            return {\n              actionIdx: nextNode.actionIdx,\n              fraction: new BN(nextNode.fraction).toString(),\n            };\n          })\n        ),\n      };\n    };\n    const actionCallSerialize = (a: any) => {\n      return {\n        numbTimesHit: a.numbTimesHit,\n        callAmount: new BN(a.callAmount).toString(),\n      };\n    };\n    return {\n      construction: {\n        authority: new PublicKey(constructionState.authority).toBase58(),\n        actions: constructionState.actions.map(actionSerialize),\n        actionCalls: constructionState.actionCalls.map(actionCallSerialize),\n        readyCallIdxList: constructionState.readyCallIdxList,\n      },\n    };\n  }\n\n  // TODO:!\n  async deleteEphemeralAccounts(constructionData: ConstructionData) {\n    const withdrawAllRentInstr = (account: Signer) => {};\n    constructionData.construction;\n  }\n\n  async sendRequests(\n    data: ConstructionData,\n    options?: SendRequestsOpts\n  ): Promise<string[]> {\n    await this.provider;\n    const txHashesPrepare =\n      data.txsPrepare.length > 0\n        ? await this.provider.sendAll(data.txsPrepare, {\n            // skipPreflight: true,\n            ...(options?.prepareCommitment || {}),\n          })\n        : [];\n    if (options?.onPrepareAccountsDone && txHashesPrepare.length > 0)\n      await options.onPrepareAccountsDone(txHashesPrepare);\n    const txHashes = await this.provider.sendAll(data.txsActionCalls, {\n      // skipPreflight: true,\n      ...(options?.actionCommitment || {}),\n    });\n    return [...txHashesPrepare, ...txHashes];\n  }\n}\n\nconst createAndInitConstruction = async (\n  program: Program,\n  authority: PublicKey,\n  numbActions: number\n): Promise<{ construction: Signer; tx: SendTxRequest }> => {\n  const ConstructionAccount = web3.Keypair.generate();\n  const tx = program.transaction.initConstruction(numbActions, {\n    accounts: {\n      construction: ConstructionAccount.publicKey,\n      authority,\n      rent: web3.SYSVAR_RENT_PUBKEY,\n    },\n    signers: [ConstructionAccount],\n    instructions: [\n      await SystemProgram.createAccount({\n        fromPubkey: program.provider.wallet.publicKey,\n        newAccountPubkey: ConstructionAccount.publicKey,\n        space: CONSTRUCTION_ACCOUNT_SIZE + 8,\n        lamports: calculateRent(\n          CONSTRUCTION_ACCOUNT_SIZE + 8,\n          LIFETIME_CONSTRUCTION_ACCOUNT_MS\n        ),\n        programId: program.programId,\n      }),\n      // await program.account.construction.createInstruction,\n    ],\n  });\n\n  return {\n    tx: { tx, signers: [ConstructionAccount] },\n    construction: ConstructionAccount,\n  };\n};\n\nconst addActionsToConstruction = (\n  program: Program,\n  construction: PublicKey,\n  actions: ActionMetadata[],\n  authority: Signer | Wallet\n): SendTxRequest => {\n  const signers = (authority as Signer).secretKey ? [authority as Signer] : [];\n  const actionMetadataWithU64: ActionMetadata[] = actions.map((action) => {\n    return {\n      ripeAmount: action.ripeAmount,\n      nextNodes: action.nextNodes.map((nextNode) =>\n        nextNode.map((n) => {\n          return {\n            actionIdx: n.actionIdx,\n            fraction: new u64(n.fraction),\n          };\n        })\n      ),\n    };\n  });\n  return {\n    tx: program.transaction.addActions(actionMetadataWithU64, {\n      accounts: {\n        authority: authority.publicKey,\n        construction: construction,\n        rent: web3.SYSVAR_RENT_PUBKEY,\n      },\n      signers: signers,\n    }),\n    signers,\n  };\n};\n\nconst getAllAtStartOfPrepareTxs = (actions: Action[]) =>\n  actions.map((a) => a.atStartOfPrepareTxs || []).flat();\n\nconst prepareConstruction = (\n  program: Program,\n  construction: PublicKey,\n  initActionIdx: number[],\n  initActionSplits: number[],\n  authority: Signer | Wallet,\n  amount: BN\n): SendTxRequest => {\n  const signers = (authority as Signer).secretKey ? [authority as Signer] : [];\n  return {\n    tx: program.transaction.prepareConstruction(\n      initActionIdx,\n      initActionSplits.map((i) => new BN(i)),\n      amount,\n      {\n        accounts: {\n          authority: authority.publicKey,\n          construction: construction,\n          rent: web3.SYSVAR_RENT_PUBKEY,\n        },\n        signers,\n      }\n    ),\n    signers,\n  };\n};\n\n/**\n * @param tokenAuthority - defaults to the authority if not provided\n */\nconst processAction = (\n  program: Program,\n  actionIdx: number,\n  construction: PublicKey,\n  actionAccountsCtx: PartialNextActionCtx,\n  authority: Signer | Wallet,\n  opts: {\n    data?: Buffer;\n    tokenAuthority?: Signer | Wallet;\n    instructions?: TransactionInstruction[];\n    additionalSigners?: Signer[];\n    preActionTxs?: SendTxRequest[];\n  }\n): SendTxRequest[] => {\n  const auth = (authority as Signer)?.secretKey ? [authority as Signer] : [];\n  const tokauth = (opts.tokenAuthority as Signer)?.secretKey\n    ? [opts.tokenAuthority as Signer]\n    : [];\n  const signersIsolated = opts.tokenAuthority\n    ? [...tokauth, ...auth]\n    : [...auth];\n  const signers = [...signersIsolated, ...(opts.additionalSigners || [])];\n  return [\n    ...(opts.preActionTxs || []),\n    {\n      tx: program.transaction.processAction(\n        actionIdx,\n        opts.data || Buffer.from([]),\n        {\n          accounts: {\n            construction: construction,\n            rent: web3.SYSVAR_RENT_PUBKEY,\n            authority: authority.publicKey,\n            actionCtxProxy: actionAccountsCtx.ctx,\n            actionAccounts: actionAccountsCtx.actionAccounts,\n          } as ProcessActionNext,\n          signers,\n          instructions: opts.instructions || undefined,\n        }\n      ),\n      signers,\n    },\n  ];\n};\n\nconst initResultAccount = async (\n  actionTemplateProgram: Program,\n  numberOfPossibleOutputTokens: number\n): Promise<{ tx: SendTxRequest; resultAccount: Signer }> => {\n  const result = Keypair.generate();\n  actionTemplateProgram.provider.connection.getMinimumBalanceForRentExemption;\n  const resultSize = calcSizeResultAccount(numberOfPossibleOutputTokens);\n  const tx = actionTemplateProgram.transaction.initResultAccount(\n    numberOfPossibleOutputTokens,\n    {\n      accounts: {\n        result: result.publicKey,\n        rent: web3.SYSVAR_RENT_PUBKEY,\n      },\n      instructions: [\n        await SystemProgram.createAccount({\n          fromPubkey: actionTemplateProgram.provider.wallet.publicKey,\n          newAccountPubkey: result.publicKey,\n          space: resultSize,\n          lamports: calculateRent(resultSize, LIFETIME_RESULT_ACCOUNT_MS),\n          programId: actionTemplateProgram.programId,\n        }),\n      ],\n      signers: [result],\n    }\n  );\n  return {\n    tx: { tx, signers: [result] },\n    resultAccount: result,\n  };\n};\n\n// From https://github.com/solana-labs/solana-program-library/blob/30406eea40671afefa18b5ae6c9b37ffcb6235d0/token/js/client/token.js#L1850\n/**\n * Construct a Close instruction\n *\n * @param programId SPL Token program account\n * @param account Account to close\n * @param dest Account to receive the remaining balance of the closed account\n * @param authority Account Close authority\n * @param multiSigners Signing accounts if `owner` is a multiSig\n */\nconst createCloseAccountInstruction = (\n  programId: PublicKey,\n  account: PublicKey,\n  dest: PublicKey,\n  owner: PublicKey\n): TransactionInstruction => {\n  throw \"TODO\";\n};\n\n// 8 for the discriminator, 32 for the owner pubkey, 4 for the number of results, and the rest for numb actions, then 64 as a buffer\nconst calcSizeResultAccount = (numberOfActions: number) =>\n  8 + 32 + 4 + numberOfActions * 8 + 64;\n\nconst checkMintsAreTheSame = (actions: Action[]) => {\n  if (actions.length === 0) return true;\n  const mint = actions[0].tokenMintIn.toBase58();\n  return actions.every((a) => a.tokenMintIn.toBase58() === mint);\n};\n","export * from \"./contexts\";\nexport * from \"./common\";\n","import { Provider } from \"@project-serum/anchor\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\nimport {\n  Action,\n  ActionMetadata,\n  BuildActionMap,\n  Construction,\n  NextNode,\n  NonUserSpecificConstruction,\n} from \"..\";\nimport { buildSeqListOfActionCalls } from \"../graph-utils\";\nimport { deepCloneObject } from \"../utils/object\";\nimport {\n  getTokenAccountUsedByMalloc,\n  PreferredTokenAccounts,\n} from \"../utils/tokens\";\n\nconst getPreviousActions = (\n  actionIdx: number,\n  actions: (Action | undefined)[]\n): { idx: number; idxInNextNodes: [number, number] }[] => {\n  // First add indices to each action\n  // Then remove the undefined actions\n  // Then search if the action has the actionIdx\n  return actions\n    .map((a, i) => {\n      return a ? { ...a, idx: i } : a;\n    })\n    .filter((a) => !!a)\n    .map((a: Action & { idx: number }) => {\n      const idxInNextNodes: [number, number] = [-1, -1];\n      // TODO: note this assumes that each action is only called once from a prior\n      for (let i = 0; i < a.actionMetadata.nextNodes.length; i++) {\n        idxInNextNodes[1] = a.actionMetadata.nextNodes[i]\n          .map((item) => item.actionIdx)\n          .indexOf(actionIdx);\n        if (idxInNextNodes[1] !== -1) {\n          idxInNextNodes[0] = i;\n          break;\n        }\n      }\n      if (idxInNextNodes[0] === -1 || idxInNextNodes[1] === -1)\n        return undefined;\n      return {\n        idx: a.idx,\n        idxInNextNodes,\n      };\n    })\n    .filter((i) => !!i);\n};\n\n/**\n * Get the mint from prior actions\n *\n * This assumes that the action given is not an initial action\n */\nconst getMintAccountFromPriorActions = (\n  actionIdx: number,\n  actions: (Action | undefined)[]\n): string => {\n  const previousActions = getPreviousActions(actionIdx, actions);\n  const mints = previousActions.map((prev) => {\n    const action = actions[prev.idx] as Action; // assume its not undefined because getPreviousAction ensures its not undefined\n    const mint = action.tokenMintOuts[prev.idxInNextNodes[0]];\n    return mint.toBase58();\n  });\n  if (mints.length < 1)\n    throw `Expected to find a previous action for a non initial action`;\n  const firstMint = mints[0];\n  if (!mints.every((mint) => mint === firstMint))\n    throw `Expected all previous mints to be the same for the action`;\n  return firstMint;\n};\n\nexport const buildConstructionFromNonUserSpecific = async (\n  construction: NonUserSpecificConstruction,\n  buildActionMap: BuildActionMap,\n  initTokenAccount: string,\n  initMintAccount: string,\n  provider: Provider,\n  preferredTokenAccounts?: PreferredTokenAccounts\n): Promise<Construction> => {\n  const orderActionsHit = buildSeqListOfActionCalls(\n    construction.actionDatas.map((a) => a.actionMetadata),\n    construction.initialActionIndices\n  );\n\n  if (orderActionsHit.length !== construction.actionDatas.length)\n    throw `An unexpected error occurred, the order of actions hit should match the length of actions`;\n\n  const actions: (Action | undefined)[] = [\n    ...Array(construction.actionDatas.length),\n  ];\n  for (let i = 0; i < orderActionsHit.length; i++) {\n    const actionIdx = orderActionsHit[orderActionsHit[i]];\n    const mintAccount = construction.initialActionIndices.includes(actionIdx)\n      ? initMintAccount\n      : getMintAccountFromPriorActions(actionIdx, actions);\n    const actionData = construction.actionDatas[actionIdx];\n    const buildFN = buildActionMap[actionData.actionTypeUID].buildIsolatedAction;\n    if (!buildFN)\n      throw `Could not find a builder function for action with UID ${actionData.actionTypeUID}`;\n    const tokenAccount = construction.initialActionIndices.includes(i)\n      ? initTokenAccount\n      : (\n          await getTokenAccountUsedByMalloc(\n            provider.wallet.publicKey,\n            new PublicKey(mintAccount),\n            preferredTokenAccounts\n          )\n        ).toBase58();\n    const { isolatedAction } = await buildFN(\n      actionData.buildActionInputs,\n      mintAccount,\n      tokenAccount,\n      actionData.actionPID,\n      provider,\n      {\n        preferredTokenAccounts,\n      }\n    );\n    const action = {\n      ...isolatedAction,\n      actionMetadata: actionData.actionMetadata,\n    };\n    actions[actionIdx] = action;\n  }\n\n  return {\n    actions,\n    initialActionIndices: construction.initialActionIndices,\n    initialSplits: construction.initialSplits,\n    amount: new BN(construction.amount),\n  };\n};\n\nconst offsetNextNodes = (\n  nextNodes: ActionMetadata[\"nextNodes\"],\n  offset: number\n): ActionMetadata[\"nextNodes\"] =>\n  nextNodes.map((nextNodeSet) =>\n    nextNodeSet.map((n) => {\n      return {\n        actionIdx: n.actionIdx + offset,\n        fraction: n.fraction,\n      } as NextNode;\n    })\n  );\n\n/**\n * Merge two constructions into 1. One is the parent and keeps its initial indices and amounts,\n * the other discards the amount value and initial indices/ splits and replaces them with the specified inputs\n *\n * @param appendChildInitToParent - where to append the initial action indices of the child construction\n * to the parent.\n */\nexport const mergeConstructions = (\n  parentConstruction: NonUserSpecificConstruction,\n  childConstruction: NonUserSpecificConstruction,\n  appendChildInitToParent: {\n    appendToInitial?: boolean;\n    indexInParent?: {\n      actionIdx: number;\n      nextNodeIdx: number;\n    };\n    splitFrac: number | string;\n  }[]\n): NonUserSpecificConstruction => {\n  // deep copy the child and parent\n  const childConstructionCloned = deepCloneObject(childConstruction);\n  const parentConstructionClone = deepCloneObject(parentConstruction);\n\n  if (\n    appendChildInitToParent.length! ==\n      childConstructionCloned.initialActionIndices.length &&\n    appendChildInitToParent.length !==\n      childConstructionCloned.initialSplits.length\n  ) {\n    throw `Expected the info to append the child to the parent to provide the same number of indices as the number of initial splits in the child`;\n  }\n  const newActionDatasArray = [\n    ...parentConstructionClone.actionDatas,\n    ...childConstructionCloned.actionDatas.map((a) => {\n      return {\n        ...a,\n        actionMetadata: {\n          ...a.actionMetadata,\n          nextNodes: offsetNextNodes(\n            a.actionMetadata.nextNodes,\n            parentConstructionClone.actionDatas.length\n          ),\n        },\n      };\n    }),\n  ];\n\n  const childInitialActionsToAdd = [];\n  for (let i = 0; i < appendChildInitToParent.length; i++) {\n    if (appendChildInitToParent[i].appendToInitial) {\n      childInitialActionsToAdd.push({\n        idx: i + parentConstructionClone.actionDatas.length,\n        fraction: appendChildInitToParent[i].splitFrac,\n      });\n    } else if (appendChildInitToParent[i].indexInParent) {\n      newActionDatasArray[\n        appendChildInitToParent[i].indexInParent.actionIdx\n      ].actionMetadata.nextNodes[\n        appendChildInitToParent[i].indexInParent.nextNodeIdx\n      ].push({\n        fraction: appendChildInitToParent[i].splitFrac,\n        actionIdx: i + parentConstructionClone.actionDatas.length,\n      });\n    } else {\n      throw `Expected the appendChildInitToParent to either append to initial or contain info as to where to append in the parent`;\n    }\n  }\n\n  const newInitialActionIndices = [\n    ...parentConstructionClone.initialActionIndices,\n    ...childInitialActionsToAdd.map((c) => c.idx),\n  ];\n  const newIninitialSplits = [\n    ...parentConstructionClone.initialSplits,\n    ...childInitialActionsToAdd.map((c) => c.fraction),\n  ];\n  return {\n    actionDatas: newActionDatasArray,\n    initialActionIndices: newInitialActionIndices,\n    initialSplits: newIninitialSplits,\n    amount: parentConstructionClone.amount,\n  };\n};\n","export const getConstants = () => {\n  const env = process.env.REACT_APP_SOLANA_NETWORK;\n  switch (env) {\n    case \"devnet\":\n      return {\n        MALLOC_PROGRAM_ID: \"9i4MAnhYagLr1vEo5jdmLehRe8Sm5Lx8fHaQNJfbFCve\",\n        mallocSpl: {\n          TRANSFER_PROGRAM_ID: \"ETpyJNQLorJbAcrPQpM9bkYxYMakegBh93kqZ1KnTBjr\",\n          SWAP_PROGRAM_ID: \"7T6seoCvCQeUeSTf2EAwX5SnyrZvX7BFUMHi74ZodBKH\",\n          DUMMY_PASS_THROUGH: \"DBhGd4VREBAw14vV1yaLXfCTtanPBwQfEErg1fe27diJ\",\n          MINT_TO: \"77WQMNHSBe6BNdMY8R1FD4JX89o2fXr5FhKNerTcJsHJ\",\n        },\n        projectSerum: {\n          DEX_PROGRAM_ID: \"DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY\",\n        },\n        demo: {\n          FAKE_USDC: \"AkzN2jJrorpUY2ApfL2UsBeTfuv1XHFKGLQurZJg6BhN\",\n          FAKE_USDC_GD: \"2BB7fDrLgBNSMCLqD835GisCHrHrGHsS8SJr6brtnWk2\",\n          FAKE_TOKEN_A: \"9GmQdigrAFdX67EMrVFwMepEN8rEdMdp8CPUEPJRY8sj\",\n        },\n        INITIAL_SPLITTER_ID_UUID: \"initial\",\n        solana: {\n          RPC: \"https://explorer-api.devnet.solana.com\",\n          NETWORK: env,\n        },\n      };\n\n    default:\n      throw \"Unexpected env\";\n  }\n  throw \"Unexpected env\";\n};\n","export class Assignable {\n\tconstructor(properties) {\n\t\t\tObject.keys(properties).map((key) => {\n\t\t\t\t\tthis[key] = properties[key];\n\t\t\t});\n\t}\n}"],"sourceRoot":""}