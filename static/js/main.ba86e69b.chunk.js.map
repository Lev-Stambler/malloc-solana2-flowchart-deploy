{"version":3,"sources":["utils/spl-tokens.ts","utils/node-ids.ts","components/tokens/TokenAccountChooser.tsx","components/actions/SwapNode.tsx","utils/flow-chart-utils.ts","components/usdc-airdrop/perform-usdc-airdrop.ts","components/constructions/SidePanel.tsx","components/constructions/SplitterNode.tsx","components/actions/ActionTemplate.tsx","views/Flowchart.tsx","components/tx-handler/LoadingTX.tsx","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils/anchor.ts","utils/malloc.ts","utils/premade-nodes.ts","state/flowchart-store.ts","config/constants.ts","components/actions/Transfer.tsx"],"names":["SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","ASSOCIATED_TOKEN_PROGRAM_ID","getTokenLists","provider","a","solanaSplStore","state","tokenList","TokenListProvider","resolve","tokens","filterByClusterSlug","getConstants","solana","NETWORK","getList","setState","getDemoTokenInfo","usdcMint","PublicKey","demo","FAKE_USDC","aMint","FAKE_TOKEN_A","getMintInfo","usdcInfo","aInfo","chainId","name","symbol","address","getTokenListContainer","TokenListContainer","findAssociatedTokenAddress","walletAddress","tokenMintAddress","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","toReadableNumber","number","decimals","balance","toString","wholeStr","substring","length","fractionStr","padStart","value","pattern","test","replace","formatWithCommas","fromReadableNumber","split","wholePart","fracPart","Error","padEnd","findAllAssociatedTokenAddress","mints","Promise","all","map","m","getTokenAccountInfo","tokenAddr","connection","getAccountInfo","account","data","parseTokenAccount","console","error","mintAddr","parseMintAccount","getNodeType","id","getNodeId","uuid","getRandomNodeId","Math","random","getEdgeId","source","target","getModalStyle","top","left","transform","useStyles","makeStyles","theme","createStyles","paper","position","width","backgroundColor","palette","background","border","boxShadow","shadows","padding","spacing","TokenLine","tok","setChoosen","style","display","gridTemplateColumns","gap","onClick","info","shortenAddress","u64","TokenAccountChooser","props","onlyWithInitializedAccounts","classes","React","useState","modalStyle","open","setOpen","customTokenAccount","setCustomTokenAccount","customMintAccount","setCustomMintAccount","wallet","useAnchorWallet","choosen","solanaSplStoreHook","useStore","getProvider","loadTokens","publicKey","t","associatedAddr","addr","amount","bals","accounts","i","toBase58","accountsFiltered","filter","accountsMapped","mint","derivedTokenAccounts","useEffect","handleClose","onClose","choosenType","log","tokenAccount","tokAccountData","alert","mintInfo","bal","body","className","overflow","maxHeight","TextField","label","onChange","e","onFocus","type","buttonText","Modal","aria-labelledby","aria-describedby","SwapNode","outTok","setOutTok","toggleNodeInfoSet","setSwapInfo","setStoreUpdateLoading","buildSwapAccounts","projectSerum","DEX_PROGRAM_ID","web3","SYSVAR_RENT_PUBKEY","authority","inTokenAccount","outTokenAccount","inMint","outMint","serumDexProgramId","rent","swapInfo","side","Side","Bid","packSwapData","SwapInstructionByte","BasicSwap","nodeInfoStoreState","action","actionData","actionProgram","mallocSpl","SWAP_PROGRAM_ID","actionAccounts","swapAccountsToActionAccounts","swapAccounts","slice","tokenAccountsOuts","signers","openOrderAccount","tokenMintOuts","nodeInfoStore","mintName","Position","Bottom","isEdge","edgeToSourceAndTarget","getAllEdgesWithSource","elems","sourceId","getAllNodesWithEdgesFromSource","targetId","getAllEdgesWithTarget","getAllActionNodeIds","flowStore","elements","getTokenMintIn","priorSplitterMints","splitterId","splitter","firstNonNull","find","some","equals","getTokenAccountIn","priorSplitterTokAccount","buildEphemeralInstruction","actionMetadatas","allActions","actionNodeId","nextSplitterIds","nextNodes","nextActions","splitterI","splits","nextAction","actionI","actionIdx","indexOf","fraction","anchor","nodeId","ripeAmount","buildActionMetas","INITIAL_SPLITTER_ID_UUID","edgeId","getInitialSplitsAndNextIds","initSplits","initIds","actionTokenMintIns","allActionsFilled","actionId","actionInfo","tokenMintIn","actionMetadata","initIdxs","forEach","initTokenAccount","actions","initialSplits","initialActionIndices","initAmount","amountInAccount","compileAndRunFlow","setEphemeralRunLoading","loadingStore","storeUpdateLoading","res","rej","setTimeout","inst","mallocSdk","getMallocSdk","buildTxs","opts","associatedTokenAccounts","reduce","prior","splStore","sendRequests","skipPreflight","commitment","preflightCommitment","retHashes","richUSDCAirdroperSK","Uint8Array","richUSDCSigner","Wallet","Keypair","fromSecretKey","getRichUsdcProvider","endpointURL","Provider","Connection","performUsdcAirdrop","userAddr","tryCreateAssociatedAccount","RPC","tokAccount","airdrop","FAKE_USDC_GD","JSON","stringify","associated","createTokenAccount","gdUsdc","airDropToTokenAccounts","amountAirdrop","transferTxs","Transaction","add","Token","createTransferInstruction","send","ConstructionSidePanel","solwallet","useWallet","loadingStoreHook","airdropLoading","setAirdropLoading","Card","maxWidth","CardContent","Button","pushElemsFn","getDefaultTransferNodeSet","getDefaultSwapNodeSet","then","hashes","catch","disabled","setElemsFn","getInitSplitter","color","disconnect","getSplitterNode","pushElems","nodeInfoStateVals","numbSources","setNumbSources","amountInitIn","setAmountInitIn","setSplits","inputInitSplToken","setInputInitSplToken","flowState","nodeState","isInitial","expandedNumb","setEdgeAnimated","ind","animated","allEdges","edge","edgeInd","findIndex","edgeObj","setElemFn","inputNodes","inpNodeStates","n","every","tokenAccountOuts","undefined","newNumbSources","diff","Array","fill","paddingBottom","parsed","parseFloat","Top","onBlur","parseInt","setSplitAmounts","onConnect","conn","params","splitterTarget","handleConnectIn","getActionTemplate","ActionNode","setMint","setTokenAccount","setMintName","setToggleNodeInfoSet","setInfos","tokList","_mint","newMint","borderRadius","nodeTypes","swap","pushElemsOntoFlow","transfer","TransferNode","height","zIndex","LoadingTx","justifyContent","alignContent","justifyItems","loading","css","size","ConnectButton","styled","WalletDialogButton","Home","span","setBalance","loadingState","message","severity","alertState","setAlertState","Date","startDate","getBalance","LAMPORTS_PER_SOL","connected","marginTop","toLocaleString","Flowchart","ephemeralRunLoading","LoadingTX","Snackbar","autoHideDuration","Alert","config","MALLOC_PROGRAM_ID","network","rpcHost","startDateSeed","process","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSolletWallet","autoConnect","txTimeout","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","chars","MallocSdk","x","y","swapId","transferId","Store","initNodeStore","isLoading","elem","idx","newElems","env","TRANSFER_PROGRAM_ID","recipientAddr","setRecipientAddr","setRecipientAddrInStore","recipientPk","recipientTokAccountAddr","Buffer","from","isWriteable"],"mappings":"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","file":"static/js/main.ba86e69b.chunk.js","sourcesContent":["import { getProvider, Provider } from \"@project-serum/anchor\";\nimport { parseTokenAccount, parseMintAccount } from \"@project-serum/common\";\nimport {\n  AccountInfo,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  MintInfo,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport {\n  TokenListProvider,\n  TokenInfo,\n  TokenListContainer,\n} from \"@solana/spl-token-registry\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\nimport { solanaSplStore } from \"../state/flowchart-store\";\nimport { getTokenMintIn } from \"./flow-chart-utils\";\n\n// TODO: where does this come from?\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: PublicKey =\n  ASSOCIATED_TOKEN_PROGRAM_ID;\n\n// TODO: have a store for token metadata which has a list of all tokens as well as their metadata\n\n// See https://github.com/solana-labs/token-list\nexport const getTokenLists = async (provider: Provider): Promise<TokenInfo[]> => {\n  if (solanaSplStore.state.tokenList) return solanaSplStore.state.tokenList;\n  const tokens = await new TokenListProvider().resolve();\n  const tokenList = tokens\n    .filterByClusterSlug(getConstants().solana.NETWORK)\n    .getList();\n  solanaSplStore.setState({\n    ...solanaSplStore.state,\n    tokenList,\n  });\n\n  // Add in demo tokens\n  if (getConstants().solana.NETWORK === \"devnet\") {\n    return [...tokenList, ...(await getDemoTokenInfo(provider))];\n  } else {\n    return tokenList;\n  }\n};\n\nconst getDemoTokenInfo = async (provider: Provider): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(getConstants().demo.FAKE_USDC);\n  const aMint = new PublicKey(getConstants().demo.FAKE_TOKEN_A);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: getConstants().demo.FAKE_USDC,\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: getConstants().demo.FAKE_TOKEN_A,\n    },\n  ];\n};\n\nexport const getTokenListContainer = async (provider: Provider): Promise<TokenListContainer> =>\n  new TokenListContainer(await getTokenLists(provider));\n\n// See https://spl.solana.com/associated-token-account\nexport const findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        walletAddress.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(tokenMintAddress).toBuffer(),\n      ],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n};\n\nexport const toReadableNumber = (number: u64, decimals: number): string => {\n  function trimTrailingZeroes(value: string): string {\n    return value.replace(/\\.?0*$/, \"\");\n  }\n  function formatWithCommas(value: string): string {\n    const pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(value)) {\n      value = value.replace(pattern, \"$1,$2\");\n    }\n    return value;\n  }\n\n  const balance = number.toString();\n  const wholeStr = balance.substring(0, balance.length - decimals) || \"0\";\n  // TODO: correct?\n  const fractionStr = balance\n    .substring(balance.length - decimals)\n    .padStart(decimals, \"0\")\n    .substring(0, decimals);\n\n  return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);\n};\n\nexport const fromReadableNumber = (\n  number: number,\n  decimals: number\n): string => {\n  function trimLeadingZeroes(value: string): string {\n    value = value.replace(/^0+/, \"\");\n    if (value === \"\") {\n      return \"0\";\n    }\n    return value;\n  }\n\n  const split = number.toString().split(\".\");\n  const wholePart = split[0];\n  const fracPart = split[1] || \"\";\n  if (split.length > 2 || fracPart.length > decimals) {\n    throw new Error(`Cannot parse '${number}' as token amount`);\n  }\n  return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, \"0\"));\n};\n\nexport const findAllAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  mints: (PublicKey | string)[]\n): Promise<PublicKey[]> =>\n  Promise.all(mints.map((m) => findAssociatedTokenAddress(walletAddress, m)));\n\nexport const getTokenAccountInfo = async (\n  provider: Provider,\n  tokenAddr: PublicKey\n): Promise<AccountInfo | null> => {\n  const account = await provider.connection.getAccountInfo(tokenAddr);\n  if (!account) return null;\n  try {\n    const data = parseTokenAccount(account.data);\n    return data;\n  } catch (e) {\n    console.error(\"An error occured parsing the data, returning null\", e);\n    return null;\n  }\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n","import { FlowElementType } from \"../interfaces\";\n\nexport const getNodeType = (id: string): FlowElementType => id.split(\"-\")[0];\nexport const getNodeId = (name: FlowElementType, uuid: string) =>\n  `${name}-${uuid}`;\nexport const getRandomNodeId = (name: FlowElementType): string =>\n  getNodeId(name, Math.random().toString());\nexport const getEdgeId = (source: string, target: string): string =>\n  `edge~${source}^${target}`;\n","import React from \"react\";\nimport { makeStyles, Theme, createStyles } from \"@material-ui/core/styles\";\nimport Modal from \"@material-ui/core/Modal\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { useMemo } from \"react\";\nimport { useEffect } from \"react\";\nimport {\n  findAllAssociatedTokenAddress,\n  findAssociatedTokenAddress,\n  getMintInfo,\n  getTokenAccountInfo,\n  getTokenLists,\n  toReadableNumber,\n} from \"../../utils/spl-tokens\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { SPLToken } from \"../../interfaces\";\nimport { shortenAddress } from \"../../utils/malloc\";\nimport { Provider } from \"@project-serum/anchor\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { isBundle } from \"typescript\";\nimport { useState } from \"react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { useStore } from \"react-stores\";\nimport { solanaSplStore } from \"../../state/flowchart-store\";\nimport { u64 } from \"@solana/spl-token\";\n\nfunction getModalStyle() {\n  const top = 50;\n  const left = 50;\n\n  return {\n    top: `${top}%`,\n    left: `${left}%`,\n    transform: `translate(-${top}%, -${left}%)`,\n  };\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    paper: {\n      position: \"absolute\",\n      width: \"auto\",\n      backgroundColor: theme.palette.background.paper,\n      border: \"2px solid #000\",\n      boxShadow: theme.shadows[5],\n      padding: theme.spacing(2, 4, 3),\n    },\n  })\n);\n\nconst TokenLine = ({\n  tok,\n  setChoosen,\n}: {\n  tok: SPLToken;\n  setChoosen: () => void;\n}) => {\n  return (\n    <div\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: \"1fr 1fr 1fr 1fr\",\n        width: \"100%\",\n        gap: \"5px\",\n      }}\n    >\n      <button onClick={setChoosen}>Choose</button>\n      <div>{tok.info.name}</div>\n      <div>\n        {shortenAddress(tok.account)}\n        {tok.balance ? \"\" : \" (currently nonexistent)\"}\n      </div>\n      <div>\n        {toReadableNumber(new u64(tok.balance || 0), tok.info.decimals)}\n      </div>\n    </div>\n  );\n};\n\nexport default function TokenAccountChooser(props: {\n  buttonText?: string;\n  onlyWithInitializedAccounts?: boolean;\n  onClose: (tok: SPLToken) => void;\n}) {\n  const onlyWithInitializedAccounts = props.onlyWithInitializedAccounts ?? true;\n  const classes = useStyles();\n  // getModalStyle is not a pure function, we roll the style only on the first render\n  const [modalStyle] = React.useState(getModalStyle);\n  const [open, setOpen] = React.useState(false);\n  const [customTokenAccount, setCustomTokenAccount] = React.useState(\"\");\n  const [customMintAccount, setCustomMintAccount] = React.useState(\"\");\n  const wallet = useAnchorWallet();\n  // If it is -1, then the custom state is choosen\n  const [choosen, setChoosen] = useState(-1);\n  const solanaSplStoreHook = useStore(solanaSplStore);\n\n  const provider = getProvider(wallet!);\n\n  const loadTokens = async () => {\n    const tokenList = await getTokenLists(provider);\n    const associatedAddr = await findAllAssociatedTokenAddress(\n      wallet?.publicKey!,\n      tokenList.map((t) => t.address)\n    );\n    const bals = await Promise.all(\n      associatedAddr.map(async (addr) => {\n        const data = await getTokenAccountInfo(provider, addr);\n        return data?.amount;\n      })\n    );\n    const accounts = associatedAddr.map((addr, i) => {\n      return {\n        account: addr.toBase58(),\n        info: tokenList[i],\n        balance: bals[i],\n      };\n    });\n    const accountsFiltered = onlyWithInitializedAccounts\n      ? accounts.filter((i) => i.balance)\n      : accounts;\n    const accountsMapped = accountsFiltered.map((i) => {\n      return {\n        ...i,\n        info: {\n          ...i.info,\n          mint: new PublicKey(i.info.address),\n        },\n        balance: i.balance?.toString() || null,\n      };\n    });\n\n    solanaSplStore.setState({\n      ...solanaSplStoreHook,\n      derivedTokenAccounts: accountsMapped,\n    });\n  };\n\n  useEffect(() => {\n    loadTokens();\n  }, []);\n\n  const handleOpen = () => {\n    loadTokens();\n    setOpen(true);\n  };\n\n  const handleClose = async () => {\n    if (!solanaSplStoreHook.derivedTokenAccounts) {\n      setOpen(false);\n      return;\n    }\n    if (choosen >= 0)\n      props.onClose(solanaSplStoreHook.derivedTokenAccounts[choosen]);\n    else {\n      const choosenType = choosen === -1 ? \"TOKEN\" : \"MINT\";\n      console.log(choosenType)\n      if (\n        (choosenType === \"TOKEN\" && !customTokenAccount) ||\n        (choosenType === \"MINT\" && !customMintAccount)\n      ) {\n        setOpen(false);\n        return;\n      }\n\n      const tokenAccount =\n        choosenType === \"TOKEN\"\n          ? customTokenAccount\n          : (\n              await findAssociatedTokenAddress(\n                wallet!.publicKey,\n                customMintAccount\n              )\n            ).toBase58();\n      console.log(\"AAAAA\", tokenAccount, customMintAccount)\n      const tokAccountData = await getTokenAccountInfo(\n        provider,\n        new PublicKey(tokenAccount)\n      );\n      if (choosenType === \"TOKEN\" && !tokAccountData) {\n        alert(\"Looks like an invalid SPL Token Account was provided\");\n        setOpen(false);\n        return;\n      }\n      if (choosenType === \"MINT\" && props.onlyWithInitializedAccounts !== false && !tokAccountData) {\n        alert(\n          \"Looks like there is no initialized associated account with this mint\"\n        );\n        setOpen(false);\n        return;\n      }\n      const mintAddr =\n        choosenType === \"TOKEN\"\n          ? tokAccountData!.mint\n          : new PublicKey(customMintAccount);\n\n      const mintInfo = await getMintInfo(provider, mintAddr);\n      if (!mintInfo) {\n        alert(\"Looks like the mint associated with this token is invalid\");\n        setOpen(false);\n        return;\n      }\n      const bal = tokAccountData?.amount || new u64(0);\n      props.onClose({\n        balance: bal,\n        account: tokenAccount,\n        info: {\n          ...mintInfo,\n          mint: mintAddr,\n        },\n      });\n    }\n    setOpen(false);\n  };\n\n  const body = (\n    <div style={modalStyle} className={classes.paper}>\n      <h2 id=\"simple-modal-title\">Choose a token account</h2>\n      <p id=\"simple-modal-description\">\n        Choose from either your associated token accounts or add a custom\n        address\n      </p>\n      <div\n        className=\"options\"\n        style={{ overflow: \"scroll\", maxHeight: \"70vh\" }}\n      >\n        <div\n          style={{ display: \"grid\", gridTemplateColumns: \"1fr 1fr 1fr 1fr\" }}\n        >\n          <span></span>\n          <div>Mint Name</div>\n          <div>Token Account Address</div>\n          <div>Amount</div>\n        </div>\n        {!solanaSplStoreHook.derivedTokenAccounts\n          ? \"Loading...\"\n          : solanaSplStoreHook.derivedTokenAccounts.map((tok, i) => (\n              <div\n                key={`token-derived-account-${i}`}\n                style={{\n                  padding: \"0.5rem\",\n                  border: choosen === i ? \"1px solid black\" : \"0px\",\n                }}\n              >\n                <TokenLine tok={tok} setChoosen={() => setChoosen(i)} />\n                <br />\n              </div>\n            ))}\n        {/* TODO: add balance to the left of this once filled out */}\n        <div\n          style={{\n            padding: \"0.5rem\",\n            border: choosen === -1 ? \"1px solid black\" : \"0px\",\n          }}\n        >\n          <TextField\n            label=\"Custom Token Account\"\n            value={customTokenAccount}\n            onChange={(e) => setCustomTokenAccount(e.target.value)}\n            onFocus={() => setChoosen(-1)}\n          />\n        </div>\n        <p>Or</p>\n        <div\n          style={{\n            padding: \"0.5rem\",\n            border: choosen === -2 ? \"1px solid black\" : \"0px\",\n          }}\n        >\n          <TextField\n            label=\"Custom Mint Account\"\n            value={customMintAccount}\n            onChange={(e) => setCustomMintAccount(e.target.value)}\n            onFocus={() => setChoosen(-2)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <div>\n      <button type=\"button\" onClick={handleOpen}>\n        {props.buttonText || \"Choose Token Account\"}\n      </button>\n      <Modal\n        open={open}\n        onClose={handleClose}\n        aria-labelledby=\"simple-modal-title\"\n        aria-describedby=\"simple-modal-description\"\n      >\n        {body}\n      </Modal>\n    </div>\n  );\n}\n","import { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport {\n  buildSwapAccounts,\n  packSwapData,\n  Side,\n  swapAccountsToActionAccounts,\n  SwapInstructionByte,\n} from \"@malloc/spl\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React, { useEffect } from \"react\";\nimport { useState } from \"react\";\nimport ReactFlow, { Handle, Position } from \"react-flow-renderer\";\nimport { getConstants } from \"../../config/constants\";\nimport { SPLToken } from \"../../interfaces\";\nimport {\n  nodeInfoStore,\n  setStoreUpdateLoading,\n} from \"../../state/flowchart-store\";\nimport TokenAccountChooser from \"../tokens/TokenAccountChooser\";\nimport { ActionNodeProps } from \"./ActionTemplate\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { getTokenListContainer } from \"../../utils/spl-tokens\";\nimport { web3 } from \"@project-serum/anchor\";\nimport { u64 } from \"@solana/spl-token\";\n\n// const elements = [\n//   {\n//     id: \"2\",\n//     type: \"special\",\n//     position: { x: 100, y: 100 },\n//     data: { text: \"A custom node\" },\n//   },\n// ];\n\nconst SwapNode = (props: ActionNodeProps) => {\n  const wallet = useAnchorWallet();\n  const [outTok, setOutTok] = useState<SPLToken | null>(null);\n\n  useEffect(() => {\n    if (props.toggleNodeInfoSet !== null) setSwapInfo();\n  }, [props.toggleNodeInfoSet, outTok]);\n\n  const setSwapInfo = async () => {\n    console.log(\"kk\", outTok, props.tokenAccount, wallet)\n    if (!outTok || !props.tokenAccount || !wallet) return;\n    setStoreUpdateLoading(true);\n    console.log(\"kk\")\n    if (!props.mint) {\n      setStoreUpdateLoading(false);\n      return;\n    }\n\n    console.log(\"LLL\", props.mint.toBase58(), outTok.info.mint.toBase58());\n    const provider = getProvider(wallet!)\n    const swapInfo = await buildSwapAccounts({\n      provider,\n      tokenList: (await getTokenListContainer(provider)) as any,\n      authority: wallet.publicKey,\n      inTokenAccount: props.tokenAccount,\n      outTokenAccount: new PublicKey(outTok.account),\n      inMint: props.mint as PublicKey,\n      outMint: outTok.info.mint,\n      serumDexProgramId: new PublicKey(\n        getConstants().projectSerum.DEX_PROGRAM_ID\n      ),\n      rent: web3.SYSVAR_RENT_PUBKEY,\n    });\n    // TODO: do the stuff with sides...\n    // TODO: min out....\n    const side = Side.Bid\n    const data = packSwapData(SwapInstructionByte.BasicSwap, side, new u64(0))\n    console.log(\"DATA:\", data)\n    props.nodeInfoStoreState[props.id] = {\n      action: {\n        actionData: data, \n        actionProgram: new PublicKey(getConstants().mallocSpl.SWAP_PROGRAM_ID),\n        actionAccounts: swapAccountsToActionAccounts(\n          swapInfo.swapAccounts,\n          side\n        ).slice(3), // TODO: remove slice and have action for an action to put its own 3 in\n        tokenAccountsOuts: [new PublicKey(outTok.account)],\n        // instructions: [\n        //   swapInfo.openOrderInitInstr\n        // ],\n        signers: [swapInfo.openOrderAccount],\n        tokenMintOuts: [outTok.info.mint],\n      },\n    };\n    nodeInfoStore.setState(props.nodeInfoStoreState);\n    setStoreUpdateLoading(false);\n  };\n\n  return (\n    <div>\n      <h4>\n        Swap {props.mintName} to{\" \"}\n        {outTok?.info.name ||\n          outTok?.info.mint.toBase58() ||\n          \"<Out token not set>\"}\n      </h4>\n      <TokenAccountChooser\n        onClose={(tok) => setOutTok(tok)}\n        buttonText=\"Choose output token\"\n        onlyWithInitializedAccounts={false}\n      />\n      <Handle type=\"source\" position={Position.Bottom} id=\"b\" />\n    </div>\n  );\n};\n\nexport default SwapNode;\n","import { Connection, Edge, Elements } from \"react-flow-renderer\";\nimport * as anchor from \"@project-serum/anchor\";\nimport {\n  Action,\n  ActionMetadata,\n  BuildEphemeralTxsInstr,\n  NextNode,\n} from \"../../../../malloc-core/ts-packages/malloc-sdk/lib\";\nimport { FlowElementType, PushElemsFn } from \"../interfaces\";\n// import { getMallocSdk } from \"./malloc\";\nimport {\n  flowStore,\n  loadingStore,\n  nodeInfoStore,\n  setEphemeralRunLoading,\n  solanaSplStore,\n} from \"../state/flowchart-store\";\nimport { getConstants } from \"../config/constants\";\nimport { getEdgeId, getNodeId, getNodeType } from \"./node-ids\";\nimport { u64 } from \"@solana/spl-token\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getMallocSdk } from \"./malloc\";\nimport { BuildEphemeralOpts } from \"@malloc/sdk\";\n\nconst isEdge = (id: string) => id.split(\"~\")[0] === \"edge\";\nconst edgeToSourceAndTarget = (id: string): string[] =>\n  id.split(\"~\")[1].split(\"^\");\n\n/**\n * @returns true if an edge was added, false otherwise\n */\nexport const handleConnectIn = (\n  params: Connection,\n  pushElems: PushElemsFn,\n  splitterTarget = true\n): boolean => {\n  if (\n    !params.source ||\n    !params.target ||\n    (splitterTarget\n      ? getNodeType(params.source || \"\") === \"splitter\"\n      : getNodeType(params.target || \"\") === \"splitter\")\n  ) {\n    return false;\n  }\n  const edge: Edge = {\n    id: getEdgeId(params.source, params.target),\n    source: params.source,\n    target: params.target,\n  };\n  pushElems([edge]);\n  return true;\n};\n\nexport const getAllEdgesWithSource = (\n  elems: Elements<any>,\n  sourceId: string\n): string[] => {\n  return elems\n    .filter((e) => isEdge(e.id) && edgeToSourceAndTarget(e.id)[0] === sourceId)\n    .map((e) => e.id);\n}\n\nexport const getAllNodesWithEdgesFromSource= (\n  elems: Elements<any>,\n  targetId: string\n) =>\n  getAllEdgesWithSource(elems, targetId).map(\n    (e) => edgeToSourceAndTarget(e)[1]\n  );\n\n;\n\nexport const getAllNodesWithEdgesToTarget = (\n  elems: Elements<any>,\n  targetId: string\n) =>\n  getAllEdgesWithTarget(elems, targetId).map(\n    (e) => edgeToSourceAndTarget(e)[0]\n  );\n\nexport const getAllEdgesWithTarget = (\n  elems: Elements<any>,\n  targetId: string\n): string[] => {\n  return elems\n    .filter((e) => isEdge(e.id) && edgeToSourceAndTarget(e.id)[1] === targetId)\n    .map((e) => e.id);\n};\n\nconst getInitialSplitsAndNextIds = (): [number[], string[]] => {\n  const splits =\n    nodeInfoStore.state[\n      getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID)\n    ].splitter?.splits;\n  if (!splits) throw \"Expected to get the splits from the initial splitter\";\n  const nextIds = getAllEdgesWithSource(\n    flowStore.state.elements,\n    getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID)\n  ).map((edgeId) => edgeToSourceAndTarget(edgeId)[1]);\n  return [splits, nextIds];\n};\n\nconst getAllActionNodeIds = (): string[] => {\n  return flowStore.state.elements\n    .filter((e) => !isEdge(e.id) && getNodeType(e.id) !== \"splitter\")\n    .map((e) => e.id);\n};\n\nconst buildActionMetas = (): (ActionMetadata & { nodeId: string })[] => {\n  const allActions = getAllActionNodeIds();\n  return allActions.map((actionNodeId) => {\n    const nextSplitterIds = getAllNodesWithEdgesFromSource(\n      flowStore.state.elements,\n      actionNodeId\n    );\n    console.log(nextSplitterIds)\n    const nextSplittersNextActions = nextSplitterIds.map((id) =>\n      getAllNodesWithEdgesFromSource(flowStore.state.elements, id)\n    );\n    const nextNodes: NextNode[][] = nextSplittersNextActions.map(\n      (nextActions, splitterI) => {\n        console.log(splitterI, nextSplitterIds)\n        const splitterId = nextSplitterIds[splitterI];\n        const splits = nodeInfoStore.state[splitterId].splitter?.splits;\n        if (!splits) throw \"Expected to find splitter information\";\n        return nextActions.map((nextAction, actionI) => {\n          return {\n            actionIdx: allActions.indexOf(nextAction),\n            fraction: new anchor.BN(splits[actionI]),\n          };\n        });\n      }\n    );\n    return {\n      nodeId: actionNodeId,\n      ripeAmount: getAllEdgesWithTarget(flowStore.state.elements, actionNodeId)\n        .length,\n      nextNodes: nextNodes,\n    };\n  });\n};\n\nexport const getTokenMintIn = (id: string): PublicKey | null => {\n  const elems = flowStore.state.elements;\n  const priorSplitterMints = getAllEdgesWithTarget(elems, id).map((e) => {\n    const splitterId = edgeToSourceAndTarget(e)[0];\n    const mint = nodeInfoStore.state[splitterId].splitter?.mint;\n    if (!mint) return null;\n    return mint;\n  });\n  if (priorSplitterMints.length === 0) return null;\n  const firstNonNull = priorSplitterMints.find((m) => !!m);\n  if (!firstNonNull) return null;\n  if (\n    priorSplitterMints\n      .filter((m) => !!m)\n      .some((mint) => !mint!.equals(firstNonNull))\n  )\n    throw `Inconsistent prior token mint address for node with id ${id}`;\n\n  // Ensure all the prior mints are filled\n  if (priorSplitterMints.some((m) => !m)) return null;\n  return firstNonNull;\n};\n\n// TODO: this assumes that the token account in is the same as the out from the last node, this is not always true\nexport const getTokenAccountIn = (id: string): PublicKey | null => {\n  const elems = flowStore.state.elements;\n  const priorSplitterTokAccount = getAllEdgesWithTarget(elems, id).map((e) => {\n    const splitterId = edgeToSourceAndTarget(e)[0];\n    const tokenAccount = nodeInfoStore.state[splitterId].splitter?.tokenAccount;\n    if (!tokenAccount) return null;\n    return tokenAccount;\n  });\n  if (priorSplitterTokAccount.length === 0) return null;\n  const firstNonNull = priorSplitterTokAccount.find((m) => !!m);\n  if (!firstNonNull) return null;\n  if (\n    priorSplitterTokAccount\n      .filter((m) => !!m)\n      .some((mint) => !mint!.equals(firstNonNull))\n  )\n    throw `Inconsistent prior token account address for node with id ${id}`;\n\n  // Ensure all the prior mints are filled\n  if (priorSplitterTokAccount.some((m) => !m)) return null;\n  return firstNonNull;\n};\n\nexport const getAllTokenMintsIn = (actionIds: string[]): PublicKey[] =>\n  actionIds.map(getTokenMintIn).map((e) => {\n    if (!e) throw \"Expected all token mints to be filled\";\n    return e;\n  });\n\nexport const getAssociatedTokenAccounts = () =>\n  (solanaSplStore.state.derivedTokenAccounts || []).reduce(\n    (prior, splStore) => {\n      prior[splStore.info.mint.toBase58()] = new PublicKey(splStore.account);\n      return prior;\n    },\n    {} as BuildEphemeralOpts[\"associatedTokenAccounts\"]\n  );\n\nexport const buildEphemeralInstruction = (): BuildEphemeralTxsInstr => {\n  const actionMetadatas = buildActionMetas();\n  const [initSplits, initIds] = getInitialSplitsAndNextIds();\n  const allActions = getAllActionNodeIds();\n\n  const actionTokenMintIns = allActions.map(getTokenMintIn);\n\n  const allActionsFilled: Action[] = allActions.map((actionId, i) => {\n    const actionInfo = nodeInfoStore.state[actionId]?.action;\n    if (!actionInfo) throw `Missing action info for node of id ${actionId}`;\n    const tokenMintIn = actionTokenMintIns[i];\n    if (!tokenMintIn)\n      throw `Missing input token mint for node of id ${tokenMintIn}`;\n    return {\n      ...actionInfo,\n      actionMetadata: actionMetadatas[i],\n      tokenMintIn,\n    };\n  });\n  console.log(\"LLL\", allActionsFilled)\n  const initIdxs = initIds.map((id) => allActions.indexOf(id));\n  console.log(actionMetadatas, initIdxs, initSplits);\n\n  initIdxs.forEach((i) => {\n    if (i < 0) throw \"An unexpected error occured in building the action list\";\n  });\n  const initTokenAccount = flowStore.state.initTokenAccount;\n  if (!initTokenAccount) throw \"Init token account not set\";\n\n  return {\n    actions: allActionsFilled, // TODO: ACTION, authority for amount in and construction, ALSO, add \"output address\" to transfer\n    initialSplits: initSplits,\n    initialActionIndices: initIdxs,\n    amount: new u64(flowStore.state.initAmount),\n    amountInAccount: initTokenAccount!,\n  };\n};\n\nexport const compileAndRunFlow = async (\n  wallet: anchor.Provider\n): Promise<string[]> => {\n  setEphemeralRunLoading(true);\n  try {\n    while (loadingStore.state.storeUpdateLoading) {\n      await new Promise((res, rej) => setTimeout(res, 50));\n    }\n\n    const inst = buildEphemeralInstruction();\n    const mallocSdk = getMallocSdk(wallet);\n    const data = await mallocSdk.buildTxs({\n      ...inst,\n      opts: {\n        associatedTokenAccounts: getAssociatedTokenAccounts(),\n      },\n    });\n    console.log(data, \"Loading...\");\n    const retHashes = await mallocSdk.sendRequests(data, {\n      skipPreflight: true,\n      // skipPreflight: false,\n      commitment: \"confirmed\",\n      preflightCommitment: \"confirmed\",\n    });\n\n    setEphemeralRunLoading(false);\n    return retHashes;\n  } catch (e) {\n    setEphemeralRunLoading(false);\n    throw e;\n  }\n};\n","import { Wallet } from \"@project-serum/anchor\";\nimport { createTokenAccount, Provider } from \"@project-serum/common\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { Connection, Keypair, PublicKey, Transaction } from \"@solana/web3.js\";\nimport { getConstants } from \"../../config/constants\";\n\nconst richUSDCAirdroperSK = new Uint8Array([\n  8, 57, 204, 222, 105, 129, 113, 8, 245, 54, 20, 45, 122, 175, 82, 37, 32, 44,\n  46, 6, 54, 35, 168, 208, 213, 194, 164, 50, 97, 226, 134, 119, 136, 196, 213,\n  189, 243, 233, 16, 53, 22, 220, 245, 4, 17, 203, 251, 233, 20, 7, 178, 5, 36,\n  19, 66, 89, 210, 148, 19, 225, 117, 61, 214, 253,\n]);\n\nconst richUSDCSigner = new Wallet(Keypair.fromSecretKey(richUSDCAirdroperSK));\n\nconst getRichUsdcProvider = (endpointURL: string) =>\n  new Provider(new Connection(endpointURL), richUSDCSigner, {});\n\nexport const performUsdcAirdrop = async (userAddr: PublicKey) => {\n  try {\n    const tokAccount = await tryCreateAssociatedAccount(\n      new PublicKey(getConstants().demo.FAKE_USDC),\n      userAddr,\n      getRichUsdcProvider(getConstants().solana.RPC)\n    );\n    await airdrop(new PublicKey(getConstants().demo.FAKE_USDC_GD), [\n      tokAccount,\n    ]);\n    alert(\"Done with your airdrop\");\n  } catch (e) {\n\t\tconsole.error(e)\n    alert(`An error occurred with the airdrop ${JSON.stringify(e)}`);\n  }\n};\n\nconst tryCreateAssociatedAccount = async (\n  mint: PublicKey,\n  account: PublicKey,\n  provider: Provider\n): Promise<PublicKey> => {\n  const associated = (\n    await PublicKey.findProgramAddress(\n      [\n        account.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(mint).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n  const data = await provider.connection.getAccountInfo(associated);\n  if (!data) {\n    return await createTokenAccount(provider, mint, account);\n  }\n  return associated;\n};\n\nconst airdrop = async (\n  gdUsdc: PublicKey,\n  airDropToTokenAccounts: PublicKey[]\n) => {\n  const decimals = 6;\n  const amountAirdrop = 1 * 10 ** decimals;\n\n  const transferTxs: Transaction = new Transaction();\n  airDropToTokenAccounts.map((tokAccount) => {\n    transferTxs.add(\n      Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        gdUsdc,\n        tokAccount,\n        richUSDCSigner.publicKey,\n        [],\n        amountAirdrop\n      )\n    );\n  });\n\n  await getRichUsdcProvider(getConstants().solana.RPC).send(transferTxs, [], {\n    skipPreflight: true,\n  });\n};\n","import Button from \"@material-ui/core/Button\";\nimport React, { useState } from \"react\";\nimport Card from \"@material-ui/core/Card\";\nimport CardActions from \"@material-ui/core/CardActions\";\nimport CardContent from \"@material-ui/core/CardContent\";\nimport { FlowElement } from \"react-flow-renderer\";\nimport { PushElemsFn, SetElemsFn } from \"../../interfaces\";\nimport {\n  getDefaultSwapNodeSet,\n  getDefaultTransferNodeSet,\n  getInitSplitter,\n} from \"../../utils/premade-nodes\";\nimport { compileAndRunFlow } from \"../../utils/flow-chart-utils\";\nimport { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\nimport { Provider, Wallet } from \"@project-serum/anchor\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getConstants } from \"../../config/constants\";\nimport { loadingStore } from \"../../state/flowchart-store\";\nimport { useStore } from \"react-stores\";\nimport { performUsdcAirdrop } from \"../usdc-airdrop/perform-usdc-airdrop\";\n\nconst ConstructionSidePanel = (props: {\n  pushElemsFn: PushElemsFn;\n  setElemsFn: SetElemsFn;\n}) => {\n  const solwallet = useWallet();\n  const wallet = useAnchorWallet();\n  const loadingStoreHook = useStore(loadingStore);\n  const [airdropLoading, setAirdropLoading] = useState(false);\n\n  const compileAndRun = () => {\n    // TODO: move into malloc sdk?\n    if (!wallet) throw \"Expected the wallet to be connected\";\n    const provider = new Provider(\n      new Connection(getConstants().solana.RPC),\n      wallet,\n      {\n        skipPreflight: true, // TODO: to keep?\n        preflightCommitment: \"confirmed\",\n      }\n    );\n    compileAndRunFlow(provider)\n      .then((hashes) => {\n        alert(\"Ran successfully!\");\n      })\n      .catch((e) => {\n        alert(`An error occured: ${e}`);\n        console.error(e);\n      });\n  };\n  return (\n    <Card style={{ maxWidth: \"300px\" }}>\n      <CardContent\n        style={{ display: \"grid\", gridTemplateColumns: \"1fr\", gap: \"1rem\" }}\n      >\n        {/* <Button onClick={() => props.pushElemsFn([getDefaultSplitterNode()])}>\n          Add Splitter\n        </Button> */}\n        <Button onClick={() => props.pushElemsFn(getDefaultTransferNodeSet())}>\n          Add Transfer Action\n        </Button>\n        <Button onClick={() => props.pushElemsFn(getDefaultSwapNodeSet())}>\n          Add Swap Action\n        </Button>\n        <Button\n          onClick={compileAndRun}\n          disabled={loadingStoreHook.storeUpdateLoading}\n        >\n          Compile and Run\n        </Button>\n        <br />\n        {/* {airdropLoading && <>Loading Airdrop...</>} */}\n        <Button\n          onClick={() => {\n            setAirdropLoading(true);\n            performUsdcAirdrop(wallet!.publicKey!).then(() =>\n              setAirdropLoading(false)\n            );\n          }}\n          disabled={airdropLoading}\n        >\n          Airdrop fake USDC\n        </Button>\n        <br />\n        <Button\n          onClick={() => props.setElemsFn([getInitSplitter()])}\n          color=\"secondary\"\n        >\n          Delete all\n        </Button>\n\n        <Button onClick={() => solwallet.disconnect()} color=\"secondary\">\n          Sign Out\n        </Button>\n        {/* <Button>Add Swap Action</Button> */}\n        {/* <Button>Add Swap Action</Button> */}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default ConstructionSidePanel;\n","import Button from \"@material-ui/core/Button\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { BN } from \"@project-serum/anchor\";\nimport { u64 } from \"@solana/spl-token\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React, { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport ReactFlow, {\n  FlowElement,\n  Handle,\n  Position,\n  Node as FlowNode,\n  Connection,\n  Edge,\n} from \"react-flow-renderer\";\nimport { useStore } from \"react-stores\";\nimport { PushElemsFn, SPLToken } from \"../../interfaces\";\nimport {\n  flowStore,\n  nodeInfoStore,\n  setElemFn,\n} from \"../../state/flowchart-store\";\nimport { getProvider } from \"../../utils/anchor\";\nimport {\n  getAllEdgesWithSource,\n  getAllEdgesWithTarget,\n  getAllNodesWithEdgesToTarget,\n  handleConnectIn,\n} from \"../../utils/flow-chart-utils\";\nimport { fromReadableNumber, getTokenLists } from \"../../utils/spl-tokens\";\nimport TokenAccountChooser from \"../tokens/TokenAccountChooser\";\n\n// const elements = [\n//   {\n//     id: \"2\",\n//     type: \"special\",\n//     position: { x: 100, y: 100 },\n//     data: { text: \"A custom node\" },\n//   },\n// ];\n\nexport const getSplitterNode = (pushElems: PushElemsFn) => {\n  return (props: { data: { isInitial?: boolean; id: string } }) => {\n    const elements = useStore(flowStore);\n    const nodeInfoStateVals = useStore(nodeInfoStore);\n    const wallet = useAnchorWallet();\n    const [numbSources, setNumbSources] = useState(0);\n    const [amountInitIn, setAmountInitIn] = useState(0);\n    const [splits, setSplits] = useState<number[]>([]);\n    const [inputInitSplToken, setInputInitSplToken] = useState<null | SPLToken>(\n      null\n    );\n    const flowState = useStore(flowStore);\n    const nodeState = useStore(nodeInfoStore);\n\n    useEffect(() => {\n      if (!props.data?.isInitial) return;\n      if (!inputInitSplToken) return;\n\n      const expandedNumb = fromReadableNumber(\n        amountInitIn,\n        inputInitSplToken.info.decimals\n      );\n      const initAmount = new u64(expandedNumb);\n      flowStore.setState({\n        ...elements,\n        initAmount,\n      });\n    }, [amountInitIn, inputInitSplToken]);\n\n    useEffect(() => {\n      if (!inputInitSplToken?.account) return;\n      if (!props.data?.isInitial) return;\n      flowStore.setState({\n        ...elements,\n        initTokenAccount: new PublicKey(inputInitSplToken?.account),\n      });\n    }, [inputInitSplToken]);\n\n    const setEdgeAnimated = (ind: number, animated: boolean) => {\n      const allEdges = getAllEdgesWithSource(elements.elements, props.data.id);\n      if (allEdges.length < ind) {\n        alert(\"The flow chart is malformed, please start over\");\n        throw \"The flow chart is malformed, please start over\";\n      }\n      const edge = allEdges[ind];\n      const edgeInd = elements.elements.findIndex((e) => e.id === edge);\n      const edgeObj = elements.elements[edgeInd] as Edge;\n      edgeObj.animated = animated;\n      setElemFn(edgeObj, edgeInd);\n    };\n\n    // Update the incoming mint for a non initial splitter\n    useEffect(() => {\n      if (props.data.isInitial) return;\n      (async () => {\n        const tokList = await getTokenLists(getProvider(wallet!));\n        const inputNodes = getAllNodesWithEdgesToTarget(\n          flowState.elements,\n          props.data.id\n        );\n        if (inputNodes.length === 0) return;\n        const inpNodeStates = inputNodes.map((id) => nodeState[id]);\n        if (inpNodeStates.some((n) => !n || !n.action)) return;\n        // TODO:!!! only assume 1 token mint out right now, this will change shortly...\n        if (\n          !inpNodeStates.every(\n            (n) =>\n              n.action!.tokenMintOuts[0] ===\n              inpNodeStates[0].action!.tokenMintOuts[0]\n          )\n        ) {\n          throw \"Expected all input mints to be the same into splitter\";\n        }\n        if (inpNodeStates[0].action!.tokenMintOuts.length === 0) return;\n        const mint = inpNodeStates[0].action!.tokenMintOuts[0];\n        // TODO: there has to be something else here... all token accounts per mint must be the same\n        const tokenAccountOuts = inpNodeStates[0].action!.tokenAccountsOuts[0];\n        nodeInfoStateVals[props.data.id] = {\n          splitter: {\n            splits,\n            tokenAccount: tokenAccountOuts,\n            mint: mint ?? undefined,\n          },\n        };\n        console.log(\n          \"Setting Splitter Mint\",\n          mint.toBase58(),\n          \"with id\",\n          props.data.id\n        );\n        // Do not update the state if the values already equal\n        if (\n          nodeState[props.data.id].splitter?.mint?.toBase58() ===\n            mint.toBase58() &&\n          nodeState[props.data.id].splitter?.tokenAccount?.toBase58() ===\n            tokenAccountOuts.toBase58()\n        ) {\n          return;\n        }\n        console.log(\"Setting Splitter Mint\", mint.toBase58());\n        nodeInfoStore.setState({ ...nodeInfoStateVals });\n      })();\n    }, [flowState, nodeState]);\n\n    useEffect(() => {\n      // TODO: for splitter not init!\n      const mint = props.data.isInitial\n        ? inputInitSplToken?.info.mint\n        : undefined;\n      const tokenAccount = props.data.isInitial\n        ? inputInitSplToken\n          ? new PublicKey(inputInitSplToken.account)\n          : undefined\n        : undefined;\n      nodeInfoStateVals[props.data.id] = {\n        splitter: {\n          splits,\n          tokenAccount,\n          mint: mint ?? undefined,\n        },\n      };\n      nodeInfoStore.setState({ ...nodeInfoStateVals });\n    }, [splits]);\n\n    useEffect(() => {\n      const edgesWithSources = getAllEdgesWithSource(\n        elements.elements,\n        props.data.id\n      );\n      const newNumbSources = edgesWithSources.length;\n      const diff = newNumbSources - numbSources;\n      if (diff < 0) {\n        setSplits([...splits.slice(0, splits.length + diff)]);\n      } else {\n        setSplits([...splits, ...Array(diff).fill(100)]);\n      }\n      setNumbSources(newNumbSources);\n      // setNumbSources(\n      //   getAllEdgesWithSource(elements.elements, props.data.id).length\n      // );\n    }, [elements]);\n\n    const setSplitAmounts = (e: any, i: number) => {\n      splits[i] = parseInt(e.target.value);\n      setSplits([...splits]);\n    };\n\n    return (\n      <div\n        style={{\n          padding: \"1rem\",\n        }}\n      >\n        <h4>{props.data?.isInitial ? \"Initial Splitter\" : \"Splitter\"}</h4>\n        {props.data?.isInitial && (\n          <TokenAccountChooser onClose={setInputInitSplToken} />\n        )}\n        {props.data?.isInitial && (\n          <div style={{ paddingBottom: \"3rem\" }}>\n            <TextField\n              label={`amount in of ${\n                inputInitSplToken?.info.name ??\n                inputInitSplToken?.info.mint.toBase58() ??\n                \"<Input token account not set>\"\n              }`}\n              type=\"number\"\n              value={amountInitIn}\n              onChange={(e) => {\n                try {\n                  if (!e.target.value) return;\n                  const parsed = parseFloat(e.target.value);\n                  setAmountInitIn(parsed);\n                } catch (e) {\n                  alert(\"Looks like an invalid number was inputted\");\n                }\n              }}\n            />\n          </div>\n        )}\n        {!props.data?.isInitial && (\n          <Handle\n            type=\"target\"\n            position={Position.Top}\n            // onConnect={(conn) => {\n            //   handleConnectIn(conn, pushElems);\n            // }}\n          />\n        )}\n        {new Array(numbSources).fill(0).map((e, i) => (\n          <div key={`splitter-frac-${i}`}>\n            <TextField\n              type=\"number\"\n              label=\"Fractional Amount\"\n              onFocus={() => setEdgeAnimated(i, true)}\n              onBlur={() => setEdgeAnimated(i, false)}\n              value={splits[i]}\n              onChange={(e) => setSplitAmounts(e, i)}\n            />\n          </div>\n        ))}\n\n        <Handle\n          type=\"source\"\n          position={Position.Bottom}\n          onConnect={(conn) => {\n            const added = handleConnectIn(conn, pushElems, false);\n          }}\n          id=\"a\"\n          style={{\n            left: `50%`,\n          }}\n        />\n      </div>\n    );\n  };\n};\n","import TextField from \"@material-ui/core/TextField\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React, { ReactElement } from \"react\";\nimport { useEffect } from \"react\";\nimport { useState } from \"react\";\nimport ReactFlow, {\n  Edge,\n  FlowElement,\n  Handle,\n  Position,\n} from \"react-flow-renderer\";\nimport { useStore } from \"react-stores\";\nimport { getConstants } from \"../../config/constants\";\nimport { PushElemsFn } from \"../../interfaces\";\nimport {\n  flowStore,\n  IFlowChart,\n  NodeInfos,\n  nodeInfoStore,\n  setStoreUpdateLoading,\n} from \"../../state/flowchart-store\";\nimport { getProvider } from \"../../utils/anchor\";\nimport {\n  getTokenAccountIn,\n  getTokenMintIn,\n  handleConnectIn,\n} from \"../../utils/flow-chart-utils\";\nimport {\n  findAssociatedTokenAddress,\n  getTokenLists,\n} from \"../../utils/spl-tokens\";\n\nexport interface ActionNodeProps {\n  id: string;\n  flowState: IFlowChart;\n  nodeInfoStoreState: NodeInfos;\n  mintName: string;\n  toggleNodeInfoSet: boolean | null;\n  mint: PublicKey | null;\n  tokenAccount: PublicKey | null;\n}\n\nexport const getActionTemplate =\n  (\n    pushElems: PushElemsFn,\n    ActionNode: (props: ActionNodeProps) => ReactElement<ActionNodeProps>\n  ) =>\n  (props: { id: string }) => {\n    const nodeInfoStoreState = useStore(nodeInfoStore);\n    const wallet = useAnchorWallet();\n    const [mint, setMint] = useState(getTokenMintIn(props.id));\n    const [tokenAccount, setTokenAccount] = useState<PublicKey | null>(null);\n\n    const [mintName, setMintName] = useState(\"<not set>\");\n    const [toggleNodeInfoSet, setToggleNodeInfoSet] = useState<boolean | null>(\n      null\n    );\n    const flowState = useStore(flowStore);\n\n    const setInfos = async () => {\n      const tokList = await getTokenLists(getProvider(wallet!));\n      const tok = tokList.find((_mint) => _mint.address === mint?.toBase58());\n      setTokenAccount(await getTokenAccountIn(props.id));\n      setMintName(tok?.name || mint?.toBase58() || \"<not set>\");\n      setToggleNodeInfoSet(!toggleNodeInfoSet);\n    };\n    useEffect(() => {\n      setInfos();\n    }, [mint]);\n\n    useEffect(() => {\n      if (mint) setToggleNodeInfoSet(!toggleNodeInfoSet);\n      setInfos();\n    }, []);\n\n    useEffect(() => {\n      const newMint = getTokenMintIn(props.id);\n      if (newMint && (!mint || newMint?.equals(mint) === false)) {\n        setMint(newMint);\n        setToggleNodeInfoSet(!toggleNodeInfoSet);\n      }\n    }, [flowState, nodeInfoStoreState]);\n\n    return (\n      <div className=\"flow-chart-node\">\n        <Handle\n          // onConnect={(conn) => handleConnectIn(conn, pushElems, false)}\n          type=\"target\"\n          position={Position.Top}\n          style={{ borderRadius: 0 }}\n        />\n        <ActionNode\n          tokenAccount={tokenAccount}\n          id={props.id}\n          flowState={flowState}\n          nodeInfoStoreState={nodeInfoStoreState}\n          mintName={mintName}\n          toggleNodeInfoSet={toggleNodeInfoSet}\n          mint={mint}\n        />\n      </div>\n    );\n  };\n","import React from \"react\";\nimport { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport { useStore } from \"react-stores\";\nimport ReactFlow, { Elements, FlowElement } from \"react-flow-renderer\";\nimport SwapNode from \"../components/actions/SwapNode\";\nimport ConstructionSidePanel from \"../components/constructions/SidePanel\";\nimport { getSplitterNode } from \"../components/constructions/SplitterNode\";\nimport {\n  flowStore,\n  pushElemsOntoFlow,\n  setElemsFn,\n} from \"../state/flowchart-store\";\nimport { getActionTemplate } from \"../components/actions/ActionTemplate\";\nimport { TransferNode } from \"../components/actions/Transfer\";\n\nexport default () => {\n  const elements = useStore(flowStore);\n\n  useEffect(() => {}, []);\n\n  const nodeTypes = {\n    swap: getActionTemplate(pushElemsOntoFlow, SwapNode),\n    transfer: getActionTemplate(pushElemsOntoFlow, TransferNode),\n    splitter: getSplitterNode(pushElemsOntoFlow),\n  };\n\n  return (\n    <div style={{ height: \"100%\", width: \"100%\", padding: \"1rem\" }}>\n      <div style={{ position: \"absolute\", zIndex: 100 }}>\n        <ConstructionSidePanel\n          pushElemsFn={pushElemsOntoFlow}\n          setElemsFn={setElemsFn}\n        />\n      </div>\n      {<ReactFlow elements={elements.elements} nodeTypes={nodeTypes} />}\n    </div>\n  );\n};\n","import PacmanLoader from \"react-spinners/PacmanLoader\";\nimport {css} from '@emotion/react'\n\nconst LoadingTx = () => {\n  return (\n    <div\n      className=\"full-screen greyed\"\n      style={{\n        display: \"grid\",\n        justifyContent: \"center\",\n        alignContent: \"center\",\n\t\t\t\tjustifyItems: 'center',\n\t\t\t\tgridTemplateColumns: '1fr'\n      }}\n    >\n\t\t\t\n      <PacmanLoader loading={true} css={css`\n\t\t\t\theight: 200px;\t\n\t\t\t`} size={80}/>\n      <h3>Waiting while the Solana Network eats your gas fees</h3>\n    </div>\n  );\n};\nexport default LoadingTx;\n","import { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport Countdown from \"react-countdown\";\nimport { Button, CircularProgress, Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\n\nimport * as anchor from \"@project-serum/anchor\";\n\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\n\nimport {\n  CandyMachine,\n  awaitTransactionSignatureConfirmation,\n  mintOneToken,\n  shortenAddress,\n} from \"./utils/malloc\";\nimport Flowchart from \"./views/Flowchart\";\nimport { useStore } from \"react-stores\";\nimport { loadingStore } from \"./state/flowchart-store\";\nimport LoadingTX from \"./components/tx-handler/LoadingTX\";\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nconst CounterText = styled.span``; // add your styles here\n\nexport interface HomeProps {\n  config: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  startDate: number;\n  txTimeout: number;\n}\n\nconst Home = (props: HomeProps) => {\n  const [balance, setBalance] = useState<number>();\n  const [isActive, setIsActive] = useState(false); // true when countdown completes\n  const [isSoldOut, setIsSoldOut] = useState(false); // true when items remaining is zero\n  const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n  const loadingState = useStore(loadingStore);\n\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n\n  const [startDate, setStartDate] = useState(new Date(props.startDate));\n\n  const wallet = useWallet();\n  const [candyMachine, setCandyMachine] = useState<CandyMachine>();\n\n  useEffect(() => {\n    (async () => {\n      if (wallet?.publicKey) {\n        const balance = await props.connection.getBalance(wallet.publicKey);\n        setBalance(balance / LAMPORTS_PER_SOL);\n      }\n    })();\n  }, [wallet, props.connection]);\n\n  return (\n    <main>\n      {wallet.connected && (\n        <p style={{ marginTop: 0 }}>\n          Address: {shortenAddress(wallet.publicKey?.toBase58() || \"\")}\n        </p>\n      )}\n\n      {wallet.connected && (\n        <p>Balance: {(balance || 0).toLocaleString()} SOL</p>\n      )}\n      {wallet.connected && <Flowchart />}\n      {!wallet.connected && <ConnectButton>Connect Wallet</ConnectButton>}\n      {loadingState.ephemeralRunLoading && <LoadingTX />}\n      <Snackbar\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n    </main>\n  );\n};\n\ninterface AlertState {\n  open: boolean;\n  message: string;\n  severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nconst renderCounter = ({ days, hours, minutes, seconds, completed }: any) => {\n  return (\n    <CounterText>\n      {hours} hours, {minutes} minutes, {seconds} seconds\n    </CounterText>\n  );\n};\n\nexport default Home;\n","import \"./App.css\";\nimport { useMemo } from \"react\";\n\nimport Home from \"./Home\";\n\nimport * as anchor from \"@project-serum/anchor\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n  ConnectionProvider,\n  WalletProvider,\n} from \"@solana/wallet-adapter-react\";\n\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\nimport { getConstants } from \"./config/constants\";\n\nconst config = new anchor.web3.PublicKey(getConstants().MALLOC_PROGRAM_ID);\n\nconst network = getConstants().solana.NETWORK;\n\nconst rpcHost = getConstants().solana.RPC;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst startDateSeed = parseInt(process.env.REACT_APP_CANDY_START_DATE!, 10);\n\nconst txTimeout = 30000; // milliseconds (confirm this works for your project)\n\nconst App = () => {\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [getPhantomWallet(), getSolflareWallet(), getSolletWallet()],\n    []\n  );\n\n  return (\n    <ConnectionProvider endpoint={endpoint}>\n      <WalletProvider wallets={wallets} autoConnect>\n        <WalletDialogProvider>\n          <Home\n            config={config}\n            connection={connection}\n            startDate={startDateSeed}\n            txTimeout={txTimeout}\n          />\n        </WalletDialogProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { Provider } from \"@project-serum/anchor\";\nimport { AnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\n\nexport const getProvider = (wallet: AnchorWallet): Provider => {\n  return new Provider(new Connection(getConstants().solana.RPC), wallet, {});\n};\n","import * as anchor from \"@project-serum/anchor\";\nimport {\n  MallocSdk,\n} from \"@malloc/sdk\";\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { getConstants } from \"../config/constants\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n  \"cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ\"\n);\n\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\nexport interface CandyMachine {\n  id: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  program: anchor.Program;\n}\n\ninterface CandyMachineState {\n  candyMachine: CandyMachine;\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  goLiveDate: Date;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  commitment: anchor.web3.Commitment = \"recent\",\n  queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result: any, context: any) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n};\n\n/* export */ const createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\n// export const getCandyMachineState = async (\n//   anchorWallet: anchor.Wallet,\n//   candyMachineId: anchor.web3.PublicKey,\n//   connection: anchor.web3.Connection,\n// ): Promise<CandyMachineState> => {\n// const provider = new anchor.Provider(connection, anchorWallet, {\n//   preflightCommitment: \"recent\",\n// });\n\n// const idl = await anchor.Program.fetchIdl(\n//   CANDY_MACHINE_PROGRAM,\n//   provider\n// );\n\n// const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n// const candyMachine = {\n//   id: candyMachineId,\n//   connection,\n//   program,\n// }\n\n// const state: any = await program.account.candyMachine.fetch(candyMachineId);\n// const itemsAvailable = state.data.itemsAvailable.toNumber();\n// const itemsRedeemed = state.itemsRedeemed.toNumber();\n// const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n// let goLiveDate = state.data.goLiveDate.toNumber();\n// goLiveDate = new Date(goLiveDate * 1000);\n\n// return {\n//   candyMachine,\n//   itemsAvailable,\n//   itemsRedeemed,\n//   itemsRemaining,\n//   goLiveDate,\n// };\n// }\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from(\"edition\"),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getTokenWallet = async (\n  wallet: anchor.web3.PublicKey,\n  mint: anchor.web3.PublicKey\n) => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n};\n\nexport const mintOneToken = async (\n  candyMachine: CandyMachine,\n  config: anchor.web3.PublicKey, // feels like this should be part of candyMachine?\n  payer: anchor.web3.PublicKey,\n  treasury: anchor.web3.PublicKey\n): Promise<string> => {\n  const mint = anchor.web3.Keypair.generate();\n  const token = await getTokenWallet(payer, mint.publicKey);\n  const { connection, program } = candyMachine;\n  const metadata = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const rent = await connection.getMinimumBalanceForRentExemption(\n    MintLayout.span\n  );\n\n  return await program.rpc.mintNft({\n    accounts: {\n      config,\n      candyMachine: candyMachine.id,\n      payer: payer,\n      wallet: treasury,\n      mint: mint.publicKey,\n      metadata,\n      masterEdition,\n      mintAuthority: payer,\n      updateAuthority: payer,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: anchor.web3.SystemProgram.programId,\n      rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n    },\n    signers: [mint],\n    instructions: [\n      anchor.web3.SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: mint.publicKey,\n        space: MintLayout.span,\n        lamports: rent,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        0,\n        payer,\n        payer\n      ),\n      createAssociatedTokenAccountInstruction(\n        token,\n        payer,\n        payer,\n        mint.publicKey\n      ),\n      Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        token,\n        payer,\n        [],\n        1\n      ),\n    ],\n  });\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const getMallocSdk = (wallet: anchor.Provider): MallocSdk => {\n  console.log(wallet)\n  return new MallocSdk(\n    new PublicKey(getConstants().MALLOC_PROGRAM_ID || \"\"),\n    wallet\n  );\n};\n","import { FlowElement } from \"react-flow-renderer\";\nimport { getConstants } from \"../config/constants\";\nimport { getEdgeId, getNodeId, getRandomNodeId } from \"./node-ids\";\n\nexport const getDefaultSplitterNode: () => FlowElement<any> = () => {\n  const splitterId = getRandomNodeId(\"splitter\");\n  return {\n    id: splitterId,\n    type: \"splitter\",\n    position: { x: 100, y: 100 },\n    data: { id: splitterId },\n  };\n};\n\nexport const getInitSplitter: () => FlowElement<any> = () => {\n  const id = getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID);\n  return {\n    id,\n    type: \"splitter\",\n    position: { x: 100, y: 100 },\n    data: { isInitial: true, id },\n  };\n};\n\nexport const getDefaultSwapNodeSet: () => FlowElement<any>[] = () => {\n  const swapId = getRandomNodeId(\"swap\");\n  const splitterId = getRandomNodeId(\"splitter\");\n  return [\n    {\n      id: swapId, // TODO: something more determistic?\n      type: \"swap\",\n      data: { id: swapId },\n      position: { x: 100, y: 400 },\n    },\n    {\n      id: splitterId,\n      type: \"splitter\",\n      data: { id: splitterId },\n      position: { x: 100, y: 400 + 60 },\n    },\n    {\n      id: getEdgeId(swapId, splitterId),\n      source: swapId,\n      target: splitterId,\n    },\n  ];\n};\n\nexport const getDefaultTransferNodeSet: () => FlowElement<any>[] = () => {\n  const transferId = getRandomNodeId(\"transfer\");\n  return [\n    {\n      id: transferId, // TODO: something more determistic?\n      type: \"transfer\",\n      data: { id: transferId },\n      position: { x: 100, y: 400 },\n    },\n    // {\n    //   id: splitterId,\n    //   type: \"splitter\",\n    //   data: { id: splitterId },\n    //   position: { x: 100, y: 400 + 60 },\n    // },\n    // {\n    //   id: getEdgeId(transferId, splitterId),\n    //   source: transferId,\n    //   target: splitterId,\n    // },\n  ];\n};\n","import { Elements, FlowElement } from \"react-flow-renderer\";\nimport { Store } from \"react-stores\";\nimport { PushElemsFn, SPLToken } from \"../interfaces\";\nimport { getInitSplitter } from \"../utils/premade-nodes\";\n// TODO: from package instead\nimport {\n  AccountsArray,\n  Action,\n} from \"../../../../malloc-core/ts-packages/malloc-sdk/lib/\";\nimport { getConstants } from \"../config/constants\";\nimport { getNodeId } from \"../utils/node-ids\";\nimport { PublicKey, Signer } from \"@solana/web3.js\";\nimport { u64 } from \"@solana/spl-token\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\n\nexport interface IFlowChart {\n  elements: Elements<any>;\n  actionData: Action[];\n  initSplits: number[];\n  initTokenAccount?: PublicKey;\n  initAmount: u64;\n}\n\nexport interface SolanaSpl {\n  derivedTokenAccounts: SPLToken[] | null;\n  tokenList: TokenInfo[] | null;\n}\n\nexport const solanaSplStore = new Store<SolanaSpl>({\n  derivedTokenAccounts: null,\n  tokenList: null,\n});\n\n/**\n * @param actionAccounts - this does not include the default 3 prepended accounts per action (token account, token program, and token auth)\n */\ninterface NodeActionInfo {\n  actionData: Buffer;\n  actionAccounts: AccountsArray;\n  signers: Signer[];\n  tokenMintOuts: PublicKey[];\n  tokenAccountsOuts: PublicKey[];\n  actionProgram: PublicKey;\n}\nexport interface NodeInfos {\n  [elementId: string]: {\n    splitter?: {\n      splits: number[];\n      tokenAccount: PublicKey | undefined;\n      mint: PublicKey | undefined;\n    };\n    action?: NodeActionInfo;\n  };\n}\n\nconst initNodeStore: NodeInfos = {};\ninitNodeStore[getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID)] =\n  {\n    splitter: {\n      splits: [],\n      mint: undefined,\n      tokenAccount: undefined,\n    },\n  };\nexport const nodeInfoStore = new Store<NodeInfos>(initNodeStore);\n\nexport const flowStore = new Store<IFlowChart>({\n  elements: [getInitSplitter()],\n  actionData: [],\n  initSplits: [],\n  initAmount: new u64(0),\n});\n\nexport const loadingStore = new Store<{\n  storeUpdateLoading: boolean;\n  ephemeralRunLoading: boolean;\n}>({\n  storeUpdateLoading: false,\n  ephemeralRunLoading: false,\n});\n\nexport const setEphemeralRunLoading = (isLoading: boolean) =>\n  loadingStore.setState({\n    ...loadingStore.state,\n    ephemeralRunLoading: isLoading,\n  });\n\nexport const setStoreUpdateLoading = (isLoading: boolean) =>\n  loadingStore.setState({\n    ...loadingStore.state,\n    storeUpdateLoading: isLoading,\n  });\n\nexport const isStoreUpdating = () => loadingStore.state.storeUpdateLoading;\n\nexport const pushElemsOntoFlow: PushElemsFn = (elems) =>\n  flowStore.setState({\n    elements: [...flowStore.state.elements, ...elems],\n  });\n\nexport const setElemsFn: PushElemsFn = (elems) =>\n  flowStore.setState({\n    elements: [...elems],\n  });\n\nexport const setElemFn = (elem: FlowElement<any>, idx: number) => {\n  const newElems = [...flowStore.state.elements];\n  newElems[idx] = elem;\n  flowStore.setState({\n    ...flowStore.state,\n    elements: newElems,\n  });\n};\n","export const getConstants = () => {\n  const env = process.env.REACT_APP_SOLANA_NETWORK;\n  switch (env) {\n    case \"devnet\":\n      return {\n        MALLOC_PROGRAM_ID: \"9i4MAnhYagLr1vEo5jdmLehRe8Sm5Lx8fHaQNJfbFCve\",\n        mallocSpl: {\n          TRANSFER_PROGRAM_ID: \"ETpyJNQLorJbAcrPQpM9bkYxYMakegBh93kqZ1KnTBjr\",\n          SWAP_PROGRAM_ID: \"7T6seoCvCQeUeSTf2EAwX5SnyrZvX7BFUMHi74ZodBKH\",\n        },\n        projectSerum: {\n          DEX_PROGRAM_ID: \"DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY\",\n        },\n        demo: {\n          FAKE_USDC: \"EAERAaa5NHid5BSt4pRAqB6fAiAp9srt45FPMobwVHX8\",\n          FAKE_USDC_GD: \"BukLK1E7shYK5jubcLCDnbwYiCzvYGv1JSaWD6Rc6f4R\",\n          FAKE_TOKEN_A: \"J3Xrfx2T1vYAKkNiYrogJnVx6cE59Yv5UuC4v9n7mVkd\",\n        },\n        INITIAL_SPLITTER_ID_UUID: \"initial\",\n        solana: {\n          RPC: \"https://explorer-api.devnet.solana.com\",\n          NETWORK: env,\n        },\n      };\n\n    default:\n      throw \"Unexpected env\";\n  }\n  throw \"Unexpected env\";\n};\n","import TextField from \"@material-ui/core/TextField\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React from \"react\";\nimport { useEffect } from \"react\";\nimport { useState } from \"react\";\nimport { getConstants } from \"../../config/constants\";\nimport { PushElemsFn } from \"../../interfaces\";\nimport {\n  flowStore,\n  IFlowChart,\n  NodeInfos,\n  nodeInfoStore,\n  setStoreUpdateLoading,\n} from \"../../state/flowchart-store\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { getTokenMintIn, handleConnectIn } from \"../../utils/flow-chart-utils\";\nimport { findAssociatedTokenAddress } from \"../../utils/spl-tokens\";\nimport { ActionNodeProps } from \"./ActionTemplate\";\n\nexport const TransferNode = (props: ActionNodeProps) => {\n  const [recipientAddr, setRecipientAddr] = useState<string>(\"\");\n  const wallet = useAnchorWallet();\n\n  useEffect(() => {\n    if (props.toggleNodeInfoSet !== null) setRecipientAddrInStore();\n  }, [props.toggleNodeInfoSet]);\n\n  const setRecipientAddrInStore = async () => {\n    if (!recipientAddr) return;\n    let recipientPk: PublicKey;\n    setStoreUpdateLoading(true);\n    try {\n      recipientPk = new PublicKey(recipientAddr);\n    } catch (e) {\n      alert(\"Invalid recipient account\");\n      setStoreUpdateLoading(false);\n      return;\n    }\n    if (!props.mint) {\n      setStoreUpdateLoading(false);\n      return;\n    }\n    const recipientTokAccountAddr = await findAssociatedTokenAddress(\n      recipientPk,\n      props.mint\n    );\n    const recipientTokAccountData = await getProvider(\n      wallet!\n    ).connection.getAccountInfo(recipientTokAccountAddr);\n    if (!recipientTokAccountData) {\n      // TODO: have this auto expand...\n      alert(\n        \"Looks like the user does not have an associated account with this mint!\"\n      );\n      setStoreUpdateLoading(false);\n      return;\n    }\n\n    props.nodeInfoStoreState[props.id] = {\n      action: {\n        actionData: Buffer.from([]),\n        actionProgram: new PublicKey(\n          getConstants().mallocSpl.TRANSFER_PROGRAM_ID\n        ),\n        actionAccounts: [\n          {\n            address: recipientTokAccountAddr,\n            isWriteable: true,\n          },\n        ],\n        signers: [],\n        tokenMintOuts: [],\n        tokenAccountsOuts: [],\n      },\n    };\n    nodeInfoStore.setState(props.nodeInfoStoreState);\n    setStoreUpdateLoading(false);\n  };\n\n  return (\n    <>\n      <h4>Transfer Action</h4>\n      <p>Input token: {props.mintName}</p>\n      <TextField\n        value={recipientAddr}\n        label=\"Recipient Address\"\n        onChange={(e) => setRecipientAddr(e.target.value)}\n        onBlur={(e) => setRecipientAddrInStore()}\n      />\n    </>\n  );\n};\n"],"sourceRoot":""}