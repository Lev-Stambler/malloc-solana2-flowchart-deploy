{"version":3,"sources":["utils/spl-tokens.ts","utils/node-ids.ts","components/tokens/TokenAccountChooser.tsx","components/actions/SwapNode.tsx","utils/flow-chart-utils.ts","components/usdc-airdrop/perform-usdc-airdrop.ts","components/constructions/SidePanel.tsx","components/constructions/SplitterNode.tsx","components/actions/ActionTemplate.tsx","views/Flowchart.tsx","components/tx-handler/LoadingTX.tsx","Home.tsx","App.tsx","reportWebVitals.ts","index.tsx","utils/anchor.ts","../../../malloc-spl/src/swap/swap-interfaces.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/constants.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/spl.ts","utils/malloc.ts","utils/premade-nodes.ts","state/flowchart-store.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/solana-utils.ts","config/constants.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/malloc-sdk.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/interfaces/index.ts","../../../malloc-spl/src/swap/index.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/index.ts","../../../malloc-core/ts-packages/malloc-sdk/lib/graph-utils.ts","components/actions/Transfer.tsx"],"names":["SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","ASSOCIATED_TOKEN_PROGRAM_ID","getTokenLists","provider","a","getCached","solanaSplStore","state","tokenList","TokenListProvider","resolve","tokens","filterByClusterSlug","getConstants","solana","NETWORK","getList","setState","getDemoTokenInfo","usdcMint","PublicKey","demo","FAKE_USDC","aMint","FAKE_TOKEN_A","getMintInfo","usdcInfo","aInfo","chainId","name","symbol","address","getTokenListContainer","TokenListContainer","findAssociatedTokenAddress","walletAddress","tokenMintAddress","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","associated","toReadableNumber","number","decimals","balance","toString","wholeStr","substring","length","fractionStr","padStart","value","pattern","test","replace","formatWithCommas","fromReadableNumber","split","wholePart","fracPart","Error","padEnd","findAllAssociatedTokenAddress","mints","Promise","all","map","m","getTokenAccountInfo","tokenAddr","connection","getAccountInfo","account","data","parseTokenAccount","console","error","mintAddr","parseMintAccount","getNodeType","id","getNodeId","uuid","getRandomNodeId","Math","random","getEdgeId","source","target","getModalStyle","top","left","transform","useStyles","makeStyles","theme","createStyles","paper","position","width","backgroundColor","palette","background","border","boxShadow","shadows","padding","spacing","TokenLine","tok","setChoosen","style","display","gridTemplateColumns","gap","onClick","info","shortenAddress","u64","TokenAccountChooser","props","onlyWithInitializedAccounts","classes","React","useState","modalStyle","open","setOpen","customTokenAccount","setCustomTokenAccount","customMintAccount","setCustomMintAccount","wallet","useAnchorWallet","choosen","solanaSplStoreHook","useStore","getProvider","loadTokens","publicKey","t","associatedAddr","addr","amount","bals","accounts","i","toBase58","accountsFiltered","filter","accountsMapped","mint","derivedTokenAccounts","useEffect","handleClose","onClose","choosenType","tokenAccount","tokAccountData","alert","mintInfo","bal","body","className","overflow","maxHeight","TextField","label","onChange","e","onFocus","type","buttonText","Modal","aria-labelledby","aria-describedby","SwapNode","outTok","setOutTok","toggleNodeInfoSet","setSwapInfo","setStoreUpdateLoading","buildSwapAccounts","projectSerum","DEX_PROGRAM_ID","web3","SYSVAR_RENT_PUBKEY","authority","inTokenAccount","outTokenAccount","inMint","outMint","serumDexProgramId","rent","swapInfo","side","buildPartialSwapAction","mallocSpl","SWAP_PROGRAM_ID","swapActionProgram","minOut","builtAction","actionAccounts","slice","nodeInfoStoreState","action","tokenAccountsOuts","nodeInfoStore","mintName","Position","Bottom","isEdge","edgeToSourceAndTarget","getAllEdgesWithSource","elems","sourceId","getAllNodesWithEdgesFromSource","targetId","getAllEdgesWithTarget","getAllActionNodeIds","flowStore","elements","getTokenMintIn","priorSplitterMints","splitterId","splitter","firstNonNull","find","some","equals","getTokenAccountIn","priorSplitterTokAccount","getAllKnownUserTokenAccounts","existentAssociatedAccounts","getAssociatedTokenAccounts","initTokenAccount","initMint","reduce","prior","splStore","buildEphemeralInstruction","actionMetadatas","allActions","actionNodeId","nextSplitterIds","nextNodes","nextActions","splitterI","splits","nextAction","actionI","actionIdx","indexOf","fraction","anchor","nodeId","ripeAmount","buildActionMetas","INITIAL_SPLITTER_ID_UUID","edgeId","getInitialSplitsAndNextIds","initSplits","initIds","actionTokenMintIns","allActionsFilled","actionId","actionInfo","tokenMintIn","actionMetadata","initIdxs","forEach","actions","initialSplits","initialActionIndices","initAmount","amountInAccount","compileAndRunFlow","setEphemeralRunLoading","loadingStore","storeUpdateLoading","res","rej","setTimeout","inst","mallocSdk","getMallocSdk","buildTxs","opts","associatedTokenAccounts","sendRequests","prepareCommitment","skipPreflight","preflightCommitment","commitment","actionCommitment","onPrepareAccountsDone","txHashes","txHash","confirmTransaction","retHashes","compileAndRunFlowChecked","richUSDCAirdroperSK","Uint8Array","richUSDCSigner","Wallet","Keypair","fromSecretKey","getRichUsdcProvider","endpointURL","Provider","Connection","performUsdcAirdrop","userAddr","tryCreateAssociatedAccount","RPC","tokAccount","airdrop","FAKE_USDC_GD","window","location","reload","JSON","stringify","log","instr","Token","createAssociatedTokenAccountInstruction","tx","Transaction","add","send","gdUsdc","airDropToTokenAccounts","amountAirdrop","transferTxs","createTransferInstruction","ConstructionSidePanel","solwallet","useWallet","loadingStoreHook","airdropLoading","setAirdropLoading","Card","maxWidth","CardContent","Button","pushElemsFn","getDefaultTransferNodeSet","getDefaultSwapNodeSet","then","hashes","catch","disabled","setElemsFn","getInitSplitter","color","disconnect","getSplitterNode","pushElems","nodeInfoStateVals","numbSources","setNumbSources","undefined","amountInitIn","setAmountInitIn","setSplits","inputInitSplToken","setInputInitSplToken","flowState","nodeState","isInitial","expandedNumb","setEdgeAnimated","ind","animated","allEdges","edge","edgeInd","findIndex","edgeObj","setElemFn","updateNonInitSplitterState","inputNodes","inpNodeStates","n","every","tokenMintOuts","tokenAccountOuts","newNumbSources","diff","Array","fill","paddingBottom","parsed","parseFloat","Top","onBlur","parseInt","setSplitAmounts","onConnect","conn","params","splitterTarget","handleConnectIn","getActionTemplate","ActionNode","setMint","setTokenAccount","setMintName","setToggleNodeInfoSet","setInfos","tokList","_mint","newMint","newTokenIn","borderRadius","nodeTypes","swap","pushElemsOntoFlow","transfer","TransferNode","height","zIndex","LoadingTx","justifyContent","alignContent","justifyItems","loading","css","size","ConnectButton","styled","WalletDialogButton","Home","span","setBalance","loadingState","message","severity","alertState","setAlertState","Date","startDate","getBalance","LAMPORTS_PER_SOL","connected","marginTop","toLocaleString","Flowchart","ephemeralRunLoading","LoadingTX","Snackbar","autoHideDuration","Alert","config","MALLOC_PROGRAM_ID","network","rpcHost","startDateSeed","process","App","endpoint","useMemo","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSolletWallet","autoConnect","txTimeout","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","Side","SwapInstructionByte","CONSTRUCTION_ACCOUNT_SIZE","LIFETIME_RESULT_ACCOUNT_MS","ONE_HOUR_MS","LIFETIME_CONSTRUCTION_ACCOUNT_MS","LAMPORTS_PER_EPOCH","MS_PER_EPOCH","transferToTx","destination","signer","secretKey","owner","signers","createTokenAccountsForActions","tokenAuthority","fundingAccount","getMintsNoDuplicates","flat","pk","associatedToSignerAccount","insts","createTokTx","txs","Set","pkToStr","chars","MallocSdk","x","y","swapId","transferId","Store","initNodeStore","actionData","isLoading","elem","idx","newElems","calculateRent","durationMs","rentCost","ceil","env","TRANSFER_PROGRAM_ID","mallocProgram","this","Program","MALLOC_IDL","_authority","_inAuth","amountInAuthority","tokenAccounts","tokenTxs","createAndInitConstruction","construction","constructionTx","addConstructionActionsTx","addActionsToConstruction","checkMintsAreTheSame","BN","transferTx","prepareConstructionTx","prepareConstruction","hitOrder","buildSeqListOfActionCalls","initResultAccount","ACTION_TEMPLATE_IDL","actionProgram","initResultAccounts","actionCtxFilled","ctx","resultAccount","isWriteable","isSigner","processTxs","hitIndex","processAction","instructions","additionalSigners","preActionTxs","txsPrepare","txsActionsCalls","txsActionCalls","resultAccounts","fetch","constructionState","actionSerialize","o","nextNode","actionCallSerialize","numbTimesHit","callAmount","actionCalls","readyCallIdxList","constructionData","options","sendAll","txHashesPrepare","program","numbActions","ConstructionAccount","generate","transaction","SystemProgram","createAccount","fromPubkey","newAccountPubkey","space","lamports","programId","initConstruction","addActions","initActionIdx","initActionSplits","actionAccountsCtx","auth","tokauth","signersPartial","Buffer","from","actionCtxProxy","actionTemplateProgram","numberOfPossibleOutputTokens","result","getMinimumBalanceForRentExemption","resultSize","calcSizeResultAccount","numberOfActions","inp","metadata","packSwapData","BasicSwap","swapAccountsToActionAccounts","swapAccounts","openOrderInitTx","getMarket","marketRet","marketPk","Market","load","marketSel","getOpenOrdersAccount","openOrderAccountData","getVaultOwnerAndNonce","decoded","ownAddress","vaultSigner","coinWallet","Bid","pcWallet","market","requestQueue","eventQueue","bids","asks","coinVault","baseVault","pcVault","quoteVault","openOrders","openOrdersAccount","openOrderPk","orderPayerTokenAccount","dexProgram","tokenProgram","openOrderTx","dexPID","OpenOrders","findForMarketAndOwner","openOrderAccount","Account","openOrdersTx","makeCreateAccountTransaction","Ask","getMarketsFromBaseMinttoQuoteMint","marketPks","instrByte","packedMinOut","toArrayLike","initPart","concat","referralAccount","outAccount","push","marketPublicKey","dexProgramId","nonce","toNumber","createProgramAddress","vaultOwner","iaddn","baseMint","quoteMint","serumProgId","getLayout","findAccountsByMints","actionMetas","initIndices","initHitCounts","simulateDAG","hitCounts","toHit","newHitCounts","getOccurrence","newRipeActions","includes","newToHit","array","v","recipientAddr","setRecipientAddr","setRecipientAddrInStore","recipientPk","recipientTokAccountAddr"],"mappings":"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","file":"static/js/main.97c357e7.chunk.js","sourcesContent":["import { getProvider, Provider } from \"@project-serum/anchor\";\nimport { parseTokenAccount, parseMintAccount } from \"@project-serum/common\";\nimport {\n  AccountInfo,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  MintInfo,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport {\n  TokenListProvider,\n  TokenInfo,\n  TokenListContainer,\n} from \"@solana/spl-token-registry\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\nimport { solanaSplStore } from \"../state/flowchart-store\";\nimport { getTokenMintIn } from \"./flow-chart-utils\";\n\n// TODO: where does this come from?\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID: PublicKey =\n  ASSOCIATED_TOKEN_PROGRAM_ID;\n\n// TODO: have a store for token metadata which has a list of all tokens as well as their metadata\n\n// See https://github.com/solana-labs/token-list\nexport const getTokenLists = async (\n  provider: Provider\n): Promise<TokenInfo[]> => {\n  const getCached = async () => {\n    if (solanaSplStore.state.tokenList) return solanaSplStore.state.tokenList;\n    const tokens = await new TokenListProvider().resolve();\n    const tokenList = tokens\n      .filterByClusterSlug(getConstants().solana.NETWORK)\n      .getList();\n    solanaSplStore.setState({\n      ...solanaSplStore.state,\n      tokenList,\n    });\n    return tokenList;\n  };\n  const tokenList = await getCached();\n\n  // Add in demo tokens\n  if (getConstants().solana.NETWORK === \"devnet\") {\n    return [...tokenList, ...(await getDemoTokenInfo(provider))];\n  } else {\n    return tokenList;\n  }\n};\n\nconst getDemoTokenInfo = async (provider: Provider): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(getConstants().demo.FAKE_USDC);\n  const aMint = new PublicKey(getConstants().demo.FAKE_TOKEN_A);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: getConstants().demo.FAKE_USDC,\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE: A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: getConstants().demo.FAKE_TOKEN_A,\n    },\n  ];\n};\n\nexport const getTokenListContainer = async (\n  provider: Provider\n): Promise<TokenListContainer> =>\n  new TokenListContainer(await getTokenLists(provider));\n\n// See https://spl.solana.com/associated-token-account\nexport const findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  const associated = await PublicKey.findProgramAddress(\n    [\n      walletAddress.toBuffer(),\n      TOKEN_PROGRAM_ID.toBuffer(),\n      new PublicKey(tokenMintAddress).toBuffer(),\n    ],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n  return associated[0];\n};\n\nexport const toReadableNumber = (number: u64, decimals: number): string => {\n  function trimTrailingZeroes(value: string): string {\n    return value.replace(/\\.?0*$/, \"\");\n  }\n  function formatWithCommas(value: string): string {\n    const pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(value)) {\n      value = value.replace(pattern, \"$1,$2\");\n    }\n    return value;\n  }\n\n  const balance = number.toString();\n  const wholeStr = balance.substring(0, balance.length - decimals) || \"0\";\n  // TODO: correct?\n  const fractionStr = balance\n    .substring(balance.length - decimals)\n    .padStart(decimals, \"0\")\n    .substring(0, decimals);\n\n  return trimTrailingZeroes(`${formatWithCommas(wholeStr)}.${fractionStr}`);\n};\n\nexport const fromReadableNumber = (\n  number: number,\n  decimals: number\n): string => {\n  function trimLeadingZeroes(value: string): string {\n    value = value.replace(/^0+/, \"\");\n    if (value === \"\") {\n      return \"0\";\n    }\n    return value;\n  }\n\n  const split = number.toString().split(\".\");\n  const wholePart = split[0];\n  const fracPart = split[1] || \"\";\n  if (split.length > 2 || fracPart.length > decimals) {\n    throw new Error(`Cannot parse '${number}' as token amount`);\n  }\n  return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, \"0\"));\n};\n\nexport const findAllAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  mints: (PublicKey | string)[]\n): Promise<PublicKey[]> =>\n  Promise.all(mints.map((m) => findAssociatedTokenAddress(walletAddress, m)));\n\nexport const getTokenAccountInfo = async (\n  provider: Provider,\n  tokenAddr: PublicKey\n): Promise<AccountInfo | null> => {\n  const account = await provider.connection.getAccountInfo(tokenAddr);\n  if (!account) return null;\n  try {\n    const data = parseTokenAccount(account.data);\n    return data;\n  } catch (e) {\n    console.error(\"An error occured parsing the data, returning null\", e);\n    return null;\n  }\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n","import { FlowElementType } from \"../interfaces\";\n\nexport const getNodeType = (id: string): FlowElementType => id.split(\"-\")[0];\nexport const getNodeId = (name: FlowElementType, uuid: string) =>\n  `${name}-${uuid}`;\nexport const getRandomNodeId = (name: FlowElementType): string =>\n  getNodeId(name, Math.random().toString());\nexport const getEdgeId = (source: string, target: string): string =>\n  `edge~${source}^${target}`;\n","import React from \"react\";\nimport { makeStyles, Theme, createStyles } from \"@material-ui/core/styles\";\nimport Modal from \"@material-ui/core/Modal\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { useMemo } from \"react\";\nimport { useEffect } from \"react\";\nimport {\n  findAllAssociatedTokenAddress,\n  findAssociatedTokenAddress,\n  getMintInfo,\n  getTokenAccountInfo,\n  getTokenLists,\n  toReadableNumber,\n} from \"../../utils/spl-tokens\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\nimport { SPLToken } from \"../../interfaces\";\nimport { shortenAddress } from \"../../utils/malloc\";\nimport { Provider } from \"@project-serum/anchor\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { isBundle } from \"typescript\";\nimport { useState } from \"react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { useStore } from \"react-stores\";\nimport { solanaSplStore } from \"../../state/flowchart-store\";\nimport { u64 } from \"@solana/spl-token\";\n\nfunction getModalStyle() {\n  const top = 50;\n  const left = 50;\n\n  return {\n    top: `${top}%`,\n    left: `${left}%`,\n    transform: `translate(-${top}%, -${left}%)`,\n  };\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    paper: {\n      position: \"absolute\",\n      width: \"auto\",\n      backgroundColor: theme.palette.background.paper,\n      border: \"2px solid #000\",\n      boxShadow: theme.shadows[5],\n      padding: theme.spacing(2, 4, 3),\n    },\n  })\n);\n\nconst TokenLine = ({\n  tok,\n  setChoosen,\n}: {\n  tok: SPLToken;\n  setChoosen: () => void;\n}) => {\n  return (\n    <div\n      style={{\n        display: \"grid\",\n        gridTemplateColumns: \"1fr 1fr 1fr 1fr\",\n        width: \"100%\",\n        gap: \"5px\",\n      }}\n    >\n      <button onClick={setChoosen}>Choose</button>\n      <div>{tok.info.name}</div>\n      <div>\n        {shortenAddress(tok.account)}\n        {tok.balance ? \"\" : \" (currently nonexistent)\"}\n      </div>\n      <div>\n        {toReadableNumber(new u64(tok.balance || 0), tok.info.decimals)}\n      </div>\n    </div>\n  );\n};\n\nexport default function TokenAccountChooser(props: {\n  buttonText?: string;\n  onlyWithInitializedAccounts?: boolean;\n  onClose: (tok: SPLToken) => void;\n}) {\n  const onlyWithInitializedAccounts = props.onlyWithInitializedAccounts ?? true;\n  const classes = useStyles();\n  // getModalStyle is not a pure function, we roll the style only on the first render\n  const [modalStyle] = React.useState(getModalStyle);\n  const [open, setOpen] = React.useState(false);\n  const [customTokenAccount, setCustomTokenAccount] = React.useState(\"\");\n  const [customMintAccount, setCustomMintAccount] = React.useState(\"\");\n  const wallet = useAnchorWallet();\n  // If it is -1, then the custom state is choosen\n  const [choosen, setChoosen] = useState(-1);\n  const solanaSplStoreHook = useStore(solanaSplStore);\n\n  const provider = getProvider(wallet!);\n\n  const loadTokens = async () => {\n    const tokenList = await getTokenLists(provider);\n    const associatedAddr = await findAllAssociatedTokenAddress(\n      wallet?.publicKey!,\n      tokenList.map((t) => t.address)\n    );\n    const bals = await Promise.all(\n      associatedAddr.map(async (addr) => {\n        const data = await getTokenAccountInfo(provider, addr);\n        return data?.amount;\n      })\n    );\n    const accounts = associatedAddr.map((addr, i) => {\n      return {\n        account: addr.toBase58(),\n        info: tokenList[i],\n        balance: bals[i],\n      };\n    });\n    const accountsFiltered = onlyWithInitializedAccounts\n      ? accounts.filter((i) => i.balance)\n      : accounts;\n    const accountsMapped = accountsFiltered.map((i) => {\n      return {\n        ...i,\n        info: {\n          ...i.info,\n          mint: new PublicKey(i.info.address),\n        },\n        balance: i.balance?.toString() || null,\n      };\n    });\n\n    solanaSplStore.setState({\n      ...solanaSplStoreHook,\n      derivedTokenAccounts: accountsMapped,\n    });\n  };\n\n  useEffect(() => {\n    loadTokens();\n  }, []);\n\n  const handleOpen = () => {\n    loadTokens();\n    setOpen(true);\n  };\n\n  const handleClose = async () => {\n    if (!solanaSplStoreHook.derivedTokenAccounts) {\n      setOpen(false);\n      return;\n    }\n    if (choosen >= 0)\n      props.onClose(solanaSplStoreHook.derivedTokenAccounts[choosen]);\n    else {\n      const choosenType = choosen === -1 ? \"TOKEN\" : \"MINT\";\n      if (\n        (choosenType === \"TOKEN\" && !customTokenAccount) ||\n        (choosenType === \"MINT\" && !customMintAccount)\n      ) {\n        setOpen(false);\n        return;\n      }\n\n      const tokenAccount =\n        choosenType === \"TOKEN\"\n          ? customTokenAccount\n          : (\n              await findAssociatedTokenAddress(\n                wallet!.publicKey,\n                customMintAccount\n              )\n            ).toBase58();\n      const tokAccountData = await getTokenAccountInfo(\n        provider,\n        new PublicKey(tokenAccount)\n      );\n      if (choosenType === \"TOKEN\" && !tokAccountData) {\n        alert(\"Looks like an invalid SPL Token Account was provided\");\n        setOpen(false);\n        return;\n      }\n      if (choosenType === \"MINT\" && props.onlyWithInitializedAccounts !== false && !tokAccountData) {\n        alert(\n          \"Looks like there is no initialized associated account with this mint\"\n        );\n        setOpen(false);\n        return;\n      }\n      const mintAddr =\n        choosenType === \"TOKEN\"\n          ? tokAccountData!.mint\n          : new PublicKey(customMintAccount);\n\n      const mintInfo = await getMintInfo(provider, mintAddr);\n      if (!mintInfo) {\n        alert(\"Looks like the mint associated with this token is invalid\");\n        setOpen(false);\n        return;\n      }\n      const bal = tokAccountData?.amount || new u64(0);\n      props.onClose({\n        balance: bal,\n        account: tokenAccount,\n        info: {\n          ...mintInfo,\n          mint: mintAddr,\n        },\n      });\n    }\n    setOpen(false);\n  };\n\n  const body = (\n    <div style={modalStyle} className={classes.paper}>\n      <h2 id=\"simple-modal-title\">Choose a token account</h2>\n      <p id=\"simple-modal-description\">\n        Choose from either your associated token accounts or add a custom\n        address\n      </p>\n      <div\n        className=\"options\"\n        style={{ overflow: \"scroll\", maxHeight: \"70vh\" }}\n      >\n        <div\n          style={{ display: \"grid\", gridTemplateColumns: \"1fr 1fr 1fr 1fr\" }}\n        >\n          <span></span>\n          <div>Mint Name</div>\n          <div>Token Account Address</div>\n          <div>Amount</div>\n        </div>\n        {!solanaSplStoreHook.derivedTokenAccounts\n          ? \"Loading...\"\n          : solanaSplStoreHook.derivedTokenAccounts.map((tok, i) => (\n              <div\n                key={`token-derived-account-${i}`}\n                style={{\n                  padding: \"0.5rem\",\n                  border: choosen === i ? \"1px solid black\" : \"0px\",\n                }}\n              >\n                <TokenLine tok={tok} setChoosen={() => setChoosen(i)} />\n                <br />\n              </div>\n            ))}\n        {/* TODO: add balance to the left of this once filled out */}\n        <div\n          style={{\n            padding: \"0.5rem\",\n            border: choosen === -1 ? \"1px solid black\" : \"0px\",\n          }}\n        >\n          <TextField\n            label=\"Custom Token Account\"\n            value={customTokenAccount}\n            onChange={(e) => setCustomTokenAccount(e.target.value)}\n            onFocus={() => setChoosen(-1)}\n          />\n        </div>\n        <p>Or</p>\n        <div\n          style={{\n            padding: \"0.5rem\",\n            border: choosen === -2 ? \"1px solid black\" : \"0px\",\n          }}\n        >\n          <TextField\n            label=\"Custom Mint Account\"\n            value={customMintAccount}\n            onChange={(e) => setCustomMintAccount(e.target.value)}\n            onFocus={() => setChoosen(-2)}\n          />\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <div>\n      <button type=\"button\" onClick={handleOpen}>\n        {props.buttonText || \"Choose Token Account\"}\n      </button>\n      <Modal\n        open={open}\n        onClose={handleClose}\n        aria-labelledby=\"simple-modal-title\"\n        aria-describedby=\"simple-modal-description\"\n      >\n        {body}\n      </Modal>\n    </div>\n  );\n}\n","import { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport {\n  buildPartialSwapAction,\n  buildSwapAccounts,\n  packSwapData,\n  Side,\n  swapAccountsToActionAccounts,\n  SwapInstructionByte,\n} from \"@malloc/spl\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React, { useEffect } from \"react\";\nimport { useState } from \"react\";\nimport ReactFlow, { Handle, Position } from \"react-flow-renderer\";\nimport { getConstants } from \"../../config/constants\";\nimport { SPLToken } from \"../../interfaces\";\nimport {\n  nodeInfoStore,\n  setStoreUpdateLoading,\n} from \"../../state/flowchart-store\";\nimport TokenAccountChooser from \"../tokens/TokenAccountChooser\";\nimport { ActionNodeProps } from \"./ActionTemplate\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { getTokenListContainer } from \"../../utils/spl-tokens\";\nimport { web3 } from \"@project-serum/anchor\";\nimport { u64 } from \"@solana/spl-token\";\n\n// const elements = [\n//   {\n//     id: \"2\",\n//     type: \"special\",\n//     position: { x: 100, y: 100 },\n//     data: { text: \"A custom node\" },\n//   },\n// ];\n\n// TODO: IF RUN W/O recompiling, the swap fails because recreate tx of order book account\n// Generally, there should be 1 order book per market though!!!!\nconst SwapNode = (props: ActionNodeProps) => {\n  const wallet = useAnchorWallet();\n  const [outTok, setOutTok] = useState<SPLToken | null>(null);\n\n  useEffect(() => {\n    if (props.toggleNodeInfoSet !== null) setSwapInfo();\n  }, [props.toggleNodeInfoSet, outTok]);\n\n  const setSwapInfo = async () => {\n    if (!outTok || !props.tokenAccount || !wallet) return;\n    setStoreUpdateLoading(true);\n    if (!props.mint) {\n      setStoreUpdateLoading(false);\n      return;\n    }\n\n    const provider = getProvider(wallet!);\n    const swapInfo = await buildSwapAccounts({\n      provider,\n      tokenList: (await getTokenListContainer(provider)) as any,\n      authority: wallet.publicKey,\n      inTokenAccount: props.tokenAccount,\n      outTokenAccount: new PublicKey(outTok.account),\n      inMint: props.mint as PublicKey,\n      outMint: outTok.info.mint,\n      serumDexProgramId: new PublicKey(\n        getConstants().projectSerum.DEX_PROGRAM_ID\n      ),\n      rent: web3.SYSVAR_RENT_PUBKEY,\n    });\n    // TODO: min out....\n    const side = swapInfo.side;\n    const builtAction = (\n      await buildPartialSwapAction({\n        provider,\n        tokenList: (await getTokenListContainer(provider)) as any,\n        authority: wallet.publicKey,\n        inTokenAccount: props.tokenAccount,\n        outTokenAccount: new PublicKey(outTok.account),\n        inMint: props.mint as PublicKey,\n        outMint: outTok.info.mint,\n        serumDexProgramId: new PublicKey(\n          getConstants().projectSerum.DEX_PROGRAM_ID\n        ),\n        rent: web3.SYSVAR_RENT_PUBKEY,\n        swapActionProgram: new PublicKey(\n          getConstants().mallocSpl.SWAP_PROGRAM_ID\n        ),\n        minOut: new u64(1), // TODO:!\n      })\n    )();\n    // remove the first three accounts from the slice as these get reinserted by the frontend // TODO: is this bad practice?\n    builtAction.actionAccounts = builtAction.actionAccounts.slice(3)\n    props.nodeInfoStoreState[props.id] = {\n      action: {\n        ...builtAction,\n        tokenAccountsOuts: [new PublicKey(outTok.account)],\n      },\n    };\n    // props.nodeInfoStoreState[props.id] = {\n    //   action: {\n    //     actionData: data,\n    //     actionProgram: new PublicKey(getConstants().mallocSpl.SWAP_PROGRAM_ID),\n    //     actionAccounts: swapAccountsToActionAccounts(\n    //       swapInfo.swapAccounts,\n    //       side\n    //     ).slice(3), // TODO: remove slice and have action for an action to put its own 3 in\n    //     tokenAccountsOuts: [new PublicKey(outTok.account)],\n    //     // instructions: [\n    //     //   swapInfo.openOrderInitInstr\n    //     // ],\n    //     signers: [swapInfo.openOrderAccount],\n    //     tokenMintOuts: [outTok.info.mint],\n    //   },\n    // };\n    nodeInfoStore.setState(props.nodeInfoStoreState);\n    setStoreUpdateLoading(false);\n  };\n\n  return (\n    <div>\n      <h4>\n        Swap {props.mintName} to{\" \"}\n        {outTok?.info.name ||\n          outTok?.info.mint.toBase58() ||\n          \"<Out token not set>\"}\n      </h4>\n      <TokenAccountChooser\n        onClose={(tok) => setOutTok(tok)}\n        buttonText=\"Choose output token\"\n        onlyWithInitializedAccounts={false}\n      />\n      <Handle type=\"source\" position={Position.Bottom} id=\"b\" />\n    </div>\n  );\n};\n\nexport default SwapNode;\n","import { Connection, Edge, Elements } from \"react-flow-renderer\";\nimport * as anchor from \"@project-serum/anchor\";\nimport {\n  Action,\n  ActionMetadata,\n  BuildEphemeralTxsInstr,\n  NextNode,\n} from \"../../../../malloc-core/ts-packages/malloc-sdk/lib\";\nimport { FlowElementType, PushElemsFn } from \"../interfaces\";\n// import { getMallocSdk } from \"./malloc\";\nimport {\n  flowStore,\n  loadingStore,\n  nodeInfoStore,\n  setEphemeralRunLoading,\n  solanaSplStore,\n} from \"../state/flowchart-store\";\nimport { getConstants } from \"../config/constants\";\nimport { getEdgeId, getNodeId, getNodeType } from \"./node-ids\";\nimport { u64 } from \"@solana/spl-token\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { getMallocSdk } from \"./malloc\";\nimport { BuildEphemeralOpts } from \"@malloc/sdk\";\nimport { getTokenAccountInfo } from \"./spl-tokens\";\nimport { getProvider } from \"./anchor\";\n\nconst isEdge = (id: string) => id.split(\"~\")[0] === \"edge\";\nconst edgeToSourceAndTarget = (id: string): string[] =>\n  id.split(\"~\")[1].split(\"^\");\n\n/**\n * @returns true if an edge was added, false otherwise\n */\nexport const handleConnectIn = (\n  params: Connection,\n  pushElems: PushElemsFn,\n  splitterTarget = true\n): boolean => {\n  console.log(params)\n  if (\n    !params.source ||\n    !params.target ||\n    (splitterTarget\n      ? getNodeType(params.source || \"\") === \"splitter\"\n      : getNodeType(params.target || \"\") === \"splitter\")\n  ) {\n    return false;\n  }\n  const edge: Edge = {\n    id: getEdgeId(params.source, params.target),\n    source: params.source,\n    target: params.target,\n  };\n  pushElems([edge]);\n  return true;\n};\n\nexport const getAllEdgesWithSource = (\n  elems: Elements<any>,\n  sourceId: string\n): string[] => {\n  return elems\n    .filter((e) => isEdge(e.id) && edgeToSourceAndTarget(e.id)[0] === sourceId)\n    .map((e) => e.id);\n};\n\nexport const getAllNodesWithEdgesFromSource = (\n  elems: Elements<any>,\n  targetId: string\n) =>\n  getAllEdgesWithSource(elems, targetId).map(\n    (e) => edgeToSourceAndTarget(e)[1]\n  );\n\nexport const getAllNodesWithEdgesToTarget = (\n  elems: Elements<any>,\n  targetId: string\n) =>\n  getAllEdgesWithTarget(elems, targetId).map(\n    (e) => edgeToSourceAndTarget(e)[0]\n  );\n\nexport const getAllEdgesWithTarget = (\n  elems: Elements<any>,\n  targetId: string\n): string[] => {\n  return elems\n    .filter((e) => isEdge(e.id) && edgeToSourceAndTarget(e.id)[1] === targetId)\n    .map((e) => e.id);\n};\n\nconst getInitialSplitsAndNextIds = (): [number[], string[]] => {\n  const splits =\n    nodeInfoStore.state[\n      getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID)\n    ].splitter?.splits;\n  if (!splits) throw \"Expected to get the splits from the initial splitter\";\n  const nextIds = getAllEdgesWithSource(\n    flowStore.state.elements,\n    getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID)\n  ).map((edgeId) => edgeToSourceAndTarget(edgeId)[1]);\n  return [splits, nextIds];\n};\n\nconst getAllActionNodeIds = (): string[] => {\n  return flowStore.state.elements\n    .filter((e) => !isEdge(e.id) && getNodeType(e.id) !== \"splitter\")\n    .map((e) => e.id);\n};\n\nconst buildActionMetas = (): (ActionMetadata & { nodeId: string })[] => {\n  const allActions = getAllActionNodeIds();\n  return allActions.map((actionNodeId) => {\n    const nextSplitterIds = getAllNodesWithEdgesFromSource(\n      flowStore.state.elements,\n      actionNodeId\n    );\n    const nextSplittersNextActions = nextSplitterIds.map((id) =>\n      getAllNodesWithEdgesFromSource(flowStore.state.elements, id)\n    );\n    const nextNodes: NextNode[][] = nextSplittersNextActions.map(\n      (nextActions, splitterI) => {\n        const splitterId = nextSplitterIds[splitterI];\n        const splits = nodeInfoStore.state[splitterId].splitter?.splits;\n        if (!splits) throw \"Expected to find splitter information\";\n        return nextActions.map((nextAction, actionI) => {\n          return {\n            actionIdx: allActions.indexOf(nextAction),\n            fraction: new anchor.BN(splits[actionI]),\n          };\n        });\n      }\n    );\n    return {\n      nodeId: actionNodeId,\n      ripeAmount: getAllEdgesWithTarget(flowStore.state.elements, actionNodeId)\n        .length,\n      nextNodes: nextNodes,\n    };\n  });\n};\n\nexport const getTokenMintIn = (id: string): PublicKey | null => {\n  const elems = flowStore.state.elements;\n  const priorSplitterMints = getAllEdgesWithTarget(elems, id).map((e) => {\n    const splitterId = edgeToSourceAndTarget(e)[0];\n    const mint = nodeInfoStore.state[splitterId].splitter?.mint;\n    if (!mint) return null;\n    return mint;\n  });\n  if (priorSplitterMints.length === 0) return null;\n  const firstNonNull = priorSplitterMints.find((m) => !!m);\n  if (!firstNonNull) return null;\n  if (\n    priorSplitterMints\n      .filter((m) => !!m)\n      .some((mint) => !mint!.equals(firstNonNull))\n  )\n    throw `Inconsistent prior token mint address for node with id ${id}`;\n\n  // Ensure all the prior mints are filled\n  if (priorSplitterMints.some((m) => !m)) return null;\n  return firstNonNull;\n};\n\n// TODO: this assumes that the token account in is the same as the out from the last node, this is not always true\nexport const getTokenAccountIn = (id: string): PublicKey | null => {\n  const elems = flowStore.state.elements;\n  const priorSplitterTokAccount = getAllEdgesWithTarget(elems, id).map((e) => {\n    const splitterId = edgeToSourceAndTarget(e)[0];\n    const tokenAccount = nodeInfoStore.state[splitterId].splitter?.tokenAccount;\n    if (!tokenAccount) return null;\n    return tokenAccount;\n  });\n  if (priorSplitterTokAccount.length === 0) return null;\n  const firstNonNull = priorSplitterTokAccount.find((m) => !!m);\n  if (!firstNonNull) return null;\n  if (\n    priorSplitterTokAccount\n      .filter((m) => !!m)\n      .some((mint) => !mint!.equals(firstNonNull))\n  )\n    throw `Inconsistent prior token account address for node with id ${id}`;\n\n  // Ensure all the prior mints are filled\n  if (priorSplitterTokAccount.some((m) => !m)) return null;\n  return firstNonNull;\n};\n\nexport const getAllTokenMintsIn = (actionIds: string[]): PublicKey[] =>\n  actionIds.map(getTokenMintIn).map((e) => {\n    if (!e) throw \"Expected all token mints to be filled\";\n    return e;\n  });\n\nconst getAllKnownUserTokenAccounts = async (wallet: anchor.Provider) => {\n  const existentAssociatedAccounts = getAssociatedTokenAccounts();\n  const initTokenAccount = flowStore.state.initTokenAccount;\n  if (initTokenAccount) {\n    const initMint = (await getTokenAccountInfo(wallet, initTokenAccount))\n      ?.mint;\n    if (initMint)\n      existentAssociatedAccounts[initMint.toBase58()] = initTokenAccount;\n  }\n  return existentAssociatedAccounts;\n};\n\nexport const getAssociatedTokenAccounts = () => {\n  const associatedAccounts = (\n    solanaSplStore.state.derivedTokenAccounts || []\n  ).reduce((prior, splStore) => {\n    prior[splStore.info.mint.toBase58()] = new PublicKey(splStore.account);\n    return prior;\n  }, {} as BuildEphemeralOpts[\"associatedTokenAccounts\"]);\n  return associatedAccounts;\n};\n\nexport const buildEphemeralInstruction = (): BuildEphemeralTxsInstr => {\n  const actionMetadatas = buildActionMetas();\n  const [initSplits, initIds] = getInitialSplitsAndNextIds();\n  const allActions = getAllActionNodeIds();\n\n  const actionTokenMintIns = allActions.map(getTokenMintIn);\n\n  // Get all actions to pass into the malloc sdk\n  const allActionsFilled: Action[] = allActions.map((actionId, i) => {\n    const actionInfo = nodeInfoStore.state[actionId]?.action;\n    if (!actionInfo) throw `Missing action info for node of id ${actionId}`;\n    const tokenMintIn = actionTokenMintIns[i];\n    if (!tokenMintIn)\n      throw `Missing input token mint for node of id ${tokenMintIn}`;\n    return {\n      ...actionInfo,\n      actionMetadata: actionMetadatas[i],\n      tokenMintIn,\n    };\n  });\n\n  const initIdxs = initIds.map((id) => allActions.indexOf(id));\n\n  initIdxs.forEach((i) => {\n    if (i < 0) throw \"An unexpected error occured in building the action list\";\n  });\n  const initTokenAccount = flowStore.state.initTokenAccount;\n  if (!initTokenAccount) throw \"Init token account not set\";\n\n  return {\n    actions: allActionsFilled, // TODO: ACTION, authority for amount in and construction, ALSO, add \"output address\" to transfer\n    initialSplits: initSplits,\n    initialActionIndices: initIdxs,\n    amount: new u64(flowStore.state.initAmount),\n    amountInAccount: initTokenAccount!,\n  };\n};\n\nconst compileAndRunFlow = async (\n  provider: anchor.Provider\n): Promise<string[]> => {\n  setEphemeralRunLoading(true);\n  try {\n    while (loadingStore.state.storeUpdateLoading) {\n      await new Promise((res, rej) => setTimeout(res, 50));\n    }\n\n    const inst = buildEphemeralInstruction();\n    const mallocSdk = getMallocSdk(provider);\n\n    const existentAssociatedAccounts = await getAllKnownUserTokenAccounts(\n      provider\n    );\n    const data = await mallocSdk.buildTxs({\n      ...inst,\n      opts: {\n        associatedTokenAccounts: existentAssociatedAccounts,\n      },\n    });\n    const retHashes = await mallocSdk.sendRequests(data, {\n      prepareCommitment: {\n        skipPreflight: false,\n        preflightCommitment: 'processed',\n        commitment: \"processed\",\n      },\n      actionCommitment: {\n        commitment: \"confirmed\",\n        // skipPreflight: false,\n        skipPreflight: true\n      },\n      onPrepareAccountsDone: async (txHashes) => {\n        const rets = await Promise.all(\n          txHashes.map((txHash) =>\n            provider.connection.confirmTransaction(txHash, \"confirmed\")\n          )\n        );\n      },\n    });\n\n    setEphemeralRunLoading(false);\n    return retHashes;\n  } catch (e) {\n    setEphemeralRunLoading(false);\n    throw e;\n  }\n};\n\nexport const compileAndRunFlowChecked = async (provider: anchor.Provider) => {\n  try {\n    await compileAndRunFlow(provider)\n  } catch (e) {\n    console.error(e)\n    alert(\"An error occured in running your flow\")\n    throw e\n  }\n}","import { Wallet } from \"@project-serum/anchor\";\nimport { createTokenAccount, Provider } from \"@project-serum/common\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport { Connection, Keypair, PublicKey, Transaction } from \"@solana/web3.js\";\nimport { getConstants } from \"../../config/constants\";\n\nconst richUSDCAirdroperSK = new Uint8Array([\n  8, 57, 204, 222, 105, 129, 113, 8, 245, 54, 20, 45, 122, 175, 82, 37, 32, 44,\n  46, 6, 54, 35, 168, 208, 213, 194, 164, 50, 97, 226, 134, 119, 136, 196, 213,\n  189, 243, 233, 16, 53, 22, 220, 245, 4, 17, 203, 251, 233, 20, 7, 178, 5, 36,\n  19, 66, 89, 210, 148, 19, 225, 117, 61, 214, 253,\n]);\n\nconst richUSDCSigner = new Wallet(Keypair.fromSecretKey(richUSDCAirdroperSK));\n\nconst getRichUsdcProvider = (endpointURL: string) =>\n  new Provider(new Connection(endpointURL), richUSDCSigner, {\n    commitment: \"confirmed\",\n  });\n\nexport const performUsdcAirdrop = async (userAddr: PublicKey) => {\n  try {\n    const tokAccount = await tryCreateAssociatedAccount(\n      new PublicKey(getConstants().demo.FAKE_USDC),\n      userAddr,\n      getRichUsdcProvider(getConstants().solana.RPC)\n    );\n    await airdrop(new PublicKey(getConstants().demo.FAKE_USDC_GD), [\n      tokAccount,\n    ]);\n    alert(\"Done with your airdrop\");\n    window.location.reload();\n  } catch (e) {\n    console.error(e);\n    alert(`An error occurred with the airdrop ${JSON.stringify(e)}`);\n  }\n};\n\nconst tryCreateAssociatedAccount = async (\n  mint: PublicKey,\n  account: PublicKey,\n  provider: Provider\n): Promise<PublicKey> => {\n  const associated = (\n    await PublicKey.findProgramAddress(\n      [\n        account.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(mint).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n  console.log(associated.toBase58());\n  const data = await provider.connection.getAccountInfo(associated);\n  if (!data) {\n    const instr = Token.createAssociatedTokenAccountInstruction(\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n      TOKEN_PROGRAM_ID,\n      mint,\n      associated,\n      account,\n      provider.wallet.publicKey\n    );\n    const tx = new Transaction();\n    tx.add(instr);\n    await provider.send(tx, []);\n    return associated;\n  }\n  return associated;\n};\n\nconst airdrop = async (\n  gdUsdc: PublicKey,\n  airDropToTokenAccounts: PublicKey[]\n) => {\n  const decimals = 6;\n  const amountAirdrop = 7 * 10 ** decimals;\n\n  const transferTxs: Transaction = new Transaction();\n  airDropToTokenAccounts.map((tokAccount) => {\n    transferTxs.add(\n      Token.createTransferInstruction(\n        TOKEN_PROGRAM_ID,\n        gdUsdc,\n        tokAccount,\n        richUSDCSigner.publicKey,\n        [],\n        amountAirdrop\n      )\n    );\n  });\n\n  await getRichUsdcProvider(getConstants().solana.RPC).send(transferTxs, [], {\n    skipPreflight: true,\n  });\n};\n","import Button from \"@material-ui/core/Button\";\nimport React, { useState } from \"react\";\nimport Card from \"@material-ui/core/Card\";\nimport CardActions from \"@material-ui/core/CardActions\";\nimport CardContent from \"@material-ui/core/CardContent\";\nimport { FlowElement } from \"react-flow-renderer\";\nimport { PushElemsFn, SetElemsFn } from \"../../interfaces\";\nimport {\n  getDefaultSwapNodeSet,\n  getDefaultTransferNodeSet,\n  getInitSplitter,\n} from \"../../utils/premade-nodes\";\nimport { compileAndRunFlowChecked } from \"../../utils/flow-chart-utils\";\nimport { useAnchorWallet, useWallet } from \"@solana/wallet-adapter-react\";\nimport { Provider, Wallet } from \"@project-serum/anchor\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getConstants } from \"../../config/constants\";\nimport { loadingStore } from \"../../state/flowchart-store\";\nimport { useStore } from \"react-stores\";\nimport { performUsdcAirdrop } from \"../usdc-airdrop/perform-usdc-airdrop\";\n\nconst ConstructionSidePanel = (props: {\n  pushElemsFn: PushElemsFn;\n  setElemsFn: SetElemsFn;\n}) => {\n  const solwallet = useWallet();\n  const wallet = useAnchorWallet();\n  const loadingStoreHook = useStore(loadingStore);\n  const [airdropLoading, setAirdropLoading] = useState(false);\n\n  const compileAndRun = () => {\n    // TODO: move into malloc sdk?\n    if (!wallet) throw \"Expected the wallet to be connected\";\n    const provider = new Provider(\n      new Connection(getConstants().solana.RPC),\n      wallet,\n      {\n        skipPreflight: true, // TODO: to keep?\n        preflightCommitment: \"confirmed\",\n      }\n    );\n    compileAndRunFlowChecked(provider)\n      .then((hashes) => {\n        alert(\"Ran successfully!\");\n        window.location.reload();\n      })\n      .catch((e) => {\n        alert(`An error occured: ${e}`);\n        console.error(e);\n      });\n  };\n  return (\n    <Card style={{ maxWidth: \"300px\" }}>\n      <CardContent\n        style={{ display: \"grid\", gridTemplateColumns: \"1fr\", gap: \"1rem\" }}\n      >\n        {/* <Button onClick={() => props.pushElemsFn([getDefaultSplitterNode()])}>\n          Add Splitter\n        </Button> */}\n        <Button onClick={() => props.pushElemsFn(getDefaultTransferNodeSet())}>\n          Add Transfer Action\n        </Button>\n        <Button onClick={() => props.pushElemsFn(getDefaultSwapNodeSet())}>\n          Add Swap Action\n        </Button>\n        <Button\n          onClick={compileAndRun}\n          disabled={loadingStoreHook.storeUpdateLoading}\n        >\n          Compile and Run\n        </Button>\n        <br />\n        {/* {airdropLoading && <>Loading Airdrop...</>} */}\n        <Button\n          onClick={() => {\n            setAirdropLoading(true);\n            performUsdcAirdrop(wallet!.publicKey!).then(() =>\n              setAirdropLoading(false)\n            );\n          }}\n          disabled={airdropLoading}\n        >\n          {airdropLoading && 'loading...'}\n          Airdrop fake USDC\n        </Button>\n        <br />\n        <Button\n          onClick={() => props.setElemsFn([getInitSplitter()])}\n          color=\"secondary\"\n        >\n          Delete all\n        </Button>\n\n        <Button onClick={() => solwallet.disconnect()} color=\"secondary\">\n          Sign Out\n        </Button>\n        {/* <Button>Add Swap Action</Button> */}\n        {/* <Button>Add Swap Action</Button> */}\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default ConstructionSidePanel;\n","import Button from \"@material-ui/core/Button\";\nimport TextField from \"@material-ui/core/TextField\";\nimport { BN } from \"@project-serum/anchor\";\nimport { u64 } from \"@solana/spl-token\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React, { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport ReactFlow, {\n  FlowElement,\n  Handle,\n  Position,\n  Node as FlowNode,\n  Connection,\n  Edge,\n} from \"react-flow-renderer\";\nimport { useStore } from \"react-stores\";\nimport { PushElemsFn, SPLToken } from \"../../interfaces\";\nimport {\n  flowStore,\n  nodeInfoStore,\n  setElemFn,\n} from \"../../state/flowchart-store\";\nimport { getProvider } from \"../../utils/anchor\";\nimport {\n  getAllEdgesWithSource,\n  getAllEdgesWithTarget,\n  getAllNodesWithEdgesToTarget,\n  handleConnectIn,\n} from \"../../utils/flow-chart-utils\";\nimport { fromReadableNumber, getTokenLists } from \"../../utils/spl-tokens\";\nimport TokenAccountChooser from \"../tokens/TokenAccountChooser\";\n\n\nexport const getSplitterNode = (pushElems: PushElemsFn) => {\n  return (props: { data: { isInitial?: boolean; id: string } }) => {\n    const elements = useStore(flowStore);\n    const nodeInfoStateVals = useStore(nodeInfoStore);\n    const wallet = useAnchorWallet();\n    const [numbSources, setNumbSources] = useState(0);\n    const [amountInitIn, setAmountInitIn] = useState<number | undefined>(undefined);\n    const [splits, setSplits] = useState<number[]>([]);\n    const [inputInitSplToken, setInputInitSplToken] = useState<null | SPLToken>(\n      null\n    );\n    const flowState = useStore(flowStore);\n    const nodeState = useStore(nodeInfoStore);\n\n    // Update the amount in to match the unitary representation\n    useEffect(() => {\n      if (!props.data?.isInitial) return;\n      if (!inputInitSplToken) return;\n      if (!amountInitIn) return;\n\n      const expandedNumb = fromReadableNumber(\n        amountInitIn,\n        inputInitSplToken.info.decimals\n      );\n      const initAmount = new u64(expandedNumb);\n      flowStore.setState({\n        ...elements,\n        initAmount,\n      });\n    }, [amountInitIn, inputInitSplToken]);\n\n    // Set the input token for Initial Splitter\n    useEffect(() => {\n      if (!inputInitSplToken?.account) return;\n      if (!props.data?.isInitial) return;\n      flowStore.setState({\n        ...elements,\n        initTokenAccount: new PublicKey(inputInitSplToken?.account),\n      });\n    }, [inputInitSplToken]);\n\n    const setEdgeAnimated = (ind: number, animated: boolean) => {\n      const allEdges = getAllEdgesWithSource(elements.elements, props.data.id);\n      if (allEdges.length < ind) {\n        alert(\"The flow chart is malformed, please start over\");\n        throw \"The flow chart is malformed, please start over\";\n      }\n      const edge = allEdges[ind];\n      const edgeInd = elements.elements.findIndex((e) => e.id === edge);\n      const edgeObj = elements.elements[edgeInd] as Edge;\n      edgeObj.animated = animated;\n      setElemFn(edgeObj, edgeInd);\n    };\n\n    const updateNonInitSplitterState = async () => {\n      if (props.data.isInitial) return;\n      const tokList = await getTokenLists(getProvider(wallet!));\n      const inputNodes = getAllNodesWithEdgesToTarget(\n        flowState.elements,\n        props.data.id\n      );\n      if (inputNodes.length === 0) return;\n      const inpNodeStates = inputNodes.map((id) => nodeState[id]);\n      if (inpNodeStates.some((n) => !n || !n.action)) return;\n      // TODO:!!! only assume 1 token mint out right now, this will change shortly...\n      if (\n        !inpNodeStates.every(\n          (n) =>\n            n.action!.tokenMintOuts[0] ===\n            inpNodeStates[0].action!.tokenMintOuts[0]\n        )\n      ) {\n        throw \"Expected all input mints to be the same into splitter\";\n      }\n      if (inpNodeStates[0].action!.tokenMintOuts.length === 0) return;\n      const mint = inpNodeStates[0].action!.tokenMintOuts[0];\n      // TODO: there has to be something else here... all token accounts per mint must be the same\n      const tokenAccountOuts = inpNodeStates[0].action!.tokenAccountsOuts[0];\n      nodeInfoStateVals[props.data.id] = {\n        splitter: {\n          splits,\n          tokenAccount: tokenAccountOuts,\n          mint: mint ?? undefined,\n        },\n      };\n      // Do not update the state if the values already equal\n      if (\n        nodeState[props.data.id].splitter?.mint?.toBase58() ===\n          mint.toBase58() &&\n        nodeState[props.data.id].splitter?.tokenAccount?.toBase58() ===\n          tokenAccountOuts.toBase58()\n      ) {\n        return;\n      }\n      nodeInfoStore.setState({ ...nodeInfoStateVals });\n    };\n\n    // Update the incoming mint for a non initial splitter\n    useEffect(() => {\n      updateNonInitSplitterState();\n    }, [flowState, nodeState]);\n    useEffect(() => {\n      updateNonInitSplitterState();\n    }, []);\n\n    useEffect(() => {\n      // TODO: for splitter not init!\n      const mint = props.data.isInitial\n        ? inputInitSplToken?.info.mint\n        : undefined;\n      const tokenAccount = props.data.isInitial\n        ? inputInitSplToken\n          ? new PublicKey(inputInitSplToken.account)\n          : undefined\n        : undefined;\n      nodeInfoStateVals[props.data.id] = {\n        splitter: {\n          splits,\n          tokenAccount,\n          mint: mint ?? undefined,\n        },\n      };\n      nodeInfoStore.setState({ ...nodeInfoStateVals });\n    }, [splits]);\n\n    useEffect(() => {\n      const edgesWithSources = getAllEdgesWithSource(\n        elements.elements,\n        props.data.id\n      );\n      const newNumbSources = edgesWithSources.length;\n      const diff = newNumbSources - numbSources;\n      if (diff < 0) {\n        setSplits([...splits.slice(0, splits.length + diff)]);\n      } else {\n        setSplits([...splits, ...Array(diff).fill(100)]);\n      }\n      setNumbSources(newNumbSources);\n      // setNumbSources(\n      //   getAllEdgesWithSource(elements.elements, props.data.id).length\n      // );\n    }, [elements]);\n\n    const setSplitAmounts = (e: any, i: number) => {\n      splits[i] = parseInt(e.target.value);\n      setSplits([...splits]);\n    };\n\n    return (\n      <div\n        style={{\n          padding: \"1rem\",\n        }}\n      >\n        <h4>{props.data?.isInitial ? \"Initial Splitter\" : \"Splitter\"}</h4>\n        {props.data?.isInitial && (\n          <TokenAccountChooser onClose={setInputInitSplToken} />\n        )}\n        {props.data?.isInitial && (\n          <div style={{ paddingBottom: \"3rem\" }}>\n            <TextField\n              label={`Amount of ${\n                inputInitSplToken?.info.name ??\n                inputInitSplToken?.info.mint.toBase58() ??\n                \"<Input token account not set>\"\n              }`}\n              type=\"number\"\n              value={amountInitIn}\n              onChange={(e) => {\n                try {\n                  if (!e.target.value) return;\n                  const parsed = parseFloat(e.target.value);\n                  setAmountInitIn(parsed);\n                } catch (e) {\n                  alert(\"Looks like an invalid number was inputted\");\n                }\n              }}\n            />\n          </div>\n        )}\n        {!props.data?.isInitial && (\n          <Handle\n            type=\"target\"\n            position={Position.Top}\n            // onConnect={(conn) => {\n            //   handleConnectIn(conn, pushElems);\n            // }}\n          />\n        )}\n        {new Array(numbSources).fill(0).map((e, i) => (\n          <div key={`splitter-frac-${i}`}>\n            <TextField\n              type=\"number\"\n              label=\"Fractional Amount\"\n              onFocus={() => setEdgeAnimated(i, true)}\n              onBlur={() => setEdgeAnimated(i, false)}\n              value={splits[i]}\n              onChange={(e) => setSplitAmounts(e, i)}\n            />\n          </div>\n        ))}\n\n        <Handle\n          type=\"source\"\n          position={Position.Bottom}\n          onConnect={(conn) => {\n            const added = handleConnectIn(conn, pushElems, false);\n          }}\n          id=\"a\"\n          style={{\n            left: `50%`,\n          }}\n        />\n      </div>\n    );\n  };\n};\n","import TextField from \"@material-ui/core/TextField\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React, { ReactElement } from \"react\";\nimport { useEffect } from \"react\";\nimport { useState } from \"react\";\nimport ReactFlow, {\n  Edge,\n  FlowElement,\n  Handle,\n  Position,\n} from \"react-flow-renderer\";\nimport { useStore } from \"react-stores\";\nimport { getConstants } from \"../../config/constants\";\nimport { PushElemsFn } from \"../../interfaces\";\nimport {\n  flowStore,\n  IFlowChart,\n  NodeInfos,\n  nodeInfoStore,\n  setStoreUpdateLoading,\n} from \"../../state/flowchart-store\";\nimport { getProvider } from \"../../utils/anchor\";\nimport {\n  getTokenAccountIn,\n  getTokenMintIn,\n  handleConnectIn,\n} from \"../../utils/flow-chart-utils\";\nimport {\n  findAssociatedTokenAddress,\n  getTokenLists,\n} from \"../../utils/spl-tokens\";\n\nexport interface ActionNodeProps {\n  id: string;\n  flowState: IFlowChart;\n  nodeInfoStoreState: NodeInfos;\n  mintName: string;\n  toggleNodeInfoSet: boolean | null;\n  mint: PublicKey | null;\n  tokenAccount: PublicKey | null;\n}\n\nexport const getActionTemplate =\n  (\n    pushElems: PushElemsFn,\n    ActionNode: (props: ActionNodeProps) => ReactElement<ActionNodeProps>\n  ) =>\n  (props: { id: string }) => {\n    const nodeInfoStoreState = useStore(nodeInfoStore);\n    const wallet = useAnchorWallet();\n    const [mint, setMint] = useState(getTokenMintIn(props.id));\n    const [tokenAccount, setTokenAccount] = useState<PublicKey | null>(null);\n\n    const [mintName, setMintName] = useState(\"<not set>\");\n    const [toggleNodeInfoSet, setToggleNodeInfoSet] = useState<boolean | null>(\n      null\n    );\n    const flowState = useStore(flowStore);\n\n    const setInfos = async () => {\n      const tokList = await getTokenLists(getProvider(wallet!));\n      const tok = tokList.find((_mint) => _mint.address === mint?.toBase58());\n      setTokenAccount(await getTokenAccountIn(props.id));\n      setMintName(tok?.name || mint?.toBase58() || \"<not set>\");\n      setToggleNodeInfoSet(!toggleNodeInfoSet);\n    };\n    useEffect(() => {\n      setInfos();\n    }, [mint]);\n\n    useEffect(() => {\n      if (mint) setToggleNodeInfoSet(!toggleNodeInfoSet);\n      setInfos();\n    }, []);\n\n    useEffect(() => {\n      const newMint = getTokenMintIn(props.id);\n\n      const newTokenIn = getTokenAccountIn(props.id);\n      if (newTokenIn && (!tokenAccount || !newTokenIn.equals(tokenAccount)))\n        setTokenAccount(newTokenIn);\n      if (newMint && (!mint || newMint?.equals(mint) === false)) {\n        setMint(newMint);\n        setToggleNodeInfoSet(!toggleNodeInfoSet);\n      }\n    }, [flowState, nodeInfoStoreState]);\n\n    return (\n      <div className=\"flow-chart-node\">\n        <Handle\n          type=\"target\"\n          position={Position.Top}\n          style={{ borderRadius: 0 }}\n        />\n        <ActionNode\n          tokenAccount={tokenAccount}\n          id={props.id}\n          flowState={flowState}\n          nodeInfoStoreState={nodeInfoStoreState}\n          mintName={mintName}\n          toggleNodeInfoSet={toggleNodeInfoSet}\n          mint={mint}\n        />\n      </div>\n    );\n  };\n","import React from \"react\";\nimport { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport { useStore } from \"react-stores\";\nimport ReactFlow, { Elements, FlowElement } from \"react-flow-renderer\";\nimport SwapNode from \"../components/actions/SwapNode\";\nimport ConstructionSidePanel from \"../components/constructions/SidePanel\";\nimport { getSplitterNode } from \"../components/constructions/SplitterNode\";\nimport {\n  flowStore,\n  pushElemsOntoFlow,\n  setElemsFn,\n} from \"../state/flowchart-store\";\nimport { getActionTemplate } from \"../components/actions/ActionTemplate\";\nimport { TransferNode } from \"../components/actions/Transfer\";\n\nexport default () => {\n  const elements = useStore(flowStore);\n\n  useEffect(() => {}, []);\n\n  const nodeTypes = {\n    swap: getActionTemplate(pushElemsOntoFlow, SwapNode),\n    transfer: getActionTemplate(pushElemsOntoFlow, TransferNode),\n    splitter: getSplitterNode(pushElemsOntoFlow),\n  };\n\n  return (\n    <div style={{ height: \"100%\", width: \"100%\", padding: \"1rem\" }}>\n      <div style={{ position: \"absolute\", zIndex: 100 }}>\n        <ConstructionSidePanel\n          pushElemsFn={pushElemsOntoFlow}\n          setElemsFn={setElemsFn}\n        />\n      </div>\n      {<ReactFlow elements={elements.elements} nodeTypes={nodeTypes} />}\n    </div>\n  );\n};\n","import PacmanLoader from \"react-spinners/PacmanLoader\";\nimport {css} from '@emotion/react'\n\nconst LoadingTx = () => {\n  return (\n    <div\n      className=\"full-screen greyed\"\n      style={{\n        display: \"grid\",\n        justifyContent: \"center\",\n        alignContent: \"center\",\n\t\t\t\tjustifyItems: 'center',\n\t\t\t\tgridTemplateColumns: '1fr'\n      }}\n    >\n\t\t\t\n      <PacmanLoader loading={true} css={css`\n\t\t\t\theight: 200px;\t\n\t\t\t`} size={80}/>\n      <h3>Waiting while the Solana Network eats your gas fees</h3>\n    </div>\n  );\n};\nexport default LoadingTx;\n","import { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport Countdown from \"react-countdown\";\nimport { Button, CircularProgress, Snackbar } from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\n\nimport * as anchor from \"@project-serum/anchor\";\n\nimport { LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nimport { WalletDialogButton } from \"@solana/wallet-adapter-material-ui\";\n\nimport {\n  CandyMachine,\n  awaitTransactionSignatureConfirmation,\n  mintOneToken,\n  shortenAddress,\n} from \"./utils/malloc\";\nimport Flowchart from \"./views/Flowchart\";\nimport { useStore } from \"react-stores\";\nimport { loadingStore } from \"./state/flowchart-store\";\nimport LoadingTX from \"./components/tx-handler/LoadingTX\";\n\nconst ConnectButton = styled(WalletDialogButton)``;\n\nconst CounterText = styled.span``; // add your styles here\n\nexport interface HomeProps {\n  config: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  startDate: number;\n  txTimeout: number;\n}\n\nconst Home = (props: HomeProps) => {\n  const [balance, setBalance] = useState<number>();\n  const [isActive, setIsActive] = useState(false); // true when countdown completes\n  const [isSoldOut, setIsSoldOut] = useState(false); // true when items remaining is zero\n  const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n  const loadingState = useStore(loadingStore);\n\n  const [alertState, setAlertState] = useState<AlertState>({\n    open: false,\n    message: \"\",\n    severity: undefined,\n  });\n\n  const [startDate, setStartDate] = useState(new Date(props.startDate));\n\n  const wallet = useWallet();\n  const [candyMachine, setCandyMachine] = useState<CandyMachine>();\n\n  useEffect(() => {\n    (async () => {\n      if (wallet?.publicKey) {\n        const balance = await props.connection.getBalance(wallet.publicKey);\n        setBalance(balance / LAMPORTS_PER_SOL);\n      }\n    })();\n  }, [wallet, props.connection]);\n\n  return (\n    <main>\n      {wallet.connected && (\n        <p style={{ marginTop: 0 }}>\n          Address: {shortenAddress(wallet.publicKey?.toBase58() || \"\")}\n        </p>\n      )}\n\n      {wallet.connected && (\n        <p>Balance: {(balance || 0).toLocaleString()} SOL</p>\n      )}\n      {wallet.connected && <Flowchart />}\n      {!wallet.connected && <ConnectButton>Connect Wallet</ConnectButton>}\n      {loadingState.ephemeralRunLoading && <LoadingTX />}\n      <Snackbar\n        open={alertState.open}\n        autoHideDuration={6000}\n        onClose={() => setAlertState({ ...alertState, open: false })}\n      >\n        <Alert\n          onClose={() => setAlertState({ ...alertState, open: false })}\n          severity={alertState.severity}\n        >\n          {alertState.message}\n        </Alert>\n      </Snackbar>\n    </main>\n  );\n};\n\ninterface AlertState {\n  open: boolean;\n  message: string;\n  severity: \"success\" | \"info\" | \"warning\" | \"error\" | undefined;\n}\n\nconst renderCounter = ({ days, hours, minutes, seconds, completed }: any) => {\n  return (\n    <CounterText>\n      {hours} hours, {minutes} minutes, {seconds} seconds\n    </CounterText>\n  );\n};\n\nexport default Home;\n","import \"./App.css\";\nimport { useMemo } from \"react\";\n\nimport Home from \"./Home\";\n\nimport * as anchor from \"@project-serum/anchor\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n  getPhantomWallet,\n  getSolflareWallet,\n  getSolletWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n  ConnectionProvider,\n  WalletProvider,\n} from \"@solana/wallet-adapter-react\";\n\nimport { WalletDialogProvider } from \"@solana/wallet-adapter-material-ui\";\nimport { getConstants } from \"./config/constants\";\n\nconst config = new anchor.web3.PublicKey(getConstants().MALLOC_PROGRAM_ID);\n\nconst network = getConstants().solana.NETWORK;\n\nconst rpcHost = getConstants().solana.RPC;\nconst connection = new anchor.web3.Connection(rpcHost);\n\nconst startDateSeed = parseInt(process.env.REACT_APP_CANDY_START_DATE!, 10);\n\nconst txTimeout = 30000; // milliseconds (confirm this works for your project)\n\nconst App = () => {\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [getPhantomWallet(), getSolflareWallet(), getSolletWallet()],\n    []\n  );\n\n  return (\n    <ConnectionProvider endpoint={endpoint}>\n      <WalletProvider wallets={wallets} autoConnect>\n        <WalletDialogProvider>\n          <Home\n            config={config}\n            connection={connection}\n            startDate={startDateSeed}\n            txTimeout={txTimeout}\n          />\n        </WalletDialogProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import { Provider } from \"@project-serum/anchor\";\nimport { AnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getConstants } from \"../config/constants\";\n\nexport const getProvider = (wallet: AnchorWallet): Provider => {\n  return new Provider(new Connection(getConstants().solana.RPC), wallet, {});\n};\n","import { PublicKey } from \"@solana/web3.js\";\n\nexport enum Side {\n  Bid = 0,\n  Ask = 1,\n}\n\nexport interface SwapAccounts {\n  market: {\n    market: PublicKey;\n    requestQueue: PublicKey;\n    eventQueue: PublicKey;\n    bids: PublicKey;\n    asks: PublicKey;\n    coinVault: PublicKey;\n    pcVault: PublicKey;\n    vaultSigner: PublicKey;\n    // User params.\n    openOrders: PublicKey;\n    orderPayerTokenAccount: PublicKey;\n    coinWallet: PublicKey;\n  };\n  pcWallet: PublicKey;\n  authority: PublicKey;\n  dexProgram: PublicKey;\n  tokenProgram: PublicKey;\n  rent: PublicKey;\n}\n\nexport enum SwapInstructionByte {\n  BasicSwap = 0,\n}\n","export const CONSTRUCTION_ACCOUNT_SIZE = 2e4; // Around 3 kilobytes\nconst ONE_HOUR_MS = 1000 * 60 * 60;\nconst HOURS_PER_EPOCH = 48;\nexport const LIVE_N_EPOCHS = 3;\nexport const LIFETIME_RESULT_ACCOUNT_MS = ONE_HOUR_MS * (HOURS_PER_EPOCH * LIVE_N_EPOCHS); // Has to be more than 1 epoch, lets be sage\nexport const LIFETIME_CONSTRUCTION_ACCOUNT_MS =\n  ONE_HOUR_MS * (HOURS_PER_EPOCH * LIVE_N_EPOCHS);\n\n// Rent constants from https://docs.solana.com/developing/programming-model/accounts\n// TODO: should this be from a dynamic value?\nexport const LAMPORTS_PER_EPOCH = 19.055;\nexport const MS_PER_EPOCH = ONE_HOUR_MS * HOURS_PER_EPOCH;\n","import { Action } from \"./interfaces\";\nimport { createTokenAccountInstrs } from \"@project-serum/common\";\nimport {\n  TOKEN_PROGRAM_ID,\n  transfer,\n} from \"@project-serum/serum/lib/token-instructions\";\nimport { Signer, PublicKey, Transaction } from \"@solana/web3.js\";\nimport Provider, { SendTxRequest } from \"@project-serum/anchor/dist/provider\";\nimport { BN, Wallet, web3 } from \"@project-serum/anchor\";\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\n\nexport interface AccountByMint {\n  [mint: string]: { publicKey: PublicKey };\n}\n\nexport const transferToTx = async (\n  source: PublicKey,\n  destination: PublicKey,\n  amount: BN,\n  authority: Signer | Wallet\n): Promise<SendTxRequest> => {\n  const signer = (authority as Signer).secretKey ? [authority as Signer] : [];\n  const inst = transfer({\n    source,\n    destination,\n    amount,\n    owner: authority.publicKey,\n  });\n  const tx = new Transaction();\n  tx.add(inst);\n  return { tx, signers: signer };\n};\n\n// TODO: testme\n/**\n * Takes in a mapping of mints to token accounts. If a token account has yet to exist, one will be made\n * which is associated to the authority's address\n *\n * @param associatedTokenAccounts - a map of mints to token accounts which the caller would prefer to use per mint. If the account does not exist,\n * and is needed it will be created in the the returned txs\n */\nexport const createTokenAccountsForActions = async (\n  provider: Provider,\n  tokenAuthority: Signer | Wallet,\n  actions: Action[],\n  fundingAccount: Signer | Wallet,\n  associatedTokenAccounts?: { [mint: string]: PublicKey }\n): Promise<{ accounts: AccountByMint; txs: SendTxRequest[] }> => {\n  const mints = getMintsNoDuplicates(\n    actions.map((a) => [a.tokenMintIn, ...a.tokenMintOuts]).flat()\n  );\n  console.log(\n    \"Got all mints of\",\n    mints,\n    \"Got associated accounts of\",\n    associatedTokenAccounts\n  );\n  let accounts: AccountByMint = {};\n  for (let i = 0; i < mints.length; i++) {\n    const mint = mints[i];\n    if ((associatedTokenAccounts || {})[mint])\n      accounts[mint] = { publicKey: associatedTokenAccounts[mint] };\n    // create the token account if not provided\n    else {\n      const pk = await findAssociatedTokenAddress(\n        tokenAuthority.publicKey,\n        mint\n      );\n      accounts[mint] = {\n        publicKey: pk, // TODO: check that this account does not yet exist\n      };\n    }\n  }\n\n  const createTokTx = await Promise.all(\n    mints.map(async (mint) => {\n      const associatedToSignerAccount = accounts[mint].publicKey;\n      const accountExists = await provider.connection.getAccountInfo(\n        associatedToSignerAccount\n      );\n\n      // Return if the account already exists\n      if (accountExists) {\n        console.log(\"ALREADY EXISTS\");\n        return null;\n      }\n      const insts = Token.createAssociatedTokenAccountInstruction(\n        ASSOCIATED_TOKEN_PROGRAM_ID,\n        TOKEN_PROGRAM_ID,\n        new PublicKey(mint),\n        accounts[mint].publicKey,\n        tokenAuthority.publicKey,\n        fundingAccount.publicKey\n      );\n      const tx = new Transaction();\n      tx.add(insts);\n      console.log(insts);\n      const signers: Signer[] = (fundingAccount as Signer).secretKey\n        ? [fundingAccount as Signer]\n        : [];\n      return {\n        tx,\n        signers: signers,\n      };\n    })\n  );\n\n  return { accounts: accounts, txs: createTokTx.filter((i) => !!i) };\n};\n\n// TODO: if there are 2 token accounts of the same type, one of them not being made, then there will be an error out\n\n// See https://spl.solana.com/associated-token-account\nconst findAssociatedTokenAddress = async (\n  walletAddress: PublicKey,\n  tokenMintAddress: PublicKey | string\n): Promise<PublicKey> => {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        walletAddress.toBuffer(),\n        TOKEN_PROGRAM_ID.toBuffer(),\n        new PublicKey(tokenMintAddress).toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getMintsNoDuplicates = (mints: PublicKey[]) => [\n  ...new Set(mints.map(pkToStr)),\n];\n\nexport const pkToStr = (pk: PublicKey) => pk.toBase58();\nexport const pkFromStr = (pk: string) => new PublicKey(pk);\n","import * as anchor from \"@project-serum/anchor\";\nimport {\n  MallocSdk,\n} from \"@malloc/sdk\";\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from \"@solana/spl-token\";\nimport { getConstants } from \"../config/constants\";\nimport { PublicKey } from \"@solana/web3.js\";\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n  \"cndyAnrLdpjq1Ssp1z8xxDsB8dxe7u4HL5Nxi2K5WXZ\"\n);\n\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\nexport interface CandyMachine {\n  id: anchor.web3.PublicKey;\n  connection: anchor.web3.Connection;\n  program: anchor.Program;\n}\n\ninterface CandyMachineState {\n  candyMachine: CandyMachine;\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  goLiveDate: Date;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  commitment: anchor.web3.Commitment = \"recent\",\n  queryStatus = false\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log(\"Rejecting for timeout...\");\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result: any, context: any) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log(\"Rejected via websocket\", result.err);\n            reject(status);\n          } else {\n            console.log(\"Resolved via websocket\", result);\n            resolve(status);\n          }\n        },\n        commitment\n      );\n    } catch (e) {\n      done = true;\n      console.error(\"WS error in setup\", txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log(\"REST null result for\", txid, status);\n            } else if (status.err) {\n              console.log(\"REST error for\", txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log(\"REST no confirmations for\", txid, status);\n            } else {\n              console.log(\"REST confirmation for\", txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log(\"REST connection error: txid\", txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log(\"Returning status\", status);\n  return status;\n};\n\n/* export */ const createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\n// export const getCandyMachineState = async (\n//   anchorWallet: anchor.Wallet,\n//   candyMachineId: anchor.web3.PublicKey,\n//   connection: anchor.web3.Connection,\n// ): Promise<CandyMachineState> => {\n// const provider = new anchor.Provider(connection, anchorWallet, {\n//   preflightCommitment: \"recent\",\n// });\n\n// const idl = await anchor.Program.fetchIdl(\n//   CANDY_MACHINE_PROGRAM,\n//   provider\n// );\n\n// const program = new anchor.Program(idl, CANDY_MACHINE_PROGRAM, provider);\n// const candyMachine = {\n//   id: candyMachineId,\n//   connection,\n//   program,\n// }\n\n// const state: any = await program.account.candyMachine.fetch(candyMachineId);\n// const itemsAvailable = state.data.itemsAvailable.toNumber();\n// const itemsRedeemed = state.itemsRedeemed.toNumber();\n// const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n// let goLiveDate = state.data.goLiveDate.toNumber();\n// goLiveDate = new Date(goLiveDate * 1000);\n\n// return {\n//   candyMachine,\n//   itemsAvailable,\n//   itemsRedeemed,\n//   itemsRemaining,\n//   goLiveDate,\n// };\n// }\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from(\"edition\"),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nconst getTokenWallet = async (\n  wallet: anchor.web3.PublicKey,\n  mint: anchor.web3.PublicKey\n) => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n    )\n  )[0];\n};\n\nexport const mintOneToken = async (\n  candyMachine: CandyMachine,\n  config: anchor.web3.PublicKey, // feels like this should be part of candyMachine?\n  payer: anchor.web3.PublicKey,\n  treasury: anchor.web3.PublicKey\n): Promise<string> => {\n  const mint = anchor.web3.Keypair.generate();\n  const token = await getTokenWallet(payer, mint.publicKey);\n  const { connection, program } = candyMachine;\n  const metadata = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const rent = await connection.getMinimumBalanceForRentExemption(\n    MintLayout.span\n  );\n\n  return await program.rpc.mintNft({\n    accounts: {\n      config,\n      candyMachine: candyMachine.id,\n      payer: payer,\n      wallet: treasury,\n      mint: mint.publicKey,\n      metadata,\n      masterEdition,\n      mintAuthority: payer,\n      updateAuthority: payer,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      systemProgram: anchor.web3.SystemProgram.programId,\n      rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n      clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n    },\n    signers: [mint],\n    instructions: [\n      anchor.web3.SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: mint.publicKey,\n        space: MintLayout.span,\n        lamports: rent,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        0,\n        payer,\n        payer\n      ),\n      createAssociatedTokenAccountInstruction(\n        token,\n        payer,\n        payer,\n        mint.publicKey\n      ),\n      Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        token,\n        payer,\n        [],\n        1\n      ),\n    ],\n  });\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const getMallocSdk = (wallet: anchor.Provider): MallocSdk => {\n  return new MallocSdk(\n    new PublicKey(getConstants().MALLOC_PROGRAM_ID || \"\"),\n    wallet\n  );\n};\n","import { FlowElement } from \"react-flow-renderer\";\nimport { getConstants } from \"../config/constants\";\nimport { getEdgeId, getNodeId, getRandomNodeId } from \"./node-ids\";\n\nexport const getDefaultSplitterNode: () => FlowElement<any> = () => {\n  const splitterId = getRandomNodeId(\"splitter\");\n  return {\n    id: splitterId,\n    type: \"splitter\",\n    position: { x: 100, y: 100 },\n    data: { id: splitterId },\n  };\n};\n\nexport const getInitSplitter: () => FlowElement<any> = () => {\n  const id = getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID);\n  return {\n    id,\n    type: \"splitter\",\n    position: { x: 100, y: 100 },\n    data: { isInitial: true, id },\n  };\n};\n\nexport const getDefaultSwapNodeSet: () => FlowElement<any>[] = () => {\n  const swapId = getRandomNodeId(\"swap\");\n  const splitterId = getRandomNodeId(\"splitter\");\n  return [\n    {\n      id: swapId, // TODO: something more determistic?\n      type: \"swap\",\n      data: { id: swapId },\n      position: { x: 100, y: 400 },\n    },\n    {\n      id: splitterId,\n      type: \"splitter\",\n      data: { id: splitterId },\n      position: { x: 100, y: 400 + 60 },\n    },\n    {\n      id: getEdgeId(swapId, splitterId),\n      source: swapId,\n      target: splitterId,\n    },\n  ];\n};\n\nexport const getDefaultTransferNodeSet: () => FlowElement<any>[] = () => {\n  const transferId = getRandomNodeId(\"transfer\");\n  return [\n    {\n      id: transferId, // TODO: something more determistic?\n      type: \"transfer\",\n      data: { id: transferId },\n      position: { x: 100, y: 400 },\n    },\n    // {\n    //   id: splitterId,\n    //   type: \"splitter\",\n    //   data: { id: splitterId },\n    //   position: { x: 100, y: 400 + 60 },\n    // },\n    // {\n    //   id: getEdgeId(transferId, splitterId),\n    //   source: transferId,\n    //   target: splitterId,\n    // },\n  ];\n};\n","import { Elements, FlowElement } from \"react-flow-renderer\";\nimport { Store } from \"react-stores\";\nimport { PushElemsFn, SPLToken } from \"../interfaces\";\nimport { getInitSplitter } from \"../utils/premade-nodes\";\n// TODO: from package instead\nimport {\n  AccountsArray,\n  Action,\n} from \"../../../../malloc-core/ts-packages/malloc-sdk/lib/\";\nimport { getConstants } from \"../config/constants\";\nimport { getNodeId } from \"../utils/node-ids\";\nimport { PublicKey, Signer } from \"@solana/web3.js\";\nimport { u64 } from \"@solana/spl-token\";\nimport { TokenInfo } from \"@solana/spl-token-registry\";\n\nexport interface IFlowChart {\n  elements: Elements<any>;\n  actionData: Action[];\n  initSplits: number[];\n  initTokenAccount?: PublicKey;\n  initAmount: u64;\n}\n\nexport interface SolanaSpl {\n  derivedTokenAccounts: SPLToken[] | null;\n  tokenList: TokenInfo[] | null;\n}\n\nexport const solanaSplStore = new Store<SolanaSpl>({\n  derivedTokenAccounts: null,\n  tokenList: null,\n});\n\n/**\n * Exclude action metadata and token mint ins as those get filled in later \n * \n * @param actionAccounts - this does not include the default 3 prepended accounts per action (token account, token program, and token auth)\n */\ntype NodeActionInfo = Omit<Omit<Action, \"actionMetadata\">, \"tokenMintIn\"> & {\n  tokenAccountsOuts: PublicKey[];\n};\n// interface NodeActionInfo {\n//   actionData: Buffer;\n//   actionAccounts: AccountsArray;\n//   signers: Signer[];\n//   tokenMintOuts: PublicKey[];\n//   tokenAccountsOuts: PublicKey[];\n//   actionProgram: PublicKey;\n//   instructions?: TransactionInstruction[];\n\n// }\nexport interface NodeInfos {\n  [elementId: string]: {\n    splitter?: {\n      splits: number[];\n      tokenAccount: PublicKey | undefined;\n      mint: PublicKey | undefined;\n    };\n    action?: NodeActionInfo;\n  };\n}\n\nconst initNodeStore: NodeInfos = {};\ninitNodeStore[getNodeId(\"splitter\", getConstants().INITIAL_SPLITTER_ID_UUID)] =\n  {\n    splitter: {\n      splits: [],\n      mint: undefined,\n      tokenAccount: undefined,\n    },\n  };\nexport const nodeInfoStore = new Store<NodeInfos>(initNodeStore);\n\nexport const flowStore = new Store<IFlowChart>({\n  elements: [getInitSplitter()],\n  actionData: [],\n  initSplits: [],\n  initAmount: new u64(0),\n});\n\nexport const loadingStore = new Store<{\n  storeUpdateLoading: boolean;\n  ephemeralRunLoading: boolean;\n}>({\n  storeUpdateLoading: false,\n  ephemeralRunLoading: false,\n});\n\nexport const setEphemeralRunLoading = (isLoading: boolean) =>\n  loadingStore.setState({\n    ...loadingStore.state,\n    ephemeralRunLoading: isLoading,\n  });\n\nexport const setStoreUpdateLoading = (isLoading: boolean) =>\n  loadingStore.setState({\n    ...loadingStore.state,\n    storeUpdateLoading: isLoading,\n  });\n\nexport const isStoreUpdating = () => loadingStore.state.storeUpdateLoading;\n\nexport const pushElemsOntoFlow: PushElemsFn = (elems) =>\n  flowStore.setState({\n    elements: [...flowStore.state.elements, ...elems],\n  });\n\nexport const setElemsFn: PushElemsFn = (elems) =>\n  flowStore.setState({\n    elements: [...elems],\n  });\n\nexport const setElemFn = (elem: FlowElement<any>, idx: number) => {\n  const newElems = [...flowStore.state.elements];\n  newElems[idx] = elem;\n  flowStore.setState({\n    ...flowStore.state,\n    elements: newElems,\n  });\n};\n","import { u64 } from \"@solana/spl-token\";\nimport { LAMPORTS_PER_EPOCH, MS_PER_EPOCH } from \"./constants\";\n\nexport const calculateRent = (size: number, durationMs: number): number => {\n  const rentCost = Math.ceil(LAMPORTS_PER_EPOCH * size * (durationMs / MS_PER_EPOCH));\n\tconsole.log(\"AAAAA\", rentCost)\n\treturn rentCost\n};\n","export const getConstants = () => {\n  const env = process.env.REACT_APP_SOLANA_NETWORK;\n  switch (env) {\n    case \"devnet\":\n      return {\n        MALLOC_PROGRAM_ID: \"9i4MAnhYagLr1vEo5jdmLehRe8Sm5Lx8fHaQNJfbFCve\",\n        mallocSpl: {\n          TRANSFER_PROGRAM_ID: \"ETpyJNQLorJbAcrPQpM9bkYxYMakegBh93kqZ1KnTBjr\",\n          SWAP_PROGRAM_ID: \"7T6seoCvCQeUeSTf2EAwX5SnyrZvX7BFUMHi74ZodBKH\",\n        },\n        projectSerum: {\n          DEX_PROGRAM_ID: \"DESVgJVGajEgKGXhb6XmqDHGz3VjdgP7rEVESBgxmroY\",\n        },\n        demo: {\n          FAKE_USDC: \"AkzN2jJrorpUY2ApfL2UsBeTfuv1XHFKGLQurZJg6BhN\",\n          FAKE_USDC_GD: \"2BB7fDrLgBNSMCLqD835GisCHrHrGHsS8SJr6brtnWk2\",\n          FAKE_TOKEN_A: \"9GmQdigrAFdX67EMrVFwMepEN8rEdMdp8CPUEPJRY8sj\",\n        },\n        INITIAL_SPLITTER_ID_UUID: \"initial\",\n        solana: {\n          RPC: \"https://explorer-api.devnet.solana.com\",\n          NETWORK: env,\n        },\n      };\n\n    default:\n      throw \"Unexpected env\";\n  }\n  throw \"Unexpected env\";\n};\n","import MALLOC_IDL from \"./idls/malloc.json\";\nimport * as BufferLayout from \"buffer-layout\";\nimport ACTION_TEMPLATE_IDL from \"./idls/action_template.json\";\nimport { BN, Program, Provider, Wallet, web3 } from \"@project-serum/anchor\";\n// import { BN, Program, Provider, web3 } from \"../../../../../forks/anchor/ts\";\nimport { SendTxRequest } from \"@project-serum/anchor/dist/provider\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport {\n  Signer,\n  Transaction,\n  PublicKey,\n  Keypair,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n  SystemProgram,\n} from \"@solana/web3.js\";\nimport {\n  CONSTRUCTION_ACCOUNT_SIZE,\n  LIFETIME_CONSTRUCTION_ACCOUNT_MS,\n  LIFETIME_RESULT_ACCOUNT_MS,\n} from \"./constants\";\nimport { buildSeqListOfActionCalls } from \"./graph-utils\";\nimport {\n  ActionCtxFinal,\n  Action,\n  ActionMetadata,\n  BNIsh,\n  AccountsArray,\n  PartialNextActionCtx,\n  ProcessActionNext,\n} from \"./interfaces\";\nimport {\n  AccountByMint,\n  createTokenAccountsForActions,\n  pkToStr,\n  transferToTx,\n} from \"./spl\";\nimport { calculateRent } from \"./solana-utils\";\n\nexport interface SendRequestsOpts {\n  onPrepareAccountsDone?: (txHashes: string[]) => Promise<any>;\n  prepareCommitment?: web3.ConfirmOptions;\n  actionCommitment?: web3.ConfirmOptions;\n}\n\nexport interface ConstructionData {\n  txsPrepare: SendTxRequest[];\n  txsActionCalls: SendTxRequest[];\n  construction: Signer;\n  resultAccounts: Signer[];\n  tokenAccounts: AccountByMint;\n}\n\n/**\n * @param authority - B58 Encoded public key of the authority\n * @param actions.tokenAccount - B58 Encoded public key of the token account\n */\nexport interface ConstructionStateSerialized {\n  construction: {\n    authority: string;\n    actions: (ActionMetadata & { tokenAccount: string })[];\n    actionCalls: { callAmount: string; numbTimesHit: number }[];\n    readyCallIdxList: number[];\n  };\n}\n\nexport interface BuildEphemeralOpts {\n  associatedTokenAccounts: {\n    [mint: string]: PublicKey;\n  };\n}\n\nexport type BuildEphemeralTxsInstr = {\n  actions: Action[];\n  initialSplits: number[];\n  initialActionIndices: number[];\n  amount: BNIsh;\n  authority?: Signer;\n  amountInAccount: PublicKey;\n  amountInAuthority?: Signer;\n  opts?: Partial<BuildEphemeralOpts>;\n};\n\nexport class MallocSdk {\n  private readonly mallocProgram: Program;\n\n  constructor(\n    private readonly MALLOC_PROGRAM_ID: PublicKey,\n    private readonly provider: Provider\n  ) {\n    this.mallocProgram = new Program(\n      MALLOC_IDL as any,\n      MALLOC_PROGRAM_ID,\n      provider\n    );\n    // TODO: make new program with idl\n  }\n\n  // TODO create token accounts and store there associations\n  // Append on \"withdraw\" functionality and tx to transfer initial into account\n  async buildTxs({\n    actions,\n    initialSplits,\n    initialActionIndices,\n    amount,\n    authority: _authority,\n    amountInAccount,\n    amountInAuthority: _inAuth,\n    opts,\n  }: BuildEphemeralTxsInstr): Promise<ConstructionData> {\n    let amountInAuthority = _inAuth || (this.provider.wallet as Wallet);\n    let authority = _authority || (this.provider.wallet as Wallet);\n\n    const { accounts: tokenAccounts, txs: tokenTxs } =\n      // TODO: disable this and then later have an option to reenable\n      await createTokenAccountsForActions(\n        this.provider,\n        authority,\n        actions,\n        this.provider.wallet as Wallet,\n        opts?.associatedTokenAccounts\n      );\n    const { construction, tx: constructionTx } =\n      await createAndInitConstruction(\n        this.mallocProgram,\n        authority.publicKey,\n        actions.length\n      );\n    const addConstructionActionsTx = addActionsToConstruction(\n      this.mallocProgram,\n      construction.publicKey,\n      actions.map((a) => a.actionMetadata),\n      authority\n    );\n\n    if (!checkMintsAreTheSame(initialActionIndices.map((i) => actions[i]))) {\n      throw \"Expected all initial token types to be the same\";\n    }\n\n    if (initialActionIndices.length === 0)\n      throw \"Expected initial actions to have length more than 0\";\n\n    const initMint = actions[initialActionIndices[0]].tokenMintIn;\n\n    const transferTx = await transferToTx(\n      amountInAccount,\n      tokenAccounts[pkToStr(initMint)].publicKey,\n      new BN(amount), // Add 1 to ensure the accounts don't go to 0 // TODO: does this make sense\n      amountInAuthority\n    );\n\n    const prepareConstructionTx = prepareConstruction(\n      this.mallocProgram,\n      construction.publicKey,\n      initialActionIndices,\n      initialSplits,\n      authority,\n      new BN(amount)\n    );\n\n    const hitOrder = buildSeqListOfActionCalls(\n      actions.map((a) => a.actionMetadata),\n      initialActionIndices\n    );\n    if (hitOrder.length !== actions.length)\n      throw \"An error occurred trying to forecast your construction\";\n\n    const initResultAccounts = await Promise.all(\n      actions.map((a) =>\n        initResultAccount(\n          new Program(\n            ACTION_TEMPLATE_IDL as any,\n            a.actionProgram,\n            this.provider\n          ),\n          // Set the number of out amounts to equal the amount of next nodes\n          a.actionMetadata.nextNodes.length\n        )\n      )\n    );\n\n    // The additional accounts added onto action action accounts follow conventional malloc standards for token\n    // TODO: have an option to not pass in the token accounts\n    const actionCtxFilled: PartialNextActionCtx[] = actions.map((action, i) => {\n      return {\n        ctx: {\n          resultAccount: initResultAccounts[i].resultAccount.publicKey,\n          actionProgram: action.actionProgram,\n        },\n        actionAccounts: [\n          {\n            address: tokenAccounts[pkToStr(action.tokenMintIn)].publicKey,\n            isWriteable: true,\n            isSigner: false,\n          },\n          {\n            address: TOKEN_PROGRAM_ID,\n            isWriteable: false,\n            isSigner: false,\n          },\n          {\n            address: authority.publicKey,\n            isSigner: true,\n            isWriteable: false,\n          },\n          ...action.actionAccounts,\n        ] as AccountsArray,\n      };\n    });\n\n    const processTxs = hitOrder.map((hitIndex) =>\n      processAction(\n        this.mallocProgram,\n        hitIndex,\n        construction.publicKey,\n        actionCtxFilled[hitIndex],\n        authority,\n        {\n          data: actions[hitIndex].actionData,\n          instructions: actions[hitIndex].instructions,\n          additionalSigners: actions[hitIndex].additionalSigners,\n          preActionTxs: actions[hitIndex].preActionTxs,\n        }\n      )\n    );\n\n    // TODO: optional withdraw to accounts\n\n    const txsPrepare = [\n      ...tokenTxs,\n      transferTx,\n      constructionTx,\n      addConstructionActionsTx,\n      prepareConstructionTx,\n      ...initResultAccounts.map((i) => i.tx),\n    ];\n    const txsActionsCalls = [...processTxs.flat()];\n\n    return {\n      construction,\n      txsPrepare: txsPrepare,\n      txsActionCalls: txsActionsCalls,\n      tokenAccounts,\n      resultAccounts: initResultAccounts.map((a) => a.resultAccount),\n    };\n  }\n\n  async getConstructionState(\n    data: ConstructionData\n  ): Promise<ConstructionStateSerialized> {\n    const constructionState: any =\n      (await this.mallocProgram.account.construction.fetch(\n        data.construction.publicKey\n      )) as any;\n    const actionSerialize = (a: any) => {\n      return {\n        tokenAccount: new PublicKey(a.tokenAccount).toBase58(),\n        ripeAmount: a.ripeAmount,\n        nextNodes: a.nextNodes.map((o) =>\n          o.map((nextNode) => {\n            return {\n              actionIdx: nextNode.actionIdx,\n              fraction: new BN(nextNode.fraction).toString(),\n            };\n          })\n        ),\n      };\n    };\n    const actionCallSerialize = (a: any) => {\n      return {\n        numbTimesHit: a.numbTimesHit,\n        callAmount: new BN(a.callAmount).toString(),\n      };\n    };\n    return {\n      construction: {\n        authority: new PublicKey(constructionState.authority).toBase58(),\n        actions: constructionState.actions.map(actionSerialize),\n        actionCalls: constructionState.actionCalls.map(actionCallSerialize),\n        readyCallIdxList: constructionState.readyCallIdxList,\n      },\n    };\n  }\n\n  // TODO:!\n  async deleteEphemeralAccounts(constructionData: ConstructionData) {\n    const withdrawAllRentInstr = (account: Signer) => {};\n    constructionData.construction;\n  }\n\n  async sendRequests(\n    data: ConstructionData,\n    options?: SendRequestsOpts\n  ): Promise<string[]> {\n    await this.provider;\n    const txHashesPrepare =\n      data.txsPrepare.length > 0\n        ? await this.provider.sendAll(data.txsPrepare, {\n            // skipPreflight: true,\n            ...(options?.prepareCommitment || {}),\n          })\n        : [];\n    if (options?.onPrepareAccountsDone && txHashesPrepare.length > 0)\n      await options.onPrepareAccountsDone(txHashesPrepare);\n    const txHashes = await this.provider.sendAll(data.txsActionCalls, {\n      // skipPreflight: true,\n      ...(options?.actionCommitment || {}),\n    });\n    return [...txHashesPrepare, ...txHashes];\n  }\n}\n\nconst createAndInitConstruction = async (\n  program: Program,\n  authority: PublicKey,\n  numbActions: number\n): Promise<{ construction: Signer; tx: SendTxRequest }> => {\n  const ConstructionAccount = web3.Keypair.generate();\n  const tx = program.transaction.initConstruction(numbActions, {\n    accounts: {\n      construction: ConstructionAccount.publicKey,\n      authority,\n      rent: web3.SYSVAR_RENT_PUBKEY,\n    },\n    signers: [ConstructionAccount],\n    instructions: [\n      await SystemProgram.createAccount({\n        fromPubkey: program.provider.wallet.publicKey,\n        newAccountPubkey: ConstructionAccount.publicKey,\n        space: CONSTRUCTION_ACCOUNT_SIZE + 8,\n        lamports: calculateRent(\n          CONSTRUCTION_ACCOUNT_SIZE + 8,\n          LIFETIME_CONSTRUCTION_ACCOUNT_MS\n        ),\n        programId: program.programId,\n      }),\n      // await program.account.construction.createInstruction,\n    ],\n  });\n\n  return {\n    tx: { tx, signers: [ConstructionAccount] },\n    construction: ConstructionAccount,\n  };\n};\n\nconst addActionsToConstruction = (\n  program: Program,\n  construction: PublicKey,\n  actions: ActionMetadata[],\n  authority: Signer | Wallet\n): SendTxRequest => {\n  const signers = (authority as Signer).secretKey ? [authority as Signer] : [];\n  return {\n    tx: program.transaction.addActions(actions, {\n      accounts: {\n        authority: authority.publicKey,\n        construction: construction,\n        rent: web3.SYSVAR_RENT_PUBKEY,\n      },\n      signers: signers,\n    }),\n    signers,\n  };\n};\n\nconst prepareConstruction = (\n  program: Program,\n  construction: PublicKey,\n  initActionIdx: number[],\n  initActionSplits: number[],\n  authority: Signer | Wallet,\n  amount: BN\n): SendTxRequest => {\n  const signers = (authority as Signer).secretKey ? [authority as Signer] : [];\n  return {\n    tx: program.transaction.prepareConstruction(\n      initActionIdx,\n      initActionSplits.map((i) => new BN(i)),\n      amount,\n      {\n        accounts: {\n          authority: authority.publicKey,\n          construction: construction,\n          rent: web3.SYSVAR_RENT_PUBKEY,\n        },\n        signers,\n      }\n    ),\n    signers,\n  };\n};\n\n/**\n * @param tokenAuthority - defaults to the authority if not provided\n */\nconst processAction = (\n  program: Program,\n  actionIdx: number,\n  construction: PublicKey,\n  actionAccountsCtx: PartialNextActionCtx,\n  authority: Signer | Wallet,\n  opts: {\n    data?: Buffer;\n    tokenAuthority?: Signer | Wallet;\n    instructions?: TransactionInstruction[];\n    additionalSigners?: Signer[];\n    preActionTxs?: SendTxRequest[];\n  }\n): SendTxRequest[] => {\n  const auth = (authority as Signer)?.secretKey ? [authority as Signer] : [];\n  const tokauth = (opts.tokenAuthority as Signer)?.secretKey\n    ? [opts.tokenAuthority as Signer]\n    : [];\n  const signersPartial = opts.tokenAuthority\n    ? [...tokauth, ...auth]\n    : [...auth];\n  const signers = [...signersPartial, ...(opts.additionalSigners || [])];\n  return [\n    ...(opts.preActionTxs || []),\n    {\n      tx: program.transaction.processAction(\n        actionIdx,\n        opts.data || Buffer.from([]),\n        {\n          accounts: {\n            construction: construction,\n            rent: web3.SYSVAR_RENT_PUBKEY,\n            authority: authority.publicKey,\n            actionCtxProxy: actionAccountsCtx.ctx,\n            actionAccounts: actionAccountsCtx.actionAccounts,\n          } as ProcessActionNext,\n          signers,\n          instructions: opts.instructions || undefined,\n        }\n      ),\n      signers,\n    },\n  ];\n};\n\nconst initResultAccount = async (\n  actionTemplateProgram: Program,\n  numberOfPossibleOutputTokens: number\n): Promise<{ tx: SendTxRequest; resultAccount: Signer }> => {\n  const result = Keypair.generate();\n  actionTemplateProgram.provider.connection.getMinimumBalanceForRentExemption;\n  const resultSize = calcSizeResultAccount(numberOfPossibleOutputTokens);\n  const tx = actionTemplateProgram.transaction.initResultAccount(\n    numberOfPossibleOutputTokens,\n    {\n      accounts: {\n        result: result.publicKey,\n        rent: web3.SYSVAR_RENT_PUBKEY,\n      },\n      instructions: [\n        await SystemProgram.createAccount({\n          fromPubkey: actionTemplateProgram.provider.wallet.publicKey,\n          newAccountPubkey: result.publicKey,\n          space: resultSize,\n          lamports: calculateRent(resultSize, LIFETIME_RESULT_ACCOUNT_MS),\n          programId: actionTemplateProgram.programId,\n        }),\n      ],\n      signers: [result],\n    }\n  );\n  return {\n    tx: { tx, signers: [result] },\n    resultAccount: result,\n  };\n};\n\n// From https://github.com/solana-labs/solana-program-library/blob/30406eea40671afefa18b5ae6c9b37ffcb6235d0/token/js/client/token.js#L1850\n/**\n * Construct a Close instruction\n *\n * @param programId SPL Token program account\n * @param account Account to close\n * @param dest Account to receive the remaining balance of the closed account\n * @param authority Account Close authority\n * @param multiSigners Signing accounts if `owner` is a multiSig\n */\nconst createCloseAccountInstruction = (\n  programId: PublicKey,\n  account: PublicKey,\n  dest: PublicKey,\n  owner: PublicKey\n): TransactionInstruction => {\n  throw \"TODO\";\n};\n\n// 8 for the discriminator, 32 for the owner pubkey, 4 for the number of results, and the rest for numb actions, then 64 as a buffer\nconst calcSizeResultAccount = (numberOfActions: number) =>\n  8 + 32 + 4 + numberOfActions * 8 + 64;\n\nconst checkMintsAreTheSame = (actions: Action[]) => {\n  if (actions.length === 0) return true;\n  const mint = pkToStr(actions[0].tokenMintIn);\n  return actions.every((a) => pkToStr(a.tokenMintIn) === mint);\n};\n","export * from \"./contexts\";\nexport * from \"./common\";\n","import {\n  Account,\n  Connection,\n  Keypair,\n  PublicKey,\n  Signer,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { MintInfo, TOKEN_PROGRAM_ID, u64 } from \"@solana/spl-token\";\nimport { Side, SwapAccounts, SwapInstructionByte } from \"./swap-interfaces\";\nimport { AccountsArray, Action, ActionMetadata } from \"@malloc/sdk\";\nimport { BN, Provider, web3 } from \"@project-serum/anchor\";\nimport { TokenInfo, TokenListContainer } from \"@solana/spl-token-registry\";\nimport { Market, OpenOrders, TokenInstructions } from \"@project-serum/serum\";\nimport {\n  connection,\n  parseMintAccount,\n  SendTxRequest,\n} from \"@project-serum/common\";\nimport { Swap } from \"@project-serum/swap\";\n\nexport * from \"./swap-interfaces\";\n\ninterface SwapInput {\n  provider: Provider;\n  tokenList: TokenListContainer;\n  authority: PublicKey;\n  inTokenAccount: PublicKey;\n  outTokenAccount: PublicKey;\n  inMint: PublicKey;\n  outMint: PublicKey;\n  serumDexProgramId: PublicKey;\n  rent: PublicKey;\n  openOrdersAccount?: PublicKey;\n}\n\nexport const buildPartialSwapAction = async (\n  inp: SwapInput & { swapActionProgram: PublicKey; minOut: u64 }\n): Promise<(metadata?: ActionMetadata) => Omit<Action, \"actionMetadata\">> => {\n  const swapInfo = await buildSwapAccounts(inp);\n\n  return (metadata?: ActionMetadata) => {\n    return {\n      actionMetadata: metadata,\n      actionData: packSwapData(\n        SwapInstructionByte.BasicSwap,\n        swapInfo.side,\n        inp.minOut\n      ),\n      actionAccounts: swapAccountsToActionAccounts(\n        swapInfo.swapAccounts,\n        swapInfo.side\n      ),\n      actionProgram: inp.swapActionProgram,\n      tokenMintIn: inp.inMint,\n      tokenMintOuts: [inp.outMint],\n      preActionTxs: swapInfo.openOrderInitTx ? [swapInfo.openOrderInitTx] : [],\n    };\n  };\n};\n\nexport const buildSwapAccounts = async (\n  inp: SwapInput\n): Promise<{\n  swapAccounts: SwapAccounts;\n  openOrderInitTx?: SendTxRequest;\n  market: Market;\n  side: Side;\n}> => {\n  const marketRet = await getMarket(\n    inp.provider.connection,\n    inp.inMint,\n    inp.outMint,\n    inp.serumDexProgramId\n  );\n  if (!marketRet) throw \"No markets found\";\n\n  const { side, pk: marketPk } = marketRet;\n  const marketSel = await Market.load(\n    inp.provider.connection,\n    marketPk,\n    {},\n    inp.serumDexProgramId\n  );\n\n  const openOrderAccountData = await getOpenOrdersAccount(\n    inp.provider.connection,\n    marketSel,\n    inp.authority,\n    inp.serumDexProgramId\n  );\n\n  const [vaultSigner, _] = await getVaultOwnerAndNonce(\n    marketSel.decoded.ownAddress,\n    inp.serumDexProgramId\n  );\n\n  const coinWallet =\n    side === Side.Bid ? inp.outTokenAccount : inp.inTokenAccount;\n  const pcWallet = side === Side.Bid ? inp.inTokenAccount : inp.outTokenAccount;\n\n  return {\n    market: marketSel,\n    swapAccounts: {\n      market: {\n        market: marketSel.decoded.ownAddress,\n        requestQueue: marketSel.decoded.requestQueue,\n        eventQueue: marketSel.decoded.eventQueue,\n        bids: marketSel.decoded.bids,\n        asks: marketSel.decoded.asks,\n        coinVault: marketSel.decoded.baseVault,\n        pcVault: marketSel.decoded.quoteVault,\n        vaultSigner: vaultSigner,\n        // User params.\n        openOrders: inp.openOrdersAccount || openOrderAccountData.openOrderPk,\n        orderPayerTokenAccount: inp.inTokenAccount,\n        coinWallet: coinWallet,\n      },\n      pcWallet,\n      authority: inp.authority,\n      dexProgram: inp.serumDexProgramId,\n      tokenProgram: TOKEN_PROGRAM_ID,\n      rent: inp.rent,\n    },\n\n    openOrderInitTx: inp.openOrdersAccount\n      ? undefined\n      : openOrderAccountData.openOrderTx,\n    side,\n  };\n};\n\n/**\n * get the open order accounts associated with the market and owner\n * \n * If none exist, create a new account and return a tx to create/ init the account as well\n */\nconst getOpenOrdersAccount = async (\n  connection: Connection,\n  market: Market,\n  owner: PublicKey,\n  dexPID: PublicKey\n): Promise<{\n  openOrderPk: PublicKey;\n  openOrderTx?: SendTxRequest;\n}> => {\n  const openOrders = await OpenOrders.findForMarketAndOwner(\n    connection,\n    market.address,\n    owner,\n    dexPID\n  );\n  if (openOrders.length === 0) {\n    const openOrderAccount = new Account(new Keypair().secretKey);\n    const openOrdersTx = new Transaction();\n    openOrdersTx.add(\n      await OpenOrders.makeCreateAccountTransaction(\n        connection,\n        market.decoded.ownAddress,\n        owner,\n        openOrderAccount.publicKey,\n        dexPID\n      )\n    );\n\n    return {\n      openOrderPk: openOrderAccount.publicKey,\n      openOrderTx: {\n        tx: openOrdersTx,\n        signers: [openOrderAccount],\n      },\n    };\n  } else {\n    return {\n      openOrderPk: openOrders[0].publicKey,\n    };\n  }\n};\n\n// TODO: this just takes the first market available... have some sorta best market in the future?\nexport const getMarket = async (\n  connection: Connection,\n  inMint: PublicKey,\n  outMint: PublicKey,\n  serumDexProgramId: PublicKey\n) => {\n  // TODO: slightly confused about side\n  let side = Side.Ask;\n  let marketPks = await getMarketsFromBaseMinttoQuoteMint(\n    connection,\n    inMint,\n    outMint,\n    serumDexProgramId\n  );\n\n  // Try the other market side\n  if (!marketPks || marketPks.length === 0) {\n    marketPks = await getMarketsFromBaseMinttoQuoteMint(\n      connection,\n      outMint,\n      inMint,\n      serumDexProgramId\n    );\n    side = Side.Bid;\n  }\n  if (!marketPks || marketPks.length === 0) return null;\n  return { pk: marketPks[0], side };\n};\n\nexport const packSwapData = (\n  instrByte: SwapInstructionByte,\n  side: Side,\n  minOut: u64\n): Buffer => {\n  const packedMinOut = minOut.toArrayLike(Buffer, \"be\", 8);\n  const initPart = Buffer.from(new Uint8Array([instrByte, side]));\n  return Buffer.concat([initPart, packedMinOut]);\n};\n\nexport const swapAccountsToActionAccounts = (\n  swapAccounts: SwapAccounts,\n  side: Side,\n  referralAccount?: PublicKey\n): AccountsArray => {\n  const tokenAccount =\n    side === Side.Bid ? swapAccounts.pcWallet : swapAccounts.market.coinWallet;\n  const outAccount =\n    side === Side.Bid ? swapAccounts.market.coinWallet : swapAccounts.pcWallet;\n  const accounts = [\n    {\n      isWriteable: true,\n      address: tokenAccount,\n    },\n    {\n      address: swapAccounts.tokenProgram,\n    },\n    {\n      address: swapAccounts.authority,\n      isSigner: true,\n    },\n    {\n      address: swapAccounts.rent,\n    },\n    {\n      address: swapAccounts.dexProgram,\n    },\n    {\n      address: outAccount,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.market,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.openOrders,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.requestQueue,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.eventQueue,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.bids,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.asks,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.orderPayerTokenAccount,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.coinVault,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.pcVault,\n      isWriteable: true,\n    },\n    {\n      address: swapAccounts.market.vaultSigner,\n    },\n  ];\n  if (referralAccount) {\n    accounts.push({\n      address: referralAccount,\n      isWriteable: true,\n    });\n  }\n  return accounts;\n};\n\nexport async function getVaultOwnerAndNonce(\n  marketPublicKey: PublicKey,\n  dexProgramId: PublicKey\n): Promise<[PublicKey, BN]> {\n  const nonce = new BN(0);\n  while (nonce.toNumber() < 255) {\n    try {\n      const vaultOwner = await PublicKey.createProgramAddress(\n        [marketPublicKey.toBuffer(), nonce.toArrayLike(Buffer, \"le\", 8)],\n        dexProgramId\n      );\n      return [vaultOwner, nonce];\n    } catch (e) {\n      nonce.iaddn(1);\n    }\n  }\n  throw new Error(\"Unable to find nonce\");\n}\n\nconst getMarketsFromBaseMinttoQuoteMint = async (\n  connection: Connection,\n  baseMint: PublicKey,\n  quoteMint: PublicKey,\n  serumProgId: PublicKey\n): Promise<PublicKey[]> => {\n  const layout = await Market.getLayout(serumProgId);\n\n  return (\n    await Market.findAccountsByMints(\n      connection,\n      baseMint,\n      quoteMint,\n      serumProgId\n    )\n  ).map((e) => e.publicKey);\n};\n\nconst getAllMarkets = async (conn: Connection, progId: PublicKey) => {\n  Market.findAccountsByMints;\n};\n\nexport const getDemoTokenInfo = async (\n  provider: Provider,\n  fakeUsdc: PublicKey | string,\n  fakeTokA: PublicKey | string\n): Promise<TokenInfo[]> => {\n  const usdcMint = new PublicKey(fakeUsdc);\n  const aMint = new PublicKey(fakeTokA);\n  const usdcInfo = await getMintInfo(provider, usdcMint);\n  const aInfo = await getMintInfo(provider, aMint);\n  if (!usdcInfo || !aInfo) {\n    throw \"Expected info for these mints\";\n  }\n  return [\n    {\n      ...usdcInfo,\n      chainId: -1,\n      name: \"FAKE USDC\",\n      symbol: \"FUSDC\",\n      address: new PublicKey(fakeUsdc).toBase58(),\n    },\n    {\n      ...aInfo,\n      chainId: -1,\n      name: \"FAKE: A TOKEN\",\n      symbol: \"FA TOKEN\",\n      address: new PublicKey(fakeTokA).toBase58(),\n    },\n  ];\n};\n\nexport const getMintInfo = async (\n  provider: Provider,\n  mintAddr: PublicKey\n): Promise<MintInfo | null> => {\n  const account = await provider.connection.getAccountInfo(mintAddr);\n  if (!account) return null;\n  return parseMintAccount(account.data);\n};\n","export * from './malloc-sdk'\nexport * from './interfaces'\nimport _MallocIdl from './idls/malloc.json'\nexport const MallocIdl = _MallocIdl","import { ActionMetadata } from \"./interfaces\";\n\n// TODO: there is a lot of cool stuff to do here\n\ntype ToHitArg = { called: number[] };\n\nexport const buildSeqListOfActionCalls = (\n  actionMetas: ActionMetadata[],\n  initIndices: number[]\n): number[] => {\n  const initHitCounts = [...Array(actionMetas.length)].fill(0);\n  const called = simulateDAG(\n    actionMetas.map((a, i) => {\n      return { ...a, id: i };\n    }),\n    initHitCounts,\n    initIndices\n  );\n\n  return called;\n};\n\n// Returns an ordered list of indices hit\nconst simulateDAG = (\n  actionMetas: (ActionMetadata & { id: number })[],\n  hitCounts: number[],\n  toHit: number[]\n): number[] => {\n  if (toHit.length === 0) return [];\n  const newHitCounts = hitCounts.map((e, i) => getOccurrence(toHit, i) + e)\n  const newRipeActions = actionMetas.filter(\n    (a) => a.ripeAmount === newHitCounts[a.id] && toHit.includes(a.id)\n  );\n  const newToHit = newRipeActions\n    .map((a) => a.nextNodes.map((o) => o.map((i) => i.actionIdx)))\n    .flat()\n    .flat();\n  return [\n    ...newRipeActions.map((a) => a.id),\n    ...simulateDAG(actionMetas, newHitCounts, newToHit),\n  ];\n};\n\nconst getOccurrence = <T>(array: T[], value: T) =>\n  array.filter((v) => v === value).length;\n","import TextField from \"@material-ui/core/TextField\";\nimport { useAnchorWallet } from \"@solana/wallet-adapter-react\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport React from \"react\";\nimport { useEffect } from \"react\";\nimport { useState } from \"react\";\nimport { getConstants } from \"../../config/constants\";\nimport { PushElemsFn } from \"../../interfaces\";\nimport {\n  flowStore,\n  IFlowChart,\n  NodeInfos,\n  nodeInfoStore,\n  setStoreUpdateLoading,\n} from \"../../state/flowchart-store\";\nimport { getProvider } from \"../../utils/anchor\";\nimport { findAssociatedTokenAddress } from \"../../utils/spl-tokens\";\nimport { ActionNodeProps } from \"./ActionTemplate\";\n\nexport const TransferNode = (props: ActionNodeProps) => {\n  const [recipientAddr, setRecipientAddr] = useState<string>(\"\");\n  const wallet = useAnchorWallet();\n\n  useEffect(() => {\n    if (props.toggleNodeInfoSet !== null) setRecipientAddrInStore();\n  }, [props.toggleNodeInfoSet]);\n\n  const setRecipientAddrInStore = async () => {\n    if (!recipientAddr) return;\n    let recipientPk: PublicKey;\n    setStoreUpdateLoading(true);\n    try {\n      recipientPk = new PublicKey(recipientAddr);\n    } catch (e) {\n      alert(\"Invalid recipient account\");\n      setStoreUpdateLoading(false);\n      return;\n    }\n    if (!props.mint) {\n      setStoreUpdateLoading(false);\n      return;\n    }\n    const recipientTokAccountAddr = await findAssociatedTokenAddress(\n      recipientPk,\n      props.mint\n    );\n    const recipientTokAccountData = await getProvider(\n      wallet!\n    ).connection.getAccountInfo(recipientTokAccountAddr);\n    if (!recipientTokAccountData) {\n      // TODO: have this auto expand...\n      alert(\n        \"Looks like the user does not have an associated account with this mint!\"\n      );\n      setStoreUpdateLoading(false);\n      return;\n    }\n\n    props.nodeInfoStoreState[props.id] = {\n      action: {\n        actionData: Buffer.from([]),\n        actionProgram: new PublicKey(\n          getConstants().mallocSpl.TRANSFER_PROGRAM_ID\n        ),\n        actionAccounts: [\n          {\n            address: recipientTokAccountAddr,\n            isWriteable: true,\n          },\n        ],\n        additionalSigners: [],\n        tokenMintOuts: [],\n        tokenAccountsOuts: [],\n      },\n    };\n    nodeInfoStore.setState(props.nodeInfoStoreState);\n    setStoreUpdateLoading(false);\n  };\n\n  return (\n    <>\n      <h4>Transfer Action</h4>\n      <p>Input token: {props.mintName}</p>\n      <TextField\n        value={recipientAddr}\n        label=\"Recipient Address\"\n        onChange={(e) => setRecipientAddr(e.target.value)}\n        onBlur={(e) => setRecipientAddrInStore()}\n      />\n    </>\n  );\n};\n"],"sourceRoot":""}